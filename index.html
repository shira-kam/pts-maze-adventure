<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elephant Maze Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #2E8B57;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }
        
        #gameContainer {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            min-height: 600px;
            transition: background 0.3s ease;
        }
        
        #gameContainer.rocket-boost {
            background: linear-gradient(135deg, #FF4500, #FF8C00, #FFD700);
        }
        
        #gameContainer.rocket-boost.blinking {
            animation: rocketBlink 0.5s infinite alternate;
        }
        
        @keyframes rocketBlink {
            0% { background: linear-gradient(135deg, #FF4500, #FF8C00, #FFD700); }
            100% { background: white; }
        }
        
        #gameCanvas {
            border: 3px solid #2E8B57;
            border-radius: 10px;
            display: block;
        }
        
        #gameInfo {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
        }
        
        #score {
            color: #FF6347;
        }
        
        #level {
            color: #4169E1;
        }
        
        #puzzleModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 5000;
        }
        
        #puzzleContent {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-width: 500px;
            max-width: 900px;
            width: 1000px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            max-height: 85vh;
            overflow-y: auto;
        }
        
        #puzzleTitle {
            font-size: 28px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #puzzleQuestion {
            font-size: 20px;
            margin-bottom: 25px;
        }
        
        .puzzle-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 20px 40px;
            margin: 12px;
            border-radius: 25px;
            font-size: 24px;
            cursor: pointer;
            font-family: inherit;
            min-width: 100px;
            min-height: 80px;
        }
        
        .puzzle-button:hover {
            background: #45a049;
        }
        
        
        #celebrationScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #87CEEB;
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #celebrationContent {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #celebrationSprite {
            margin-top: 20px;
        }
        
        #playAgainBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 25px;
            cursor: pointer;
            margin-bottom: 20px;
            font-family: inherit;
            font-weight: bold;
        }
        
        #playAgainBtn:hover {
            background: #45a049;
        }
        
        #difficultyScreen {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #difficultyContent {
            text-align: center;
            background: white;
            padding: 50px;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        #difficultyTitle {
            font-size: 36px;
            color: #2E8B57;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .difficulty-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 25px 40px;
            margin: 15px;
            border-radius: 25px;
            font-size: 24px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            min-width: 250px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .difficulty-button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        
        .difficulty-button.easy {
            background: #4CAF50;
        }
        
        .difficulty-button.medium {
            background: #FF9800;
        }
        
        .difficulty-button.hard {
            background: #F44336;
        }
        
        #debugScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 4000;
            overflow-y: auto;
            color: white;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        
        #debugContent {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        #debugTitle {
            font-size: 32px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .debug-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #FFD700;
        }
        
        .debug-section h3 {
            color: #FFD700;
            margin-top: 0;
            font-size: 24px;
        }
        
        .celebration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .celebration-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid #666;
        }
        
        .celebration-item h4 {
            color: #FFD700;
            margin-top: 0;
        }
        
        .celebration-preview {
            width: 200px;
            height: 200px;
            border: 2px solid #FFD700;
            margin: 10px auto;
            background: #333;
        }
        
        .debug-button {
            background: #FFD700;
            color: black;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .debug-button:hover {
            background: #FFA500;
        }
        
        #debugCloseBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #F44336;
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            z-index: 4001;
        }
        
        #debugCloseBtn:hover {
            background: #D32F2F;
        }
        
        
        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #gameOverContent {
            text-align: center;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        #gameOverContent h1 {
            font-size: 48px;
            margin: 0;
        }
        
        #gameOverSprite {
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        #gameOverBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 25px 50px;
            font-size: 28px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            min-width: 250px;
        }
        
        #gameOverBtn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        #seeScoreBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 25px 50px;
            font-size: 28px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            min-width: 250px;
        }
        
        #seeScoreBtn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        #finalScoreScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            z-index: 3500;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #finalScoreContent {
            text-align: center;
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            max-width: 600px;
            min-width: 500px;
        }
        
        #finalScoreTitle {
            font-size: 36px;
            color: #2E8B57;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .level-score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            margin: 5px 0;
            background: #f0f8ff;
            border-radius: 10px;
            border-left: 5px solid #4CAF50;
        }
        
        .level-wall-block {
            width: 30px;
            height: 30px;
            background-size: cover;
            background-repeat: no-repeat;
            border-radius: 3px;
            margin-right: 10px;
        }
        
        .level-score-item.special {
            background: #fffacd;
            border-left-color: #FFD700;
        }
        
        .level-score-number {
            font-size: 18px;
            font-weight: bold;
            color: #2E8B57;
        }
        
        .level-score-hearts {
            font-size: 16px;
        }
        
        #totalScoreSection {
            margin-top: 30px;
            padding: 20px;
            background: #e6f3ff;
            border-radius: 15px;
            border: 3px solid #4CAF50;
        }
        
        #totalScoreText {
            font-size: 28px;
            font-weight: bold;
            color: #2E8B57;
            margin-bottom: 10px;
        }
        
        #finalScoreBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 20px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            font-family: inherit;
            font-weight: bold;
        }
        
        #finalScoreBtn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        
    </style>
</head>
<body>
    
    <div id="gameContainer">
        <div id="gameInfo">
            <div id="score">♥️♥️♥️♥️♥️</div>
            <div id="level">Level: 1</div>
        </div>
        
        <canvas id="gameCanvas" width="880" height="880"></canvas>
    </div>
    
    <div id="puzzleModal">
        <div id="puzzleContent">
            <h2 id="puzzleTitle">Puzzle Time!</h2>
            <p id="puzzleQuestion"></p>
            <div id="puzzleOptions"></div>
            <div id="puzzleResult"></div>
        </div>
    </div>
    
    <div id="celebrationScreen">
        <div id="celebrationContent">
            <button id="playAgainBtn" onclick="playAgain()">Play Again</button>
            <canvas id="celebrationSprite" width="800" height="900"></canvas>
        </div>
    </div>
    
    
    <div id="difficultyScreen">
        <div id="difficultyContent">
            <div id="difficultyTitle">Choose Your Difficulty</div>
            <button class="difficulty-button easy" onclick="selectDifficulty('easy')">Easy Peasy 🫛</button>
            <button class="difficulty-button medium" onclick="selectDifficulty('medium')">Neutral 😐</button>
            <button class="difficulty-button hard" onclick="selectDifficulty('hard')">Hard Mode 🙀</button>
        </div>
    </div>
    
    <div id="debugScreen">
        <button id="debugCloseBtn" onclick="closeDebugMode()">✕ Close Debug</button>
        <div id="debugContent">
            <div id="debugTitle">🐛 DEBUG MODE 🐛</div>
            
            <div class="debug-section">
                <h3>🎮 Level Selection</h3>
                <p>Jump to any level for testing:</p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;">
                    <button class="debug-button" onclick="jumpToLevel(1)">Jump to Level 1</button>
                    <button class="debug-button" onclick="jumpToLevel(2)">Jump to Level 2</button>
                    <button class="debug-button" onclick="jumpToLevel(3)">Jump to Level 3</button>
                    <button class="debug-button" onclick="jumpToLevel(4)">Jump to Level 4</button>
                    <button class="debug-button" onclick="jumpToLevel(5)">Jump to Level 5</button>
                    <button class="debug-button" onclick="jumpToLevel(6)">Jump to Level 6</button>
                    <button class="debug-button" onclick="jumpToLevel(7)">Jump to Level 7</button>
                    <button class="debug-button" onclick="jumpToLevel(8)">Jump to Level 8</button>
                    <button class="debug-button" onclick="jumpToLevel(9)">Jump to Level 9</button>
                    <button class="debug-button" onclick="jumpToLevel(10)">Jump to Level 10 (Debug)</button>
                </div>
                <p style="margin-top: 10px; font-size: 14px; color: #ccc;">Current Level: <span id="debugCurrentLevel">1</span></p>
            </div>
            
            <div class="debug-section">
                <h3>🧪 Test Versions</h3>
                <p>Test alternative starting positions for number line levels:</p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;">
                    <button class="debug-button" onclick="jumpToTestLevel(4)">Test Level 4 (Start at 0)</button>
                </div>
                <p style="margin-top: 10px; font-size: 14px; color: #ccc;">Test versions start PT at 0 with black 0 square</p>
            </div>
            
            <div class="debug-section">
                <h3>🎉 Celebration Animations</h3>
                <p>View all celebration sprites from each level:</p>
                <button class="debug-button" onclick="loadDebugCelebrationSprites()" style="margin-bottom: 15px;">🔄 Reload All Sprites</button>
                <div class="celebration-grid">
                    <div class="celebration-item">
                        <h4>Level 1 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration1" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(1)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(1)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 2 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration2" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(2)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(2)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 3 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration3" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(3)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(3)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 4 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration4" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(4)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(4)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 5 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration5" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(5)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(5)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 6 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration6" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(6)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(6)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 7 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration7" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(7)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(7)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 8 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration8" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(8)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(8)">Stop</button>
                    </div>
                    
                    <div class="celebration-item">
                        <h4>Level 9 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration9" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(9)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(9)">Stop</button>
                    </div>
                    
                    <div class="celebration-item">
                        <h4>Level 10 - PT Celebration (Debug Only)</h4>
                        <canvas class="celebration-preview" id="debugCelebration10" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(10)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(10)">Stop</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <div id="gameOverContent">
            <h1>GAME OVER</h1>
            <canvas id="gameOverSprite" width="436" height="436"></canvas>
            <button id="seeScoreBtn" onclick="showGameOverScore()">See Score</button>
        </div>
    </div>
    
    <div id="finalScoreScreen">
        <div id="finalScoreContent">
            <div id="finalScoreTitle">🎉 Congratulations! 🎉</div>
            
            <div id="levelScoresContainer">
                <!-- Level scores will be populated here -->
            </div>
            
            <div id="totalScoreSection">
                <div id="totalScoreText">Total Score: 0 ♥️</div>
                <p style="font-size: 16px; color: #666; margin: 5px 0;">Lives remaining across all levels</p>
            </div>
            
            <button id="finalScoreBtn" onclick="restartFromFinalScore()">Play Again</button>
        </div>
    </div>
    
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // CSV Parser for dynamic maze loading
        async function loadMazeFromCSV() {
            try {
                // Level 10 uses level 9's maze (debug duplicate)
                const mazeLevel = game.selectedDifficulty === 10 ? 9 : game.selectedDifficulty;
                const csvPath = `level-${mazeLevel}/grid.csv`;
                console.log(`Attempting to load ${csvPath}...`);
                console.log('Selected difficulty:', game.selectedDifficulty);
                const response = await fetch(csvPath + '?v=' + Date.now());
                console.log('Fetch response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                console.log('CSV loaded successfully, length:', csvText.length);
                console.log('First few lines:', csvText.split('\n').slice(0, 3).join('\n'));
                console.log('Looking for r1/r2 doors in CSV:', csvText.includes('r1'), csvText.includes('r2'));
                return parseMazeFromCSV(csvText);
            } catch (error) {
                console.error('Error loading CSV for level', game.selectedDifficulty, ':', error);
                console.log('Falling back to embedded CSV data');
                // Fallback to embedded CSV data if file load fails
                const fallbackCSV = `,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T
1,o,o,o,o,o,o,o,o,o,o,o,o,o,m,o,o,o,o,o,o
2,,o,,,,,,,,,,,,,,,o,,,o
3,,r,o,o,o,,o,,o,o,o,o,o,o,o,,o,,,
4,,,,,o,,o,,o,,,,,,o,,o,o,o,m
5,o,o,o,o,o,,o,o,r,,o,o,o,o,o,,,,,o
6,m,,,,,,,,o,,o,,,,,,,,,o
7,o,o,o,o,o,o,m,,o,,o,,o,o,o,o,o,o,o,o
8,,,,,,,o,,o,,m,,,,,,,,,o
9,,o,o,m,o,,o,,o,,o,o,o,o,o,o,o,o,o,o
10,,o,,,o,,o,,o,,,,,,,,,,,r
11,,o,,o,o,o,o,o,r,o,o,m,o,o,o,o,o,o,,o
12,,o,,,,,o,,o,,,,,,,,,o,,o
13,,o,o,o,o,o,o,,o,,,o,o,o,o,o,,o,,o
14,,,,,,,,,o,o,o,r,,,,m,,o,o,o
15,o,o,o,o,o,o,o, ,o,,,o,,m,,o,,,,
16,r,,,,,,,,o,o,o,o,,o,,o,o,o,o,o
17,o,,o,o,o,o,o,o,o,,,,,o,,,,,,o
18,o,,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o
19,m,,,,,,,,,,,,,,,,,,,o
20,o,o,o,o,o,o,o,o,o,r,o,o,o,o,o,m,o,o,o,w`;
                return parseMazeFromCSV(fallbackCSV);
            }
        }
        
        function parseMazeFromCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const doors = [];
            const paths = [];
            const bonusItems = [];
            let watering_hole = null;
            
            // Skip header row (line 0)
            for (let rowIndex = 1; rowIndex < lines.length; rowIndex++) {
                const cells = lines[rowIndex].split(',');
                
                // Skip first column (row number), start from column 1
                for (let colIndex = 1; colIndex < cells.length; colIndex++) {
                    const cellValue = cells[colIndex].trim();
                    
                    // Calculate actual coordinates (0-based for arrays)
                    const x = (colIndex - 1) * 40; // Column A=0, B=1, etc. * 40
                    const y = (rowIndex - 1) * 40; // Row 1=0, Row 2=1, etc. * 40
                    
                    switch (cellValue) {
                        case 'o':
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'm':
                            doors.push({ x, y, type: 'math', open: false, color: '#FF6B6B' });
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'r':
                            doors.push({ x, y, type: 'reading', open: false, color: '#4ECDC4' });
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'r1':
                            doors.push({ x, y, type: 'reading1', open: false, color: '#9C27B0' }); // Purple
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'r2':
                            doors.push({ x, y, type: 'reading2', open: false, color: '#FF9800' }); // Orange
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 's':
                            doors.push({ x, y, type: 'sorting', open: false, color: '#FFD93D' });
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'w':
                            watering_hole = { x, y };
                            // Add path under watering hole for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'h':
                            // Heart collectible - add to paths and track as heart
                            paths.push({ x, y, width: 40, height: 40, type: 'heart', collected: false });
                            break;
                        case 'b':
                            // Bonus collectible (level 9) - add to paths and track as bonus
                            bonusItems.push({ x, y, width: 40, height: 40, collected: false });
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        // Empty cells and walls are ignored
                    }
                }
            }
            
            return { doors, paths, watering_hole, bonusItems };
        }
        
        // Word list parser for dynamic loading
        async function loadWordListFromFile() {
            try {
                // Level 10 uses level 9's word list (debug duplicate)
                const wordListLevel = game.selectedDifficulty === 10 ? 9 : game.selectedDifficulty;
                const wordListPath = `level-${wordListLevel}/Word-List.txt`;
                console.log(`Attempting to load ${wordListPath}...`);
                const response = await fetch(wordListPath + '?v=' + Date.now());
                const wordListText = await response.text();
                return parseWordList(wordListText);
            } catch (error) {
                console.error(`Error loading Word-List.txt from level-${game.selectedDifficulty}:`, error);
                // Fallback to embedded word list if file load fails
                const fallbackWordList = `BAG 💼,
MAP 🗺️,
HAT 🧢,
LEG 🦵,
GEM 💎,
DOT ⚪️,
TEN 🔟,
BOX 📦,
FOX 🦊,
CAR 🚗,
CAT 🐈,
DOG 🐕,
LOG 🪵,
SUN ☀️,
CUP ☕️,
FLY 🪰,
BED 🛏️,
RAT 🐀,
BAT 🦇,
PEN 🖊️,
PIG 🐖`;
                return parseWordList(fallbackWordList);
            }
        }
        
        // Distractor list parser
        async function loadDistractorsFromFile() {
            try {
                const response = await fetch('distractors.txt' + '?v=' + Date.now());
                const distractorText = await response.text();
                return parseDistractors(distractorText);
            } catch (error) {
                console.error('Error loading distractors.txt:', error);
                return {};
            }
        }
        
        function parseDistractors(distractorText) {
            const lines = distractorText.trim().split('\n');
            const distractors = {};
            
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine.includes(':')) {
                    const [letter, emojis] = trimmedLine.split(':');
                    const letterKey = letter.trim().toUpperCase();
                    const emojiList = emojis.trim().split(/\s+/).filter(emoji => emoji.length > 0);
                    distractors[letterKey] = emojiList;
                }
            });
            
            return distractors;
        }
        
        function parseWordList(wordListText) {
            const lines = wordListText.trim().split('\n');
            const wordEmojiPairs = [];
            
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine && trimmedLine.endsWith(',')) {
                    // Remove trailing comma and split by space
                    const parts = trimmedLine.slice(0, -1).split(' ');
                    if (parts.length >= 2) {
                        const word = parts[0];
                        const emoji = parts.slice(1).join(' '); // Join in case emoji has spaces
                        wordEmojiPairs.push({ word, emoji });
                    }
                }
            });
            
            return wordEmojiPairs;
        }
        
        // Load sprite sheets for PT
        const ptSprites = {
            movement: new Image(),
            celebration: {},
            bonus: new Image()
        };
        
        // Load PT sprites
        ptSprites.movement.src = 'PT-sprite.svg';
        ptSprites.bonus.src = 'level-9/PT-Bonus-Sprite.svg';
        // Celebration sprites will be loaded dynamically based on difficulty
        
        // Digraph data for Level 3
        let digraphEmojis = {};
        let digraphSounds = {};
        let emojiNames = {};
        
        // Load emoji names for word pronunciation
        async function loadEmojiNames() {
            try {
                const response = await fetch('emoji-names.txt' + '?v=' + Date.now());
                const emojiText = await response.text();
                
                const lines = emojiText.trim().split('\n');
                lines.forEach(line => {
                    const parts = line.trim().split(',');
                    if (parts.length >= 2) {
                        const emoji = parts[0];
                        const name = parts[1];
                        emojiNames[emoji] = name;
                    }
                });
                
                console.log('Loaded emoji names:', emojiNames);
                return emojiNames;
            } catch (error) {
                console.error('Error loading emoji names:', error);
                return {};
            }
        }
        
        // Load digraph data files for Level 3
        async function loadDigraphData() {
            try {
                const [emojiResponse, soundResponse, namesResponse] = await Promise.all([
                    fetch('digraph-emojis.txt' + '?v=' + Date.now()),
                    fetch('digraph-sounds.txt' + '?v=' + Date.now()),
                    loadEmojiNames()
                ]);
                
                const emojiText = await emojiResponse.text();
                const soundText = await soundResponse.text();
                
                // Parse digraph-emojis.txt
                const emojiLines = emojiText.trim().split('\n');
                emojiLines.forEach(line => {
                    const parts = line.trim().split(',');
                    if (parts.length >= 4) {
                        const digraph = parts[0];
                        const emojis = parts.slice(1);
                        digraphEmojis[digraph] = emojis;
                    }
                });
                
                // Parse digraph-sounds.txt
                const soundLines = soundText.trim().split('\n');
                soundLines.forEach(line => {
                    const parts = line.trim().split(',');
                    if (parts.length >= 2) {
                        const digraph = parts[0];
                        const sound = parts[1];
                        digraphSounds[digraph] = sound;
                    }
                });
                
                // Store emoji names
                emojiNames = namesResponse;
                
                console.log('Loaded digraph data:', { digraphEmojis, digraphSounds, emojiNames });
                return { digraphEmojis, digraphSounds, emojiNames };
            } catch (error) {
                console.error('Error loading digraph data:', error);
                return { digraphEmojis: {}, digraphSounds: {}, emojiNames: {} };
            }
        }
        
        // Celebration animation configuration for all levels
        const celebrationConfig = {
            1: { frames: 9, layout: 'horizontal' },
            2: { frames: 62, layout: 'horizontal' },
            3: { frames: 43, layout: 'horizontal' },
            4: { frames: 62, layout: 'horizontal' },
            5: { frames: 52, layout: 'horizontal' },
            6: { frames: 29, layout: 'horizontal' },
            7: { frames: 24, layout: 'horizontal' },
            8: { frames: 29, layout: 'horizontal' },
            9: { frames: 27, layout: 'horizontal' },
            10: { frames: 27, layout: 'horizontal' }
        };
        
        // Function to get celebration frame configuration for a level
        function getCelebrationConfig(level) {
            const config = celebrationConfig[level];
            if (!config) {
                console.error(`No celebration config found for level ${level}`);
                return celebrationConfig[1]; // Fallback to level 1
            }
            return config;
        }
        
        // Function to calculate frame dimensions and properties
        function calculateFrameProperties(sprite, level) {
            const config = getCelebrationConfig(level);
            const actualSheetWidth = sprite.width;
            const actualSheetHeight = sprite.height;
            
            let frameWidth, frameHeight, framesPerRow, totalFrames;
            
            if (config.layout === 'horizontal') {
                framesPerRow = config.frames;
                // Use Math.floor for level 3 to prevent drift, regular division for others
                frameWidth = level === 3 ? Math.floor(actualSheetWidth / framesPerRow) : actualSheetWidth / framesPerRow;
                frameHeight = actualSheetHeight;
                totalFrames = config.frames;
            } else {
                // Future support for other layouts like grid if needed
                throw new Error(`Unsupported layout: ${config.layout}`);
            }
            
            return {
                frameWidth,
                frameHeight,
                framesPerRow,
                totalFrames
            };
        }
        
        // Function to load celebration sprite based on difficulty
        function loadCelebrationSprite(difficulty) {
            const celebrationSprite = new Image();
            const cacheBuster = '?v=' + Date.now();
            
            if (difficulty >= 1 && difficulty <= 9) {
                celebrationSprite.src = `level-${difficulty}/celebrate.png` + cacheBuster;
            } else {
                console.error(`Invalid difficulty level: ${difficulty}`);
                celebrationSprite.src = 'level-1/celebrate.png' + cacheBuster; // Fallback
            }
            
            return celebrationSprite;
        }
        
        // Current sprites
        let currentMovementSprites = ptSprites.movement;
        let currentCelebrationSprites = ptSprites.celebration;
        
        // Texture system for maze elements
        const textures = {
            wall: new Image(),
            open: new Image(),
            math: new Image(),
            reading: new Image(),
            endpoint: new Image(),
            heart: new Image(),    // Heart collectible texture
            bonus: new Image(),    // Bonus collectible texture (level 9)
            reading1: new Image(), // Will fallback to reading texture
            reading2: new Image(), // Will fallback to reading texture
            sorting: new Image(),  // Will fallback to math texture
            loaded: false
        };
        
        // Game over sprite
        const gameOverSprite = new Image();
        gameOverSprite.src = 'game-over.png' + '?v=' + Date.now();
        gameOverSprite.onload = () => {
            console.log('Game over sprite loaded successfully');
        };
        gameOverSprite.onerror = () => {
            console.error('Failed to load game over sprite');
        };
        
        // Function to load textures for current level
        function loadTextures(level) {
            const basePath = `level-${level}/`;
            const cacheBuster = '?v=' + Date.now();
            
            textures.wall.src = basePath + 'wall.png' + cacheBuster;
            textures.open.src = basePath + 'open.png' + cacheBuster;
            textures.math.src = basePath + 'math.png' + cacheBuster;
            textures.reading.src = basePath + 'reading.png' + cacheBuster;
            textures.endpoint.src = basePath + 'endpoint.png' + cacheBuster;
            
            // Load heart texture for level 6, 7, 8, 9, and 10
            if (level === 6 || level === 7 || level === 8 || level === 9 || level === 10) {
                textures.heart.src = basePath + 'heart.png' + cacheBuster;
            }
            
            // Load bonus texture for level 9 and 10
            if (level === 9 || level === 10) {
                textures.bonus.src = basePath + 'bonus.png' + cacheBuster;
            }
            
            // For door types without specific textures, use existing ones
            textures.reading1 = textures.reading; // Use reading texture for letter matching
            textures.reading2 = textures.reading; // Use reading texture for emoji-to-word
            textures.sorting = textures.math;     // Use math texture for sorting
            
            // Track when all main textures are loaded
            let loadedCount = 0;
            const requiredTextures = ['wall', 'open', 'math', 'reading', 'endpoint'];
            
            requiredTextures.forEach(textureType => {
                textures[textureType].onload = () => {
                    loadedCount++;
                    if (loadedCount === requiredTextures.length) {
                        textures.loaded = true;
                        console.log(`Textures loaded for level ${level}`);
                    }
                };
                
                textures[textureType].onerror = () => {
                    console.warn(`Failed to load ${textureType} texture for level ${level}, using fallback`);
                    loadedCount++;
                    if (loadedCount === requiredTextures.length) {
                        textures.loaded = true;
                    }
                };
            });
        }
        
        // Improve canvas rendering quality
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        // Game object - will be populated with dynamic maze data
        const game = {
            score: 3,
            currentLevel: 1,
            selectedDifficulty: 1,
            maxUnlockedLevel: parseInt(localStorage.getItem('ptMazeMaxLevel')) || 1, // Track highest level unlocked
            gameLoopRunning: false, // Track if game loop is already running
            player: {
                x: 0,
                y: 0,
                size: 20,
                speed: 40,
                direction: 'right', // current facing direction
                animFrame: 0, // current animation frame (0 or 1)
                animTimer: 0, // timer for animation
                isMoving: false // whether player is currently moving
            },
            maze: [],
            doors: [], // Will be populated from CSV
            bonusItems: [], // Bonus collectibles (level 9)
            hasBonus: false, // Whether PT has collected the bonus
            rocketCountdown: 0, // Countdown timer for rocket boost (in seconds)
            rocketBoostData: null, // Stores rocket boost movement data when puzzle is active
            watering_hole: null, // Will be populated from CSV
            wordEmojiPairs: [], // Will be populated from Word-List.txt
            distractors: {}, // Will be populated from distractors.txt
            usedWords: [], // Track words used in current level to prevent repetition
            difficultyMode: 'hard', // easy, medium, hard
            debugMode: false, // Debug mode toggle
            testMode: false, // Test mode for alternative starting positions
            tileSize: 40,
            puzzleActive: false,
            celebrating: false,
            celebrationFrame: 0,
            celebrationTimer: 0,
            gameOverActive: false,
            gameOverFrame: 0,
            gameOverTimer: 0,
            paths: [], // Will be populated from CSV
            digraphEmojis: {}, // Will be populated from digraph-emojis.txt for Level 3
            digraphSounds: {}, // Will be populated from digraph-sounds.txt for Level 3
            emojiNames: {}, // Will be populated from emoji-names.txt for Level 3
            usedDigraphs: [], // Track digraphs used in current level to prevent repetition
            levelScores: {}, // Track final score for each completed level
            deathLevel: null, // Track which level the user died on
            gameSession: { // Track current game session
                startTime: null,
                levelsCompleted: 0,
                totalScore: 0
            }
        };
        
        // Text-to-speech function for digraph sounds
        function speakDigraph(soundText) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(soundText);
                utterance.rate = 0.8; // Slightly slower for clarity
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                window.speechSynthesis.speak(utterance);
                console.log('Speaking digraph sound:', soundText);
            } else {
                console.warn('Speech synthesis not supported in this browser');
                alert(`Sound: ${soundText}`);
            }
        }
        
        // Text-to-speech function for emoji word names
        function speakEmojiWord(emoji) {
            if ('speechSynthesis' in window && game.emojiNames && game.emojiNames[emoji]) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                const wordName = game.emojiNames[emoji];
                const utterance = new SpeechSynthesisUtterance(wordName);
                utterance.rate = 0.8; // Slightly slower for clarity
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                window.speechSynthesis.speak(utterance);
                console.log('Speaking emoji word:', wordName);
            } else {
                console.warn('Speech synthesis not supported or emoji name not found for:', emoji);
            }
        }
        
        // Function to unlock next level
        function unlockNextLevel() {
            if (game.selectedDifficulty < 8) {
                game.maxUnlockedLevel = Math.max(game.maxUnlockedLevel, game.selectedDifficulty + 1);
                localStorage.setItem('ptMazeMaxLevel', game.maxUnlockedLevel.toString());
            }
        }
        
        // Debug function to reset progress (call in browser console)
        function resetProgress() {
            localStorage.removeItem('ptMazeMaxLevel');
            game.maxUnlockedLevel = 1;
            console.log('Progress reset to level 1');
        }
        
        // Difficulty selection function
        function selectDifficulty(difficulty) {
            game.difficultyMode = difficulty;
            console.log(`Selected difficulty: ${difficulty}`);
            
            // Reset test mode when starting normal gameplay
            game.testMode = false;
            
            // Initialize game session
            game.levelScores = {};
            game.deathLevel = null;
            game.gameSession = {
                startTime: Date.now(),
                levelsCompleted: 0,
                totalScore: 0
            };
            
            // Hide difficulty selection screen
            document.getElementById('difficultyScreen').style.display = 'none';
            
            // Start the game with level 1
            game.selectedDifficulty = 1;
            currentCelebrationSprites = loadCelebrationSprite(1);
            initializeGame();
        }
        
        // Debug mode variables
        const debugState = {
            celebrationSprites: {},
            animationFrames: {},
            animationTimers: {},
            isAnimating: {}
        };
        
        // Debug mode toggle function
        function toggleDebugMode() {
            game.debugMode = !game.debugMode;
            if (game.debugMode) {
                console.log('🐛 Debug mode enabled');
                document.getElementById('debugScreen').style.display = 'block';
                loadDebugCelebrationSprites();
                updateDebugCurrentLevel();
            } else {
                console.log('🐛 Debug mode disabled');
                document.getElementById('debugScreen').style.display = 'none';
                stopAllDebugAnimations();
            }
        }
        
        // Update debug current level display
        function updateDebugCurrentLevel() {
            const debugCurrentLevel = document.getElementById('debugCurrentLevel');
            if (debugCurrentLevel) {
                debugCurrentLevel.textContent = game.selectedDifficulty;
            }
        }
        
        // Jump to specific level function for debug mode
        function jumpToLevel(level) {
            if (level < 1 || level > 10) {
                console.error('Invalid level:', level);
                return;
            }
            
            console.log(`🐛 Jumping to level ${level} from debug mode`);
            
            // Update game state
            game.selectedDifficulty = level;
            
            // Load celebration sprite for this level
            currentCelebrationSprites = loadCelebrationSprite(level);
            
            // Close debug mode
            closeDebugMode();
            
            // Initialize the new level
            initializeGame();
        }
        
        // Jump to test version of level (PT starts at 0, black 0 square)
        function jumpToTestLevel(level) {
            if (level < 1 || level > 10) {
                console.error('Invalid test level:', level);
                return;
            }
            
            console.log(`🧪 Jumping to TEST version of level ${level} from debug mode`);
            
            // Update game state and mark as test mode
            game.selectedDifficulty = level;
            game.testMode = true; // Flag to indicate test mode
            
            // Load celebration sprite for this level
            currentCelebrationSprites = loadCelebrationSprite(level);
            
            // Close debug mode
            closeDebugMode();
            
            // Initialize the test level
            initializeGame();
        }
        
        // Close debug mode
        function closeDebugMode() {
            game.debugMode = false;
            document.getElementById('debugScreen').style.display = 'none';
            stopAllDebugAnimations();
        }
        
        // Load all celebration sprites for debug mode
        function loadDebugCelebrationSprites() {
            for (let level = 1; level <= 10; level++) {
                const sprite = new Image();
                const cacheBuster = '?v=' + Date.now() + '_' + Math.random();
                
                // Level 10 uses level 9's celebration sprite (debug duplicate)
                const spriteLevel = level === 10 ? 9 : level;
                sprite.src = `level-${spriteLevel}/celebrate.png` + cacheBuster;
                
                sprite.onload = () => {
                    console.log(`Debug sprite loaded for level ${level}: ${sprite.width}x${sprite.height}`);
                };
                
                debugState.celebrationSprites[level] = sprite;
                debugState.animationFrames[level] = 0;
                debugState.animationTimers[level] = 0;
                debugState.isAnimating[level] = false;
            }
        }
        
        // Play celebration animation in debug mode
        function debugPlayCelebration(level) {
            debugState.isAnimating[level] = true;
            debugState.animationFrames[level] = 0;
            debugState.animationTimers[level] = 0;
            animateDebugCelebration(level);
        }
        
        // Stop celebration animation in debug mode
        function debugStopCelebration(level) {
            debugState.isAnimating[level] = false;
        }
        
        // Stop all debug animations
        function stopAllDebugAnimations() {
            for (let level = 1; level <= 10; level++) {
                debugState.isAnimating[level] = false;
            }
        }
        
        // Animate celebration in debug mode
        function animateDebugCelebration(level) {
            if (!debugState.isAnimating[level]) return;
            
            const canvas = document.getElementById(`debugCelebration${level}`);
            const ctx = canvas.getContext('2d');
            const sprite = debugState.celebrationSprites[level];
            
            if (sprite && sprite.complete) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Calculate frame properties using configuration-based approach
                const frameProps = calculateFrameProperties(sprite, level);
                const { frameWidth, frameHeight, framesPerRow, totalFrames } = frameProps;
                
                // Calculate frame position
                const row = Math.floor(debugState.animationFrames[level] / framesPerRow);
                const col = debugState.animationFrames[level] % framesPerRow;
                const frameX = col * frameWidth;
                const frameY = row * frameHeight;
                
                // Scale to fit debug canvas
                const scaleX = canvas.width / frameWidth;
                const scaleY = canvas.height / frameHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9;
                
                const scaledWidth = frameWidth * scale;
                const scaledHeight = frameHeight * scale;
                const offsetX = (canvas.width - scaledWidth) / 2;
                const offsetY = (canvas.height - scaledHeight) / 2;
                
                // Draw current frame
                ctx.drawImage(
                    sprite,
                    frameX, frameY, frameWidth, frameHeight,
                    offsetX, offsetY, scaledWidth, scaledHeight
                );
                
                // Update frame counter
                debugState.animationTimers[level]++;
                const frameDelay = level === 3 ? 40 : 25;
                if (debugState.animationTimers[level] >= frameDelay) {
                    debugState.animationFrames[level] = (debugState.animationFrames[level] + 1) % totalFrames;
                    debugState.animationTimers[level] = 0;
                }
            }
            
            if (debugState.isAnimating[level]) {
                requestAnimationFrame(() => animateDebugCelebration(level));
            }
        }
        
        // Initialize game with dynamic maze and word list data
        async function initializeGame() {
            console.log(`Initializing game for level ${game.selectedDifficulty}`);
            
            // Reset division problem tracking when starting/restarting level 8, 9, or 10
            if (game.selectedDifficulty === 8 || game.selectedDifficulty === 9 || game.selectedDifficulty === 10) {
                game.hasUsedAnswerOne = false;
                game.hasUsedDivideByOne = false;
                game.usedDivisionProblems = new Set();
                console.log(`Reset division problem tracking for level ${game.selectedDifficulty}`);
            }
            
            // Reset bonus state when starting level 9 or 10
            if (game.selectedDifficulty === 9 || game.selectedDifficulty === 10) {
                game.hasBonus = false;
                game.rocketCountdown = 0;
                currentMovementSprites = ptSprites.movement;
                updateRocketDisplay(); // Hide countdown display
                console.log('Reset bonus state for level 9');
            }
            
            // Load textures for this level
            loadTextures(game.selectedDifficulty);
            
            // Load maze data, word list, distractors, and digraph data (for Level 3) in parallel
            const loadPromises = [
                loadMazeFromCSV(),
                loadWordListFromFile(),
                loadDistractorsFromFile()
            ];
            
            // Add digraph data loading for Levels 3, 4, 5, 6, 7, and 8
            if (game.selectedDifficulty === 3 || game.selectedDifficulty === 4 || game.selectedDifficulty === 5 || game.selectedDifficulty === 6 || game.selectedDifficulty === 7 || game.selectedDifficulty === 8) {
                loadPromises.push(loadDigraphData());
            }
            
            const results = await Promise.all(loadPromises);
            const [mazeData, wordList, distractors, digraphData] = results;
            
            console.log(`Loaded maze data:`, mazeData);
            console.log(`Loaded word list:`, wordList);
            console.log(`Loaded distractors:`, distractors);
            
            game.doors = mazeData.doors;
            game.paths = mazeData.paths;
            game.watering_hole = mazeData.watering_hole;
            game.bonusItems = mazeData.bonusItems;
            game.wordEmojiPairs = wordList;
            game.distractors = distractors;
            
            // Store digraph data if Levels 3, 4, 5, 6, 7, or 8
            if ((game.selectedDifficulty === 3 || game.selectedDifficulty === 4 || game.selectedDifficulty === 5 || game.selectedDifficulty === 6 || game.selectedDifficulty === 7 || game.selectedDifficulty === 8) && digraphData) {
                game.digraphEmojis = digraphData.digraphEmojis;
                game.digraphSounds = digraphData.digraphSounds;
                game.emojiNames = digraphData.emojiNames;
                console.log(`Loaded digraph data for Level ${game.selectedDifficulty}:`, digraphData);
            }
            
            // Reset game state with new data
            resetGame();
            
            // Start the game after both are loaded (only if not already running)
            if (!game.gameLoopRunning) {
                game.gameLoopRunning = true;
                gameLoop();
            }
        }
        
        function updateScore(points) {
            game.score += points;
            
            // Update hearts display with single heart and count
            const livesText = `${Math.max(0, game.score)} ♥️`;
            document.getElementById('score').textContent = livesText;
            
            if (game.score <= 0) {
                // Immediately dismiss any open puzzle dialog
                if (game.puzzleActive) {
                    document.getElementById('puzzleModal').style.display = 'none';
                    game.puzzleActive = false;
                    // Clear any multiplication door reference
                    game.currentMultiplicationDoor = null;
                }
                gameOver();
            }
        }
        
        function gameOver() {
            console.log('Game over triggered');
            // Track which level the user died on
            game.deathLevel = game.selectedDifficulty;
            game.gameOverActive = true;
            game.gameOverFrame = 0;
            game.gameOverTimer = 0;
            document.getElementById('gameOverScreen').style.display = 'flex';
            console.log('Starting game over animation');
            animateGameOver();
        }
        
        function animateGameOver() {
            if (!game.gameOverActive) return;
            
            const canvas = document.getElementById('gameOverSprite');
            const ctx = canvas.getContext('2d');
            
            if (!canvas) {
                console.error('Game over canvas not found');
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameOverSprite.complete) {
                // 13 frames, each 436x436 pixels
                const frameWidth = 436;
                const frameHeight = 436;
                const totalFrames = 13;
                
                // Calculate frame position (horizontal layout)
                const frameX = game.gameOverFrame * frameWidth;
                const frameY = 0;
                
                // Draw current frame
                ctx.drawImage(
                    gameOverSprite,
                    frameX, frameY, frameWidth, frameHeight, // Source frame
                    0, 0, canvas.width, canvas.height // Destination (full canvas)
                );
                
                // Update frame counter
                game.gameOverTimer++;
                if (game.gameOverTimer >= 15) { // Slower animation
                    game.gameOverFrame = (game.gameOverFrame + 1) % totalFrames;
                    game.gameOverTimer = 0;
                }
            } else {
                // Show a placeholder while sprite loads
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width/2, canvas.height/2);
                console.log('Game over sprite not loaded yet');
            }
            
            requestAnimationFrame(animateGameOver);
        }
        
        function restartGame() {
            // Stop game over animation
            game.gameOverActive = false;
            
            // Hide game over screen and show difficulty selection
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('difficultyScreen').style.display = 'flex';
        }
        
        function isOnPath(x, y) {
            return game.paths.some(path => 
                x >= path.x && x < path.x + path.width &&
                y >= path.y && y < path.y + path.height
            );
        }
        
        function isDoorBlocking(newX, newY) {
            return game.doors.some(door => 
                !door.open && 
                newX === door.x && newY === door.y
            );
        }
        
        function checkHeartCollection(x, y) {
            // Find any heart at this position
            const heartPath = game.paths.find(path => 
                path.type === 'heart' && 
                !path.collected &&
                x === path.x && y === path.y
            );
            
            if (heartPath) {
                // Mark heart as collected
                heartPath.collected = true;
                
                // Add one life/point
                updateScore(1);
                
                console.log('Heart collected! +1 life');
                
                // Optional: Play a collection sound or show visual feedback
                // You could add a brief animation or sound here
            }
        }
        
        function checkBonusCollection(x, y) {
            // Find any bonus at this position
            const bonusItem = game.bonusItems.find(bonus => 
                !bonus.collected &&
                x === bonus.x && y === bonus.y
            );
            
            if (bonusItem) {
                // Mark bonus as collected
                bonusItem.collected = true;
                
                // Set bonus flag and switch to bonus sprite
                game.hasBonus = true;
                currentMovementSprites = ptSprites.bonus;
                
                // Start 90-second rocket countdown
                game.rocketCountdown = 90;
                startRocketCountdown();
                
                console.log('Bonus collected! PT now has rocket boost for 90 seconds');
            }
        }
        
        function startRocketCountdown() {
            // Update countdown display immediately
            updateRocketDisplay();
            
            // Start countdown timer
            const countdownInterval = setInterval(() => {
                // Only countdown if no puzzle is active (pause during puzzles)
                if (!game.puzzleActive) {
                    game.rocketCountdown--;
                    updateRocketDisplay();
                    
                    if (game.rocketCountdown <= 0) {
                        // Rocket boost expired
                        clearInterval(countdownInterval);
                        game.hasBonus = false;
                        currentMovementSprites = ptSprites.movement;
                        updateRocketDisplay(); // Hide the display
                        console.log('Rocket boost expired! PT back to normal movement');
                    }
                }
            }, 1000);
        }
        
        function updateRocketDisplay() {
            let rocketDisplay = document.getElementById('rocketDisplay');
            const gameContainer = document.getElementById('gameContainer');
            
            if (!rocketDisplay) {
                // Create rocket display element
                rocketDisplay = document.createElement('div');
                rocketDisplay.id = 'rocketDisplay';
                rocketDisplay.style.cssText = `
                    text-align: center;
                    font-size: 18px;
                    font-weight: bold;
                    color: #FFFFFF;
                    margin-bottom: 10px;
                    padding: 5px;
                    background: rgba(0, 0, 0, 0.3);
                    border-radius: 10px;
                    display: none;
                `;
                gameContainer.prepend(rocketDisplay);
            }
            
            if (game.rocketCountdown > 0) {
                rocketDisplay.textContent = `🚀 Rocket Boost: ${game.rocketCountdown}s`;
                rocketDisplay.style.display = 'block';
                
                // Add rocket boost background
                gameContainer.classList.add('rocket-boost');
                
                // Add blinking effect in last 5 seconds
                if (game.rocketCountdown <= 5) {
                    gameContainer.classList.add('blinking');
                } else {
                    gameContainer.classList.remove('blinking');
                }
            } else {
                rocketDisplay.style.display = 'none';
                // Remove all rocket boost effects
                gameContainer.classList.remove('rocket-boost', 'blinking');
            }
        }
        
        function getBlockingDoor(x, y) {
            return game.doors.find(door => 
                !door.open && 
                x === door.x && y === door.y
            );
        }
        
        function completeRocketBoostMovement() {
            if (!game.rocketBoostData) return;
            
            const data = game.rocketBoostData;
            
            // Open all doors in the path and collect all hearts/bonuses
            for (let i = 0; i < data.maxSpaces; i++) {
                const space = data.spaces[i];
                
                // Open any doors at this position
                const door = getBlockingDoor(space.x, space.y);
                if (door && !door.open) {
                    door.open = true;
                    door.color = '#B8F2B8'; // Change to green
                }
                
                // Collect hearts and bonuses
                checkHeartCollection(space.x, space.y);
                checkBonusCollection(space.x, space.y);
            }
            
            // Move PT to the furthest valid position (3rd space if possible)
            const finalSpace = data.spaces[data.maxSpaces - 1];
            game.player.x = finalSpace.x;
            game.player.y = finalSpace.y;
            
            // Clear rocket boost data
            game.rocketBoostData = null;
            
            console.log(`Rocket boost completed: moved ${data.maxSpaces} spaces`);
        }
        
        function setupDivisionDragDrop(door) {
            const dots = document.querySelectorAll('.dot');
            const baskets = document.querySelectorAll('.basket');
            
            // Initialize selection state
            door.selectedDot = null;
            
            // Setup drag events for dots
            dots.forEach(dot => {
                dot.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.dotId);
                    e.target.style.opacity = '0.5';
                });
                
                dot.addEventListener('dragend', (e) => {
                    e.target.style.opacity = '1';
                });
            });
            
            // Setup drop events for baskets
            baskets.forEach(basket => {
                basket.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    basket.style.backgroundColor = '#FF69B4';
                });
                
                basket.addEventListener('dragleave', (e) => {
                    basket.style.backgroundColor = '#FFB6C1';
                });
                
                basket.addEventListener('drop', (e) => {
                    e.preventDefault();
                    basket.style.backgroundColor = '#FFB6C1';
                    
                    const dotId = e.dataTransfer.getData('text/plain');
                    const dot = document.querySelector(`[data-dot-id="${dotId}"]`);
                    const basketId = basket.dataset.basketId;
                    
                    if (dot && basketId !== undefined) {
                        moveDotToBasket(dot, basketId, door);
                    }
                });
            });
            
            // Setup drop zone for dots area (to remove from baskets)
            const dotsArea = document.getElementById('dotsContainer');
            dotsArea.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            dotsArea.addEventListener('drop', (e) => {
                e.preventDefault();
                const dotId = e.dataTransfer.getData('text/plain');
                const dot = document.querySelector(`[data-dot-id="${dotId}"]`);
                
                if (dot) {
                    moveDotToArea(dot, door);
                }
            });
            
            // Check if submit button should be enabled
            updateSubmitButton(door);
        }
        
        function moveDotToBasket(dot, basketId, door) {
            // Find which basket this dot came from (if any)
            const currentBasket = dot.closest('.basket');
            if (currentBasket) {
                const currentBasketId = currentBasket.dataset.basketId;
                door.divisionData.dotsInBaskets[currentBasketId]--;
                const currentCountElement = currentBasket.querySelector('.basket-count');
                currentCountElement.textContent = door.divisionData.dotsInBaskets[currentBasketId];
            }
            
            // Move dot to new basket
            const basket = document.querySelector(`[data-basket-id="${basketId}"]`);
            const basketDots = basket.querySelector('.basket-dots');
            basketDots.appendChild(dot);
            
            // Update basket count
            door.divisionData.dotsInBaskets[basketId]++;
            const countElement = basket.querySelector('.basket-count');
            countElement.textContent = door.divisionData.dotsInBaskets[basketId];
            
            // Keep dot same size when in basket and remove focus state
            dot.style.width = '30px';
            dot.style.height = '30px';
            dot.style.fontSize = '22px';
            dot.style.border = '2px solid transparent';
            dot.style.boxShadow = 'none';
            dot.style.transform = 'scale(1)';
            
            // Clear selected dot state
            door.selectedDot = null;
            
            // Update submit button
            updateSubmitButton(door);
        }
        
        function moveDotToArea(dot, door) {
            // Find which basket this dot came from
            const basket = dot.closest('.basket');
            if (basket) {
                const basketId = basket.dataset.basketId;
                door.divisionData.dotsInBaskets[basketId]--;
                const countElement = basket.querySelector('.basket-count');
                countElement.textContent = door.divisionData.dotsInBaskets[basketId];
            }
            
            // Move dot back to dots area
            const dotsArea = document.getElementById('dotsContainer');
            dotsArea.appendChild(dot);
            
            // Restore original size
            dot.style.width = '30px';
            dot.style.height = '30px';
            dot.style.fontSize = '22px';
            dot.style.border = '2px solid transparent';
            
            // Update submit button
            updateSubmitButton(door);
        }
        
        function selectDot(dotId) {
            const dot = document.querySelector(`[data-dot-id="${dotId}"]`);
            if (!dot) return;
            
            // Get the door object (we need to find it from the current puzzle)
            const doors = game.doors;
            const currentDoor = doors.find(d => d.divisionData && !d.divisionData.isComplete);
            if (!currentDoor) return;
            
            // Check if there's already a selected dot and this clicked dot is in a basket
            if (currentDoor.selectedDot !== null && currentDoor.selectedDot !== dotId) {
                const clickedDotBasket = dot.closest('.basket');
                if (clickedDotBasket) {
                    // Move the selected dot to this basket instead of changing selection
                    const basketId = clickedDotBasket.dataset.basketId;
                    const selectedDot = document.querySelector(`[data-dot-id="${currentDoor.selectedDot}"]`);
                    if (selectedDot) {
                        moveDotToBasket(selectedDot, basketId, currentDoor);
                        return; // Exit early, don't change selection
                    }
                }
            }
            
            // Clear previous selection
            document.querySelectorAll('.dot').forEach(d => {
                d.style.border = '2px solid transparent';
                d.style.boxShadow = 'none';
                d.style.transform = 'scale(1)';
            });
            
            // Select this dot (whether in basket or main area) with enhanced focus state
            dot.style.border = '3px solid #0066FF';
            dot.style.boxShadow = '0 0 8px #0066FF';
            dot.style.transform = 'scale(1.1)';
            currentDoor.selectedDot = dotId;
        }
        
        function selectBasket(basketId) {
            // Get the door object
            const doors = game.doors;
            const currentDoor = doors.find(d => d.divisionData && !d.divisionData.isComplete);
            if (!currentDoor) return;
            
            // If no dot is selected, auto-select the first available dot in the main area
            if (currentDoor.selectedDot === null) {
                const dotsInMainArea = document.querySelectorAll('#dotsContainer .dot');
                if (dotsInMainArea.length > 0) {
                    const firstDot = dotsInMainArea[0];
                    const dotId = firstDot.getAttribute('data-dot-id');
                    selectDot(parseInt(dotId));
                    console.log(`Auto-selected dot ${dotId} for basket click`);
                }
            }
            
            // Move selected dot to basket
            const dot = document.querySelector(`[data-dot-id="${currentDoor.selectedDot}"]`);
            if (dot) {
                moveDotToBasket(dot, basketId, currentDoor);
            }
        }
        
        function selectDotsArea() {
            // Get the door object
            const doors = game.doors;
            const currentDoor = doors.find(d => d.divisionData && !d.divisionData.isComplete);
            if (!currentDoor || currentDoor.selectedDot === null) return;
            
            // Move selected dot back to main area
            const dot = document.querySelector(`[data-dot-id="${currentDoor.selectedDot}"]`);
            if (dot) {
                moveDotToArea(dot, currentDoor);
            }
        }
        
        function updateSubmitButton(door) {
            const submitButton = document.getElementById('submitDivision');
            if (!submitButton) return;
            
            // Check if all dots are in baskets
            const totalDotsInBaskets = door.divisionData.dotsInBaskets.reduce((sum, count) => sum + count, 0);
            const allDotsPlaced = totalDotsInBaskets === door.divisionData.dividend;
            
            if (allDotsPlaced) {
                submitButton.style.opacity = '1';
                submitButton.style.pointerEvents = 'auto';
            } else {
                submitButton.style.opacity = '0.5';
                submitButton.style.pointerEvents = 'none';
            }
        }
        
        function speakDivisionProblem(dividend, divisor) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                // Convert numbers to words for better pronunciation
                const numberWords = {
                    1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
                    6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
                    11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen',
                    16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen'
                };
                
                const dividendWord = numberWords[dividend] || dividend.toString();
                const divisorWord = numberWords[divisor] || divisor.toString();
                
                const utterance = new SpeechSynthesisUtterance(`${dividendWord} divided by ${divisorWord}`);
                utterance.rate = 0.8; // Speak a bit slower
                utterance.volume = 0.8;
                
                window.speechSynthesis.speak(utterance);
            } else {
                console.log('Speech synthesis not supported');
            }
        }
        
        function submitDivisionAnswer() {
            // Find the current division door
            const doors = game.doors;
            const currentDoor = doors.find(d => d.divisionData && !d.divisionData.isComplete);
            if (!currentDoor) return;
            
            checkDivisionAnswer('reading', currentDoor);
        }
        
        function checkDivisionAnswer(type, door) {
            const data = door.divisionData;
            const result = document.getElementById('puzzleResult');
            
            // Check if all baskets have equal number of dots
            const dotsPerBasket = data.dotsInBaskets[0];
            const allEqual = data.dotsInBaskets.every(count => count === dotsPerBasket);
            
            // Initialize attempt counters if they don't exist
            if (!door.currentProblemAttempts) door.currentProblemAttempts = 0;
            door.currentProblemAttempts++;
            
            if (allEqual && dotsPerBasket === data.answer) {
                // Correct answer!
                result.innerHTML = '👍';
                result.style.color = 'green';
                result.style.fontSize = '48px';
                
                // Mark door as open
                door.open = true;
                
                // Complete rocket boost movement if active
                completeRocketBoostMovement();
                
                // Keep title simple on success - don't show the answer
                
                // Give +1 point for correct answer
                updateScore(1);
                
                // Reset attempt counters
                door.currentProblemAttempts = 0;
                
                // Change door color to match open path
                door.color = '#B8F2B8';
                
                // Mark as complete and close after a delay
                data.isComplete = true;
                
                // No speech feedback - keep it silent on success
                
                setTimeout(() => {
                    document.getElementById('puzzleModal').style.display = 'none';
                    result.innerHTML = '';
                    result.style.fontSize = '';
                    game.puzzleActive = false;
                    // Clear any multiplication door reference
                    game.currentMultiplicationDoor = null;
                }, 1500);
            } else {
                // Wrong answer
                result.innerHTML = '👎';
                result.style.color = 'red';
                result.style.fontSize = '48px';
                
                // Deduct points based on difficulty mode
                let pointsToDeduct = 0;
                
                if (game.difficultyMode === 'easy') {
                    pointsToDeduct = -1; // Always lose 1 point in easy mode
                } else if (game.difficultyMode === 'medium') {
                    // In medium mode: first wrong answer = -1, second wrong answer = -2
                    pointsToDeduct = door.currentProblemAttempts === 1 ? -1 : -2;
                } else {
                    pointsToDeduct = -2; // Hard mode: always lose 2 points
                }
                
                updateScore(pointsToDeduct);
                
                // Track failed attempts (for potential game over)
                if (!door.failedAttempts) door.failedAttempts = 0;
                door.failedAttempts++;
                
                // Clear result after showing thumbs down
                setTimeout(() => {
                    result.innerHTML = '';
                    result.style.fontSize = '';
                    
                    // Keep dots where they are for another attempt
                    const title = document.getElementById('puzzleTitle');
                    title.innerHTML = `<span style="color: #8A2BE2; font-weight: bold;">${data.dividend}</span> <span style="color: #0066FF;">÷</span> <span style="color: #DC143C; font-weight: bold;">${data.divisor}</span> = ?`;
                }, 1500);
            }
        }
        
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw wall texture background across the entire canvas (including padding areas)
            if (textures.loaded && textures.wall.complete) {
                // Draw wall texture in a proper grid pattern covering entire canvas
                for (let x = 0; x < Math.ceil(canvas.width / 40); x++) {
                    for (let y = 0; y < Math.ceil(canvas.height / 40); y++) {
                        ctx.drawImage(textures.wall, x * 40, y * 40, 40, 40);
                    }
                }
            } else {
                // Fallback to solid color if texture isn't loaded
                ctx.fillStyle = '#2F4F2F';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw open paths using texture (same maze layout with thicker border)
            game.paths.forEach(path => {
                if (path.type === 'heart' && !path.collected) {
                    // Draw heart collectible
                    if (textures.loaded && textures.heart.complete) {
                        ctx.drawImage(textures.heart, path.x + 40, path.y + 40, 40, 40);
                    } else {
                        // Fallback: draw open path with heart emoji
                        ctx.fillStyle = '#B8F2B8';
                        ctx.fillRect(path.x + 40, path.y + 40, 40, 40);
                        ctx.fillStyle = '#FF0000';
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('❤️', path.x + 60, path.y + 65);
                    }
                } else if (path.type !== 'heart' || path.collected) {
                    // Draw regular open path
                    if (textures.loaded && textures.open.complete) {
                        // Direct positioning with 40px border padding
                        ctx.drawImage(textures.open, path.x + 40, path.y + 40, 40, 40);
                    } else {
                        // Fallback to solid color
                        ctx.fillStyle = '#B8F2B8';
                        ctx.fillRect(path.x + 40, path.y + 40, 40, 40);
                    }
                }
            });
            
            // Draw bonus items (level 9)
            if (game.bonusItems) {
                game.bonusItems.forEach(bonus => {
                    if (!bonus.collected) {
                        if (textures.loaded && textures.bonus.complete) {
                            ctx.drawImage(textures.bonus, bonus.x + 40, bonus.y + 40, 40, 40);
                        } else {
                            // Fallback: draw open path with star emoji
                            ctx.fillStyle = '#B8F2B8';
                            ctx.fillRect(bonus.x + 40, bonus.y + 40, 40, 40);
                            ctx.fillStyle = '#FFD700';
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('⭐', bonus.x + 60, bonus.y + 65);
                        }
                    }
                });
            }
            
            // Draw doors using textures
            game.doors.forEach(door => {
                if (!door.open) {
                    let doorTexture = null;
                    
                    // Select appropriate texture
                    if (door.type === 'math') {
                        doorTexture = textures.math;
                    } else if (door.type === 'reading') {
                        doorTexture = textures.reading;
                    } else if (door.type === 'reading1') {
                        doorTexture = textures.reading1;
                    } else if (door.type === 'reading2') {
                        doorTexture = textures.reading2;
                    } else if (door.type === 'sorting') {
                        doorTexture = textures.sorting;
                    }
                    
                    // Draw door texture or fallback color with symbol
                    if (textures.loaded && doorTexture && doorTexture.complete) {
                        // Simple direct positioning with thicker border
                        ctx.drawImage(doorTexture, door.x + 40, door.y + 40, 40, 40);
                    } else {
                        // Fallback to original color system with symbols
                        ctx.fillStyle = door.color;
                        ctx.fillRect(door.x + 40, door.y + 40, 40, 40);
                        
                        // Only draw symbols when using fallback colors
                        ctx.fillStyle = '#000';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        let symbol = '🔀'; // Default sorting symbol
                        if (door.type === 'math') symbol = '🪨';
                        else if (door.type === 'reading') symbol = '📚';
                        else if (door.type === 'reading1') symbol = '🔤';
                        else if (door.type === 'reading2') symbol = '🏞️';
                        ctx.fillText(symbol, door.x + 60, door.y + 65);
                    }
                }
            });
            
            // Draw watering hole (endpoint) using texture
            if (game.watering_hole) {
                if (textures.loaded && textures.endpoint.complete) {
                    ctx.drawImage(textures.endpoint, game.watering_hole.x + 40, game.watering_hole.y + 40, 40, 40);
                } else {
                    // Fallback to original style
                    ctx.fillStyle = '#FFB6C1'; // Light pink background
                    ctx.fillRect(game.watering_hole.x + 40, game.watering_hole.y + 40, 40, 40);
                    ctx.fillStyle = '#000';
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('🎂', game.watering_hole.x + 60, game.watering_hole.y + 68);
                }
            }
            
            // Draw PT sprite (offset by 30px)
            if (currentMovementSprites.complete) {
                // Calculate which frame to use based on direction and animation
                let frameX = 0;
                if (game.player.direction === 'right') {
                    frameX = (game.player.animFrame === 0) ? 0 : 160; // Frames 1, 2
                } else if (game.player.direction === 'left') {
                    frameX = (game.player.animFrame === 0) ? 320 : 480; // Frames 3, 4
                } else if (game.player.direction === 'up') {
                    frameX = (game.player.animFrame === 0) ? 640 : 800; // Frames 5, 6
                } else if (game.player.direction === 'down') {
                    frameX = (game.player.animFrame === 0) ? 640 : 800; // Frames 5, 6 (same as up for now)
                }
                
                // Draw the sprite frame (160x160 from SVG sprite sheet)
                // PT should be 45x45 to be bigger than the tile (overlaps slightly)
                const ptSize = 45;
                const ptOffset = -2.5; // Negative offset to center the larger sprite
                
                ctx.drawImage(
                    currentMovementSprites,
                    frameX, 0, 160, 160, // Source: x, y, width, height from sprite sheet
                    game.player.x + 40 + ptOffset, game.player.y + 40 + ptOffset, ptSize, ptSize // Centered in tile with thicker border
                );
            } else {
                // Fallback while sprite loads - bigger and centered
                const tileCenter = 20;
                ctx.fillStyle = '#D3D3D3';
                ctx.beginPath();
                ctx.arc(game.player.x + 40 + tileCenter, game.player.y + 40 + tileCenter, 22, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🐘', game.player.x + 40 + tileCenter, game.player.y + 40 + tileCenter + 10);
            }
        }
        
        // Debug mode keyboard listener (Shift + Ctrl + D)
        document.addEventListener('keydown', (e) => {
            if (e.shiftKey && e.ctrlKey && (e.key === 'D' || e.key === 'd')) {
                e.preventDefault();
                toggleDebugMode();
                return;
            }
        });
        
        // Global arrow key prevention to stop page scrolling
        document.addEventListener('keydown', (e) => {
            // Always prevent arrow keys from scrolling the page
            const key = e.key || e.code;
            const arrowKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Up', 'Down', 'Left', 'Right'];
            if (arrowKeys.includes(key)) {
                e.preventDefault();
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // Don't allow movement if puzzle is active
            if (game.puzzleActive) return;
            
            // Snap current position to grid first
            let currentGridX = Math.round(game.player.x / game.tileSize) * game.tileSize;
            let currentGridY = Math.round(game.player.y / game.tileSize) * game.tileSize;
            
            let newX = currentGridX;
            let newY = currentGridY;
            
            // Calculate movement distance (triple if rocket boost active)
            const moveDistance = game.hasBonus && game.rocketCountdown > 0 ? game.tileSize * 3 : game.tileSize;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    newY -= moveDistance;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    newY += moveDistance;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    newX -= moveDistance;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    newX += moveDistance;
                    break;
                default:
                    return;
            }
            
            // Handle rocket boost movement (3 spaces) or normal movement (1 space)
            if (game.hasBonus && game.rocketCountdown > 0 && moveDistance === game.tileSize * 3) {
                // Rocket boost: handle 3-space movement with simplified logic
                const deltaX = (newX - currentGridX) / 3;
                const deltaY = (newY - currentGridY) / 3;
                const space1X = currentGridX + deltaX;
                const space1Y = currentGridY + deltaY;
                const space2X = currentGridX + deltaX * 2;
                const space2Y = currentGridY + deltaY * 2;
                const space3X = newX;
                const space3Y = newY;
                
                // Find how far PT can move before hitting a wall
                let finalX = currentGridX;
                let finalY = currentGridY;
                let maxSpaces = 0;
                
                if (isOnPath(space1X, space1Y)) {
                    finalX = space1X;
                    finalY = space1Y;
                    maxSpaces = 1;
                    
                    if (isOnPath(space2X, space2Y)) {
                        finalX = space2X;
                        finalY = space2Y;
                        maxSpaces = 2;
                        
                        if (isOnPath(space3X, space3Y)) {
                            finalX = space3X;
                            finalY = space3Y;
                            maxSpaces = 3;
                        }
                    }
                }
                
                // Find the first puzzle in the path
                let firstPuzzleDoor = null;
                if (maxSpaces >= 1) {
                    const door1 = getBlockingDoor(space1X, space1Y);
                    if (door1 && !door1.open) {
                        firstPuzzleDoor = door1;
                    } else if (maxSpaces >= 2) {
                        const door2 = getBlockingDoor(space2X, space2Y);
                        if (door2 && !door2.open) {
                            firstPuzzleDoor = door2;
                        } else if (maxSpaces >= 3) {
                            const door3 = getBlockingDoor(space3X, space3Y);
                            if (door3 && !door3.open) {
                                firstPuzzleDoor = door3;
                            }
                        }
                    }
                }
                
                // If there's a puzzle to solve, show it and store rocket boost data
                if (firstPuzzleDoor) {
                    // Store rocket boost movement data for completion
                    game.rocketBoostData = {
                        spaces: [
                            {x: space1X, y: space1Y},
                            {x: space2X, y: space2Y}, 
                            {x: space3X, y: space3Y}
                        ],
                        maxSpaces: maxSpaces,
                        currentX: currentGridX,
                        currentY: currentGridY
                    };
                    
                    showPuzzle(firstPuzzleDoor.type, firstPuzzleDoor);
                    return; // Don't move yet, wait for puzzle completion
                }
                
                // No puzzles - move PT to final position and collect everything along the way
                if (maxSpaces > 0) {
                    game.player.x = finalX;
                    game.player.y = finalY;
                    
                    // Collect hearts/bonuses from all traversed spaces
                    if (maxSpaces >= 1) {
                        checkHeartCollection(space1X, space1Y);
                        checkBonusCollection(space1X, space1Y);
                    }
                    if (maxSpaces >= 2) {
                        checkHeartCollection(space2X, space2Y);
                        checkBonusCollection(space2X, space2Y);
                    }
                    if (maxSpaces >= 3) {
                        checkHeartCollection(space3X, space3Y);
                        checkBonusCollection(space3X, space3Y);
                    }
                    
                    // Update direction and start animation
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        game.player.direction = 'left';
                    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        game.player.direction = 'right';
                    } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        game.player.direction = 'up';
                    } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                        game.player.direction = 'down';
                    }
                    
                    // Trigger walking animation
                    game.player.isMoving = true;
                    game.player.animFrame = (game.player.animFrame + 1) % 2; // Toggle between frames 0 and 1
                }
            } else {
                // Normal movement (single space)
                if (isOnPath(newX, newY)) {
                    // Check if a door is blocking the path
                    if (!isDoorBlocking(newX, newY)) {
                        // Update player position
                        game.player.x = newX;
                        game.player.y = newY;
                        
                        // Check for heart collection
                        checkHeartCollection(newX, newY);
                        // Check for bonus collection
                        checkBonusCollection(newX, newY);
                        
                        // Update direction and start animation
                        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                            game.player.direction = 'left';
                        } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                            game.player.direction = 'right';
                        } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                            game.player.direction = 'up';
                        } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                            game.player.direction = 'down';
                        }
                        
                        // Trigger walking animation
                        game.player.isMoving = true;
                        game.player.animFrame = (game.player.animFrame + 1) % 2; // Toggle between frames 0 and 1
                    } else {
                        // Find which door is blocking and show puzzle
                        const blockingDoor = game.doors.find(door => 
                            !door.open && 
                            newX === door.x && newY === door.y
                        );
                        if (blockingDoor && !game.puzzleActive) {
                            showPuzzle(blockingDoor.type, blockingDoor);
                        }
                    }
                }
            }
            
            // Check for watering hole win condition
            if (game.watering_hole) {
                const distance = Math.sqrt(
                    Math.pow(game.player.x + 20 - game.watering_hole.x, 2) + 
                    Math.pow(game.player.y + 20 - game.watering_hole.y, 2)
                );
                if (distance < 40) {
                    showCelebration();
                }
            }
        });
        
        // Flexible number line puzzle generator
        function createNumberLinePuzzle(door, equationType = 'simple') {
            let num1, num2, num3, answer;
            let equation, title;
            
            // Generate equation based on type
            switch(equationType) {
                case 'simple': // A+B or A-B (levels 4-7)
                    const isAddition = Math.random() < 0.5;
                    if (isAddition) {
                        // A + B = answer (1-12) - avoid 0s in addition
                        do {
                            num1 = Math.floor(Math.random() * 12) + 1; // 1-12
                            num2 = Math.floor(Math.random() * 12) + 1; // 1-12
                            answer = num1 + num2;
                        } while (answer > 12);
                        equation = `${num1} + ${num2}`;
                        title = `${num1} + ${num2} = ?`;
                    } else {
                        // A - B = answer (0-12)
                        do {
                            num1 = Math.floor(Math.random() * 13); // 0-12
                            num2 = Math.floor(Math.random() * (num1 + 1)); // 0 to num1
                            answer = num1 - num2;
                        } while (answer < 0 || answer > 12);
                        equation = `${num1} - ${num2}`;
                        title = `${num1} - ${num2} = ?`;
                    }
                    break;
                    
                case 'triple_add': // A+B+C (level 8-9)
                    do {
                        // Reduce 0s in addition - only allow one 0 maximum per problem
                        num1 = Math.floor(Math.random() * 10) + 1; // 1-10 (smaller range for triple add)
                        num2 = Math.floor(Math.random() * 10) + 1; // 1-10
                        num3 = Math.random() < 0.7 ? Math.floor(Math.random() * 5) + 1 : 0; // 70% chance 1-5, 30% chance 0
                        answer = num1 + num2 + num3;
                    } while (answer > 12);
                    equation = `${num1} + ${num2} + ${num3}`;
                    title = `<span style="color: #32CD32; font-weight: bold;">${num1}</span> <span style="color: #FF8C00;">+</span> <span style="color: #32CD32; font-weight: bold;">${num2}</span> <span style="color: #FF8C00;">+</span> <span style="color: #32CD32; font-weight: bold;">${num3}</span> = ?`;
                    break;
                    
                case 'mixed_add_sub': // A+B-C (future levels)
                    do {
                        num1 = Math.floor(Math.random() * 10) + 1; // 1-10 (avoid 0 in first term)
                        num2 = Math.floor(Math.random() * 8) + 1; // 1-8 (avoid 0 in addition term)
                        num3 = Math.floor(Math.random() * 8); // 0-7 (subtraction term can be 0)
                        answer = num1 + num2 - num3;
                    } while (answer < 0 || answer > 12);
                    equation = `${num1} + ${num2} - ${num3}`;
                    title = `${num1} + ${num2} - ${num3} = ?`;
                    break;
                    
                case 'mixed_sub_add': // A-B+C (future levels)
                    do {
                        num1 = Math.floor(Math.random() * 10) + 3; // 3-12 (avoid 0 in first term, ensure subtraction possible)
                        num2 = Math.floor(Math.random() * 6); // 0-5 (subtraction term can be 0)
                        num3 = Math.floor(Math.random() * 8) + 1; // 1-8 (avoid 0 in addition term)
                        answer = num1 - num2 + num3;
                    } while (answer < 0 || answer > 12);
                    equation = `${num1} - ${num2} + ${num3}`;
                    title = `${num1} - ${num2} + ${num3} = ?`;
                    break;
                    
                case 'multiplication': // A×B (level 10)
                    do {
                        // Keep multiplication simple: 1×1 to 4×3 (answers 1-12)
                        num1 = Math.floor(Math.random() * 4) + 1; // 1-4
                        num2 = Math.floor(Math.random() * 3) + 1; // 1-3
                        answer = num1 * num2;
                    } while (answer > 12);
                    equation = `${num1} × ${num2}`;
                    title = `<span style="color: #FF6B35; font-weight: bold;">${num1}</span> <span style="color: #32CD32;">×</span> <span style="color: #FF6B35; font-weight: bold;">${num2}</span> = ?`;
                    break;
                    
            }
            
            // Store the problem details on the door
            door.mathAnswer = answer;
            door.mathStartPosition = 0; // Always start at 0
            door.foxPosition = door.mathStartPosition;
            
            // Generate multiple choice answers with |W-R|<4 constraint
            const wrongAnswers = [];
            while (wrongAnswers.length < 2) {
                let wrongAnswer;
                if (Math.random() < 0.5) {
                    wrongAnswer = answer + Math.floor(Math.random() * 3) + 1; // +1 to +3
                } else {
                    wrongAnswer = answer - Math.floor(Math.random() * 3) - 1; // -1 to -3
                }
                // Ensure wrong answer is in valid range (0-12) and not already used
                if (wrongAnswer >= 0 && wrongAnswer <= 12 && wrongAnswer !== answer && !wrongAnswers.includes(wrongAnswer)) {
                    wrongAnswers.push(wrongAnswer);
                }
            }
            
            // Create answer options array and shuffle
            const allAnswers = [answer, ...wrongAnswers];
            allAnswers.sort(() => Math.random() - 0.5);
            
            console.log(`Number Line Puzzle: ${equation} = ${answer}, PT starts at ${door.mathStartPosition}`);
            
            return {
                title: title,
                answer: answer,
                allAnswers: allAnswers,
                equation: equation
            };
        }
        
        // Helper function to determine baskets per row based on divisor
        function getBasketsPerRow(divisor) {
            if (divisor >= 1 && divisor <= 5) {
                return divisor; // 1 row: all baskets on one line
            } else if (divisor >= 6 && divisor <= 10) {
                return Math.ceil(divisor / 2); // 2 rows: divide evenly between 2 rows
            } else if (divisor >= 11 && divisor <= 15) {
                return Math.ceil(divisor / 3); // 3 rows: divide evenly between 3 rows
            } else {
                return Math.ceil(divisor / 4); // 4+ rows for larger divisors
            }
        }
        
        // Reusable division puzzle generator
        function createDivisionPuzzle(door) {
            let dividend, divisor, answer;
            
            // Generate division problem: A ÷ B = C where A ≤ 15
            // Answer = 1 can only appear once per level
            // A ÷ 1 can only appear once per level
            // Track problems to prevent duplicates
            if (game.hasUsedAnswerOne === undefined) {
                game.hasUsedAnswerOne = false;
            }
            if (game.hasUsedDivideByOne === undefined) {
                game.hasUsedDivideByOne = false;
            }
            if (!game.usedDivisionProblems) {
                game.usedDivisionProblems = new Set();
            }
            
            let attempts = 0;
            const maxAttempts = 100;
            
            do {
                // Generate random division problem
                dividend = Math.floor(Math.random() * 15) + 1; // 1 to 15
                divisor = Math.floor(Math.random() * dividend) + 1; // 1 to dividend
                answer = Math.floor(dividend / divisor);
                
                // Ensure clean division
                if (dividend % divisor !== 0) {
                    dividend = divisor * answer;
                }
                
                attempts++;
                if (attempts >= maxAttempts) {
                    // Fallback to simple problem
                    dividend = 6;
                    divisor = 2;
                    answer = 3;
                    break;
                }
            } while (
                dividend % divisor !== 0 || // Must be evenly divisible
                answer === 0 || // No zero answers
                answer > 10 || // Keep answers reasonable (max 10 dots per basket)
                (answer === 1 && game.hasUsedAnswerOne) || // Answer = 1 only once per level
                (divisor === 1 && game.hasUsedDivideByOne) || // A ÷ 1 only once per level
                game.usedDivisionProblems.has(`${dividend}÷${divisor}`) // No repeats
            );
            
            // Mark answer = 1 as used if this problem has answer = 1
            if (answer === 1) {
                game.hasUsedAnswerOne = true;
                console.log(`Used answer=1 for problem: ${dividend}÷${divisor}=1`);
            }
            
            // Mark A ÷ 1 as used if this problem divides by 1
            if (divisor === 1) {
                game.hasUsedDivideByOne = true;
                console.log(`Used A÷1 for problem: ${dividend}÷1=${dividend}`);
            }
            
            // Store this problem as used
            game.usedDivisionProblems.add(`${dividend}÷${divisor}`);
            
            // Store the problem details on the door (same format as original)
            door.divisionData = {
                dividend: dividend,
                divisor: divisor,
                answer: answer,
                dotsInBaskets: new Array(divisor).fill(0), // Track dots in each basket
                isComplete: false
            };
            
            // Create the division interface with bigger dots and baskets
            const divisionHTML = `
                <div class="division-container" style="margin: 10px auto; width: 900px; text-align: center; min-height: 400px; max-height: 700px; overflow-y: auto; padding: 20px; box-sizing: border-box;">
                    <div style="margin: 20px 0; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        <button id="speakProblem" style="
                            background: #2196F3;
                            color: white;
                            border: none;
                            padding: 10px 15px;
                            font-size: 16px;
                            border-radius: 20px;
                            cursor: pointer;
                            font-family: inherit;
                            display: flex;
                            align-items: center;
                            gap: 5px;
                        " onclick="speakDivisionProblem(${dividend}, ${divisor})">
                            🔊
                        </button>
                    </div>
                    
                    <div class="dots-area" id="dotsArea" style="
                        margin: 20px auto;
                        min-height: 120px;
                        height: 120px;
                        max-width: 800px;
                        border: 2px dashed #ccc;
                        border-radius: 10px;
                        padding: 15px;
                        background: #f9f9f9;
                        overflow-y: auto;
                        box-sizing: border-box;
                    ">
                        <div id="dotsContainer" style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 8px; min-height: 80px; cursor: pointer;" onclick="selectDotsArea()">
                            ${Array(dividend).fill().map((_, i) => 
                                `<div class="dot" data-dot-id="${i}" style="
                                    width: 30px;
                                    height: 30px;
                                    background: #8A2BE2;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    user-select: none;
                                    border: 2px solid transparent;
                                    transition: all 0.2s ease;
                                    box-shadow: none;
                                    transform: scale(1);
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 22px;
                                " draggable="true" onclick="event.stopPropagation(); selectDot(${i})">🟣</div>`
                            ).join('')}
                        </div>
                    </div>
                    
                    <div class="baskets-area" style="margin: 20px auto; min-height: 250px; max-height: 400px; overflow-y: auto; padding: 10px; max-width: 800px;">
                        <div id="basketsContainer" style="display: grid; grid-template-columns: repeat(${getBasketsPerRow(divisor)}, 140px); gap: 20px; justify-content: center; align-items: start;">
                            ${Array(divisor).fill().map((_, i) => 
                                `<div class="basket" data-basket-id="${i}" style="
                                    width: 140px;
                                    height: 140px;
                                    border: 4px solid #DC143C;
                                    border-radius: 15px;
                                    background: #FFB6C1;
                                    display: flex;
                                    flex-direction: column;
                                    align-items: center;
                                    justify-content: center;
                                    position: relative;
                                    min-height: 140px;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                " onclick="selectBasket(${i})">
                                    <div class="basket-count" style="
                                        position: absolute;
                                        top: -12px;
                                        right: -12px;
                                        background: #228B22;
                                        color: white;
                                        border-radius: 50%;
                                        width: 24px;
                                        height: 24px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-size: 14px;
                                        font-weight: bold;
                                    ">0</div>
                                    <div class="basket-dots" style="
                                        display: flex;
                                        flex-wrap: wrap;
                                        gap: 4px;
                                        justify-content: center;
                                        align-items: center;
                                        width: 100%;
                                        height: 100%;
                                        padding: 10px;
                                        box-sizing: border-box;
                                    "></div>
                                </div>`
                            ).join('')}
                        </div>
                    </div>
                    
                    <div style="margin-top: 30px;">
                        <button id="submitDivision" style="
                            background: #4CAF50;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 18px;
                            border-radius: 25px;
                            cursor: pointer;
                            font-family: inherit;
                            font-weight: bold;
                        " onclick="submitDivisionAnswer()">Submit Answer</button>
                    </div>
                </div>
            `;
            
            console.log(`Division Puzzle: ${dividend} ÷ ${divisor} = ${answer}`);
            
            return {
                title: `${dividend} ÷ ${divisor} = ?`,
                html: divisionHTML,
                dividend: dividend,
                divisor: divisor,
                answer: answer
            };
        }
        
        // Interactive multiplication puzzle with synchronized squares
        function showMultiplicationGroupsPuzzle(door) {
            console.log('=== MULTIPLICATION PUZZLE INITIALIZATION ===');
            console.log('showMultiplicationGroupsPuzzle called with door:', door);
            console.log('Door before modification:', {
                type: door.type,
                multiplicationA: door.multiplicationA,
                multiplicationB: door.multiplicationB,
                mathAnswer: door.mathAnswer
            });
            
            const modal = document.getElementById('puzzleModal');
            const title = document.getElementById('puzzleTitle');
            const question = document.getElementById('puzzleQuestion');
            const options = document.getElementById('puzzleOptions');
            
            // Generate simple multiplication problem (A < 10, B < 10, A×B < 15)
            let A, B;
            do {
                A = Math.floor(Math.random() * 6) + 2; // 2-7
                B = Math.floor(Math.random() * 4) + 2; // 2-5
            } while (A >= 10 || B >= 10 || A * B >= 15);
            
            const correctAnswer = A * B;
            console.log(`Generated problem: ${A} × ${B} = ${correctAnswer}`);
            
            // Store puzzle data
            door.multiplicationA = A;
            door.multiplicationB = B;
            door.mathAnswer = correctAnswer;
            door.currentBoxes = 1;
            door.currentDots = 0;
            
            // CRITICAL: Store reference to this specific door for submission
            game.currentMultiplicationDoor = door;
            
            console.log('Door after setting values:', {
                type: door.type,
                multiplicationA: door.multiplicationA,
                multiplicationB: door.multiplicationB,
                mathAnswer: door.mathAnswer,
                position: `(${door.x}, ${door.y})`
            });
            console.log('Stored door reference in game.currentMultiplicationDoor');
            console.log('============================================');
            
            // Set up interface
            title.innerHTML = `<span style="color: black; font-weight: bold; font-size: 32px;">${A} × ${B} = ?</span>`;
            question.innerHTML = '';
            
            // Generate wrong answers within |W-R| < 4
            const wrongAnswers = [];
            
            // Generate two unique wrong answers
            while (wrongAnswers.length < 2) {
                let wrongAnswer;
                
                // Try to find wrong answers within range
                do {
                    const offset = Math.floor(Math.random() * 6) - 3; // -3 to +3
                    wrongAnswer = correctAnswer + offset;
                } while (wrongAnswer === correctAnswer || wrongAnswer <= 0 || wrongAnswers.includes(wrongAnswer));
                
                // Ensure the wrong answer is within |W-R| < 4
                if (Math.abs(wrongAnswer - correctAnswer) < 4 && wrongAnswer > 0) {
                    wrongAnswers.push(wrongAnswer);
                }
            }
            
            // Create array of all answers and shuffle
            const allAnswers = [correctAnswer, ...wrongAnswers];
            for (let i = allAnswers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allAnswers[i], allAnswers[j]] = [allAnswers[j], allAnswers[i]];
            }
            
            // Store the correct answer position for validation
            door.correctAnswerPosition = allAnswers.indexOf(correctAnswer);
            
            options.innerHTML = `
                <div id="multiplicationContainer" style="text-align: center; padding: 20px;">
                    <!-- Red squares area (using exact division puzzle styling) -->
                    <div id="squaresArea" style="margin: 20px 0; min-height: 160px; position: relative;">
                        <div class="basket" data-square="0" style="
                            width: 140px;
                            height: 140px;
                            border: 4px solid #DC143C;
                            border-radius: 15px;
                            background: #FFB6C1;
                            display: inline-block;
                            flex-direction: column;
                            justify-content: center;
                            align-items: center;
                            position: relative;
                            min-height: 140px;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            margin: 10px;
                            vertical-align: top;
                        ">
                            <div class="basket-dots" style="
                                display: flex;
                                flex-wrap: wrap;
                                gap: 4px;
                                justify-content: center;
                                align-items: center;
                                height: 100%;
                                width: 100%;
                                padding: 8px;
                                box-sizing: border-box;
                            "></div>
                        </div>
                        <!-- Visual feedback area for squares -->
                        <div id="visualFeedback" style="
                            position: absolute; 
                            top: -10px; 
                            right: 10px; 
                            font-size: 32px;
                            z-index: 10;
                        "></div>
                    </div>
                    
                    <!-- Plus and Minus buttons -->
                    <div style="margin: 20px 0;">
                        <button onclick="removeRedSquare()" style="background: white; color: black; border: 3px solid black; padding: 15px 20px; border-radius: 50%; font-size: 24px; cursor: pointer; font-weight: bold; margin-right: 10px;">−</button>
                        <button onclick="addRedSquare()" style="background: white; color: black; border: 3px solid black; padding: 15px 20px; border-radius: 50%; font-size: 24px; cursor: pointer; font-weight: bold;">+</button>
                    </div>
                    
                    <!-- Multiple choice answers -->
                    <div style="margin: 30px 0;">
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                            ${allAnswers.map((answer, index) => `
                                <button id="answerBtn${index}" onclick="checkMultiplicationAnswer(${index})" style="
                                    background: #4CAF50;
                                    color: white;
                                    border: none;
                                    padding: 15px 25px;
                                    margin: 5px;
                                    border-radius: 25px;
                                    font-size: 20px;
                                    cursor: pointer;
                                    font-family: inherit;
                                    min-width: 80px;
                                    transition: all 0.2s ease;
                                    position: relative;
                                " onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4CAF50'">${answer}</button>
                            `).join('')}
                        </div>
                    </div>
                    
                    <!-- Result area for thumbs up/down feedback -->
                    <div id="puzzleResult" style="margin-top: 20px; text-align: center;"></div>
                </div>
            `;
            
            // Add click handler to initial square
            setupSquareHandlers();
        }
        
        // Set up click handlers for red squares
        function setupSquareHandlers() {
            const squares = document.querySelectorAll('.basket[data-square]');
            squares.forEach(square => {
                // Remove ALL existing event listeners by cloning and replacing the element
                const newSquare = square.cloneNode(true);
                square.parentNode.replaceChild(newSquare, square);
                
                // Add single click handler for square (adds 1 dot to all squares)
                newSquare.addEventListener('click', (e) => {
                    if (e.target === newSquare || e.target.classList.contains('basket-dots')) {
                        addDotToAllSquares();
                    }
                });
                
                // Re-setup dot click handlers in this square
                const dots = newSquare.querySelectorAll('.multiplication-dot');
                dots.forEach(dot => {
                    dot.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeDotFromAllSquares();
                    });
                });
            });
        }
        
        // Add a dot to all red squares (SYNCHRONIZED)
        function addDotToAllSquares() {
            const door = game.doors.find(d => d.type === 'math');
            if (!door) return;
            
            door.currentDots++;
            console.log(`Adding dot to all squares. New count: ${door.currentDots}`);
            
            const squares = document.querySelectorAll('.basket[data-square]');
            console.log(`Found ${squares.length} squares to add dots to`);
            
            squares.forEach((square, index) => {
                const dotsContainer = square.querySelector('.basket-dots');
                
                // Create new dot using exact division puzzle styling
                const dot = document.createElement('div');
                dot.className = 'dot multiplication-dot';
                dot.style.cssText = `
                    width: 30px;
                    height: 30px;
                    background: #8A2BE2;
                    border-radius: 50%;
                    cursor: pointer;
                    border: 2px solid transparent;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 22px;
                    transition: all 0.2s ease;
                `;
                dot.innerHTML = '🟣';
                
                // Add click handler to remove dot from all squares
                dot.onclick = (e) => {
                    e.stopPropagation();
                    removeDotFromAllSquares();
                };
                
                dotsContainer.appendChild(dot);
                console.log(`Square ${index} now has ${dotsContainer.children.length} dots`);
            });
        }
        
        // Remove a dot from all red squares (SYNCHRONIZED)
        function removeDotFromAllSquares() {
            const door = game.doors.find(d => d.type === 'math');
            if (!door || door.currentDots <= 0) return;
            
            door.currentDots--;
            console.log(`Removing dot from all squares. New count: ${door.currentDots}`);
            
            const squares = document.querySelectorAll('.basket[data-square]');
            console.log(`Found ${squares.length} squares to remove dots from`);
            
            squares.forEach((square, index) => {
                const dotsContainer = square.querySelector('.basket-dots');
                const dots = dotsContainer.querySelectorAll('.multiplication-dot');
                if (dots.length > 0) {
                    // Remove the last dot
                    dots[dots.length - 1].remove();
                    console.log(`Square ${index} now has ${dotsContainer.querySelectorAll('.multiplication-dot').length} dots`);
                }
            });
        }
        
        // Add a new red square (MUST come pre-filled with same dots as existing squares)
        function addRedSquare() {
            const door = game.doors.find(d => d.type === 'math');
            if (!door) return;
            
            // Get current dot count from existing squares to ensure synchronization
            const existingSquares = document.querySelectorAll('.basket[data-square]');
            const currentDotCount = existingSquares.length > 0 ? 
                existingSquares[0].querySelectorAll('.multiplication-dot').length : 0;
            
            // Update the door's current dots to match reality
            door.currentDots = currentDotCount;
            door.currentBoxes++;
            
            console.log(`Adding new square: currentDots=${door.currentDots}, currentBoxes=${door.currentBoxes}`);
            
            const squaresArea = document.getElementById('squaresArea');
            const newSquare = document.createElement('div');
            newSquare.className = 'basket';
            newSquare.setAttribute('data-square', door.currentBoxes - 1);
            newSquare.style.cssText = `
                width: 140px;
                height: 140px;
                border: 4px solid #DC143C;
                border-radius: 15px;
                background: #FFB6C1;
                display: inline-block;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                position: relative;
                min-height: 140px;
                cursor: pointer;
                transition: all 0.2s ease;
                margin: 10px;
                vertical-align: top;
            `;
            
            // Add dots container
            const dotsContainer = document.createElement('div');
            dotsContainer.className = 'basket-dots';
            dotsContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                justify-content: center;
                align-items: center;
                height: 100%;
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
            `;
            
            // CRITICAL: Add existing dots to new square (must match other squares exactly)
            for (let i = 0; i < door.currentDots; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot multiplication-dot';
                dot.style.cssText = `
                    width: 30px;
                    height: 30px;
                    background: #8A2BE2;
                    border-radius: 50%;
                    cursor: pointer;
                    border: 2px solid transparent;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 22px;
                    transition: all 0.2s ease;
                `;
                dot.innerHTML = '🟣';
                
                dot.onclick = (e) => {
                    e.stopPropagation();
                    removeDotFromAllSquares();
                };
                
                dotsContainer.appendChild(dot);
            }
            
            newSquare.appendChild(dotsContainer);
            squaresArea.appendChild(newSquare);
            setupSquareHandlers(); // Refresh handlers
            
            console.log(`New square added with ${dotsContainer.children.length} dots`);
        }
        
        // Remove a red square
        function removeRedSquare() {
            const door = game.doors.find(d => d.type === 'math');
            if (!door || door.currentBoxes <= 1) return; // Always keep at least 1 square
            
            const squares = document.querySelectorAll('.basket[data-square]');
            if (squares.length <= 1) return; // Safety check
            
            // Remove the last square
            const lastSquare = squares[squares.length - 1];
            lastSquare.remove();
            
            door.currentBoxes--;
            console.log(`Removed square. Remaining squares: ${door.currentBoxes}`);
            
            // Re-setup handlers for remaining squares
            setupSquareHandlers();
        }
        
        // Check multiplication answer (both visual arrangement and selected answer)
        function checkMultiplicationAnswer(selectedIndex) {
            const door = game.currentMultiplicationDoor;
            if (!door) {
                console.error('No current multiplication door found!');
                return;
            }
            
            // First, check the visual arrangement
            const squares = document.querySelectorAll('.basket[data-square]');
            const userBoxes = squares.length;
            
            // Check dots in each square to ensure they're all the same
            let userDotsPerBox = 0;
            let allSquaresHaveSameDots = true;
            
            squares.forEach((square, index) => {
                const dotsInThisSquare = square.querySelectorAll('.multiplication-dot').length;
                if (index === 0) {
                    userDotsPerBox = dotsInThisSquare;
                } else if (dotsInThisSquare !== userDotsPerBox) {
                    allSquaresHaveSameDots = false;
                }
            });
            
            const A = door.multiplicationA;
            const B = door.multiplicationB;
            
            // Check if user created either A×B or B×A arrangement
            const option1Check = (userBoxes === A && userDotsPerBox === B);
            const option2Check = (userBoxes === B && userDotsPerBox === A);
            const isCorrectArrangement = (option1Check || option2Check) && allSquaresHaveSameDots;
            
            // Check if selected answer is correct
            const isCorrectAnswer = (selectedIndex === door.correctAnswerPosition);
            
            const result = document.getElementById('puzzleResult');
            
            // Clear all previous feedback
            squares.forEach(square => {
                const existing = square.querySelector('.square-feedback');
                if (existing) existing.remove();
            });
            
            // Clear button feedback
            for (let i = 0; i < 3; i++) {
                const btn = document.getElementById(`answerBtn${i}`);
                if (btn) {
                    const existing = btn.querySelector('.button-feedback');
                    if (existing) existing.remove();
                }
            }
            
            // Add feedback based on what's wrong/right
            if (!isCorrectArrangement) {
                // Add thumbs down to each square
                squares.forEach(square => {
                    const feedback = document.createElement('div');
                    feedback.className = 'square-feedback';
                    feedback.innerHTML = '👎';
                    feedback.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        font-size: 24px;
                        z-index: 20;
                    `;
                    square.appendChild(feedback);
                });
            } else {
                // Add thumbs up to each square if arrangement is correct
                squares.forEach(square => {
                    const feedback = document.createElement('div');
                    feedback.className = 'square-feedback';
                    feedback.innerHTML = '👍';
                    feedback.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        font-size: 24px;
                        z-index: 20;
                    `;
                    square.appendChild(feedback);
                });
            }
            
            // Add feedback to the selected button
            const selectedBtn = document.getElementById(`answerBtn${selectedIndex}`);
            if (selectedBtn) {
                const feedback = document.createElement('div');
                feedback.className = 'button-feedback';
                feedback.innerHTML = isCorrectAnswer ? '👍' : '👎';
                feedback.style.cssText = `
                    position: absolute;
                    top: -10px;
                    right: -10px;
                    font-size: 20px;
                    z-index: 25;
                `;
                selectedBtn.appendChild(feedback);
            }
            
            // Both must be correct to succeed
            if (isCorrectArrangement && isCorrectAnswer) {
                // Mark door as open
                door.open = true;
                door.color = '#B8F2B8';
                
                // Complete rocket boost movement if active
                completeRocketBoostMovement();
                
                // Add 1 point
                updateScore(1);
                
                // Close modal after brief delay
                setTimeout(() => {
                    document.getElementById('puzzleModal').style.display = 'none';
                    game.puzzleActive = false;
                    // Clear the multiplication door reference
                    game.currentMultiplicationDoor = null;
                }, 800);
            } else {
                // Deduct points based on difficulty
                if (!door.currentProblemAttempts) door.currentProblemAttempts = 0;
                door.currentProblemAttempts++;
                
                let pointsToDeduct = 0;
                if (game.difficultyMode === 'easy') {
                    pointsToDeduct = -1;
                } else if (game.difficultyMode === 'medium') {
                    pointsToDeduct = door.currentProblemAttempts === 1 ? -1 : -2;
                } else {
                    pointsToDeduct = door.currentProblemAttempts === 1 ? -1 : -3;
                }
                updateScore(pointsToDeduct);
                
                // Clear all feedback after 3 seconds
                setTimeout(() => {
                    squares.forEach(square => {
                        const existing = square.querySelector('.square-feedback');
                        if (existing) existing.remove();
                    });
                    
                    for (let i = 0; i < 3; i++) {
                        const btn = document.getElementById(`answerBtn${i}`);
                        if (btn) {
                            const existing = btn.querySelector('.button-feedback');
                            if (existing) existing.remove();
                        }
                    }
                }, 3000);
                
                // Generate new problem after 3 failures
                if (door.currentProblemAttempts >= 3) {
                    setTimeout(() => {
                        door.currentProblemAttempts = 0;
                        showMultiplicationGroupsPuzzle(door);
                    }, 2500);
                }
            }
        }
        
        function showPuzzle(type, door) {
            const modal = document.getElementById('puzzleModal');
            const title = document.getElementById('puzzleTitle');
            const question = document.getElementById('puzzleQuestion');
            const options = document.getElementById('puzzleOptions');
            
            game.puzzleActive = true;
            modal.style.display = 'block';
            
            if (type === 'math') {
                // Check if this is Level 10 - use interactive multiplication groups
                if (game.selectedDifficulty === 10) {
                    console.log('=== CALLING MULTIPLICATION PUZZLE ===');
                    console.log('Level 10 detected, calling showMultiplicationGroupsPuzzle with door:', door);
                    showMultiplicationGroupsPuzzle(door);
                    return;
                }
                
                // Check if this is Level 4 and up - use number line puzzles  
                if (game.selectedDifficulty >= 4) {
                    // Determine equation type based on level
                    let equationType;
                    if (game.selectedDifficulty === 8 || game.selectedDifficulty === 9) {
                        equationType = 'triple_add'; // A+B+C for levels 8-9
                    } else {
                        equationType = 'simple'; // A+B or A-B for levels 4-7
                    }
                    
                    // Generate the puzzle using our reusable function
                    const puzzle = createNumberLinePuzzle(door, equationType);
                    
                    // Set the title
                    title.innerHTML = puzzle.title;
                    question.innerHTML = '';
                    
                    // Create interface with number line and multiple choice
                    options.innerHTML = `
                        <div class="numberline-container" style="margin: 20px auto; max-width: 600px;">
                            <div class="number-grid" id="numberGrid" style="
                                display: grid;
                                grid-template-columns: repeat(13, 1fr);
                                gap: 2px;
                                border: 2px solid #666;
                                margin-bottom: 10px;
                                background: white;
                                padding: 5px;
                                border-radius: 10px;
                            "></div>
                            <div class="grid-labels" id="gridLabels" style="
                                display: grid;
                                grid-template-columns: repeat(13, 1fr);
                                gap: 2px;
                                text-align: center;
                                font-size: 12px;
                                font-weight: bold;
                            "></div>
                        </div>
                        <div style="margin-top: 20px;">
                            <div id="answerButtons" style="display: flex; gap: 15px; justify-content: center;">
                            </div>
                        </div>
                    `;
                    
                    // Create answer buttons
                    const answerContainer = document.getElementById('answerButtons');
                    puzzle.allAnswers.forEach(ans => {
                        const button = document.createElement('button');
                        button.textContent = ans;
                        button.style.cssText = `
                            padding: 15px 25px;
                            font-size: 18px;
                            font-weight: bold;
                            border: 2px solid #4CAF50;
                            border-radius: 8px;
                            background: white;
                            color: #4CAF50;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        `;
                        button.onmouseover = () => {
                            button.style.background = '#4CAF50';
                            button.style.color = 'white';
                        };
                        button.onmouseout = () => {
                            button.style.background = 'white';
                            button.style.color = '#4CAF50';
                        };
                        button.onclick = () => checkAnswer(ans === puzzle.answer, type, door, button);
                        answerContainer.appendChild(button);
                    });
                    
                    // Initialize the number line with black cell 0 for all levels 4+
                    initializeNumberLine(door);
                    
                    return; // Exit early for all number line levels
                } else {
                    // Levels 1-3: Regular multiple choice math (answers 1-12)
                    const isAddition = Math.random() < 0.5;
                    let num1, num2, answer;
                    const maxAnswer = 12; // Max answer for Levels 1-3
                    
                    if (isAddition) {
                        // For addition, ensure sum doesn't exceed maxAnswer
                        const maxNum1 = maxAnswer - 1;
                        num1 = Math.floor(Math.random() * maxNum1) + 1; // 1 to (maxAnswer-1)
                        num2 = Math.floor(Math.random() * (maxAnswer - num1)) + 1; // 1 to (maxAnswer-num1)
                        answer = num1 + num2;
                        title.textContent = `${num1} + ${num2} = ?`;
                    } else {
                        // For subtraction, ensure result is between 1-maxAnswer
                        num1 = Math.floor(Math.random() * maxAnswer) + 1;
                        num2 = Math.floor(Math.random() * Math.min(num1, maxAnswer)) + 1;
                        answer = num1 - num2;
                        title.textContent = `${num1} - ${num2} = ?`;
                    }
                    
                    question.textContent = '';
                    
                    // Generate wrong answers between 1-maxAnswer
                    const wrongAnswers = [];
                    while (wrongAnswers.length < 2) {
                        const wrong = Math.floor(Math.random() * maxAnswer) + 1;
                        if (wrong !== answer && !wrongAnswers.includes(wrong)) {
                            wrongAnswers.push(wrong);
                        }
                    }
                    
                    const allAnswers = [answer, ...wrongAnswers].sort(() => Math.random() - 0.5);
                    
                    options.innerHTML = '';
                    allAnswers.forEach(ans => {
                        const button = document.createElement('button');
                        button.className = 'puzzle-button';
                        button.textContent = ans;
                        button.onclick = () => checkAnswer(ans === answer, type, door, button);
                        options.appendChild(button);
                    });
                }
            } else if (type === 'reading') {
                // Check if this is Level 8, 9, or 10 - use division
                if (game.selectedDifficulty === 8 || game.selectedDifficulty === 9 || game.selectedDifficulty === 10) {
                    // Clean up any existing keyboard handlers before starting division puzzle
                    if (game.currentKeyHandler) {
                        document.removeEventListener('keydown', game.currentKeyHandler);
                        game.currentKeyHandler = null;
                    }
                    
                    // Use the reusable division puzzle function
                    const divisionPuzzle = createDivisionPuzzle(door);
                    title.innerHTML = divisionPuzzle.title;
                    question.innerHTML = '';
                    options.innerHTML = divisionPuzzle.html;
                    
                    // Setup drag and drop functionality
                    setupDivisionDragDrop(door);
                    
                    // Add Enter key handler for division puzzle
                    const divisionKeyHandler = (e) => {
                        if (e.key === 'Enter') {
                            submitDivisionAnswer();
                        }
                    };
                    document.addEventListener('keydown', divisionKeyHandler);
                    game.currentKeyHandler = divisionKeyHandler;
                    
                    // Auto-select the first dot for easier interaction
                    setTimeout(() => {
                        const firstDot = document.querySelector('#dotsContainer .dot');
                        if (firstDot) {
                            const dotId = firstDot.getAttribute('data-dot-id');
                            selectDot(parseInt(dotId));
                            console.log(`Auto-selected first dot ${dotId} on puzzle load`);
                        }
                    }, 100);
                    
                    return; // Exit early for Level 8/9 reading (division)
                }
                // Check if this is Level 3, 4, 5, 6, or 7 - use digraph game instead of regular reading
                else if (game.selectedDifficulty === 3 || game.selectedDifficulty === 4 || game.selectedDifficulty === 5 || game.selectedDifficulty === 6 || game.selectedDifficulty === 7) {
                    // Level 3 Digraph Game
                    if (!game.digraphEmojis || Object.keys(game.digraphEmojis).length === 0) {
                        console.error('Digraph data not loaded yet!');
                        return;
                    }
                    
                    // Get available digraphs (exclude already used ones)
                    const allDigraphs = Object.keys(game.digraphEmojis);
                    const availableDigraphs = allDigraphs.filter(digraph => !game.usedDigraphs.includes(digraph));
                    
                    // If all digraphs have been used, reset the used list
                    const digraphsToUse = availableDigraphs.length > 0 ? availableDigraphs : allDigraphs;
                    if (availableDigraphs.length === 0) {
                        game.usedDigraphs = [];
                        console.log('All digraphs used - resetting digraph tracking for this level');
                    }
                    
                    // Pick a random digraph
                    const selectedDigraph = digraphsToUse[Math.floor(Math.random() * digraphsToUse.length)];
                    
                    // Add to used digraphs list
                    if (!game.usedDigraphs.includes(selectedDigraph)) {
                        game.usedDigraphs.push(selectedDigraph);
                    }
                    
                    // Get emojis for this digraph - randomly pick one as correct answer
                    const digraphEmojis = game.digraphEmojis[selectedDigraph];
                    const correctEmoji = digraphEmojis[Math.floor(Math.random() * digraphEmojis.length)]; // Random emoji from this digraph
                    
                    // Get wrong emojis from OTHER digraphs (emojis that don't contain this sound)
                    const wrongEmojis = [];
                    let otherDigraphs = Object.keys(game.digraphEmojis).filter(d => d !== selectedDigraph);
                    
                    // Avoid confusing SK/SC pairs - they sound too similar
                    if (selectedDigraph === 'SK') {
                        otherDigraphs = otherDigraphs.filter(d => d !== 'SC');
                    } else if (selectedDigraph === 'SC') {
                        otherDigraphs = otherDigraphs.filter(d => d !== 'SK');
                    }
                    
                    while (wrongEmojis.length < 2 && otherDigraphs.length > 0) {
                        const randomDigraph = otherDigraphs[Math.floor(Math.random() * otherDigraphs.length)];
                        const randomEmojiArray = game.digraphEmojis[randomDigraph];
                        const randomEmoji = randomEmojiArray[Math.floor(Math.random() * randomEmojiArray.length)];
                        
                        // Make sure this emoji doesn't contain our target sound and isn't already used
                        if (!wrongEmojis.includes(randomEmoji) && randomEmoji !== correctEmoji) {
                            wrongEmojis.push(randomEmoji);
                        }
                    }
                    
                    // Display the digraph letters
                    title.innerHTML = `<div style="font-size: 48px; font-weight: bold; color: #2E8B57; margin-bottom: 15px;">${selectedDigraph}</div>`;
                    
                    // Add speaker button in question area
                    const soundToSpeak = game.digraphSounds[selectedDigraph] || selectedDigraph.toLowerCase();
                    question.innerHTML = `
                        <button onclick="speakDigraph('${soundToSpeak}')" style="
                            background: white; 
                            color: black; 
                            border: 3px solid #4CAF50; 
                            padding: 15px 25px; 
                            font-size: 24px; 
                            border-radius: 50%; 
                            cursor: pointer; 
                            margin-bottom: 20px;
                            width: 70px;
                            height: 70px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            margin: 0 auto 20px auto;
                        ">🔊</button>
                    `;
                    
                    // Shuffle all answer options
                    const allAnswers = [correctEmoji, ...wrongEmojis.slice(0, 2)].sort(() => Math.random() - 0.5);
                    
                    options.innerHTML = '';
                    allAnswers.forEach(emoji => {
                        const button = document.createElement('button');
                        button.className = 'puzzle-button';
                        button.textContent = emoji;
                        button.style.fontSize = '48px';
                        button.style.background = 'white';
                        button.style.color = 'black';
                        button.style.border = '3px solid #4CAF50';
                        button.style.minWidth = '120px';
                        button.style.minHeight = '100px';
                        button.onclick = () => checkAnswer(emoji === correctEmoji, type, door, button, emoji);
                        options.appendChild(button);
                    });
                } else {
                    // Regular reading game for Levels 1 and 2
                    const wordEmojiPairs = game.wordEmojiPairs;
                    
                    // Filter out already used words in this level
                    const availableWords = wordEmojiPairs.filter(pair => !game.usedWords.includes(pair.word));
                    
                    // If all words have been used, reset the used words list
                    const wordsToUse = availableWords.length > 0 ? availableWords : wordEmojiPairs;
                    if (availableWords.length === 0) {
                        game.usedWords = [];
                        console.log('All words used - resetting word tracking for this level');
                    }
                    
                    // Pick a random word-emoji pair from available words
                    const correctPair = wordsToUse[Math.floor(Math.random() * wordsToUse.length)];
                    
                    // Add this word to used words list
                    if (!game.usedWords.includes(correctPair.word)) {
                        game.usedWords.push(correctPair.word);
                    }
                    
                    // Check if word list is loaded
                    if (!wordEmojiPairs || wordEmojiPairs.length === 0) {
                        console.error('Word list not loaded yet!');
                        return;
                    }
                    
                    const firstLetter = correctPair.word.charAt(0).toUpperCase();
                    const wrongEmojis = [];
                    
                    // Try to find words with same first letter
                    const sameLetterWords = wordEmojiPairs.filter(pair => 
                        pair.word.charAt(0).toUpperCase() === firstLetter && 
                        pair.word !== correctPair.word
                    );
                    
                    // Add wrong emojis from same-letter words
                    while (wrongEmojis.length < 2 && sameLetterWords.length > 0) {
                        const randomIndex = Math.floor(Math.random() * sameLetterWords.length);
                        const wrongPair = sameLetterWords.splice(randomIndex, 1)[0];
                        wrongEmojis.push(wrongPair.emoji);
                    }
                    
                    // If not enough same-letter words, use distractors
                    if (wrongEmojis.length < 2 && game.distractors[firstLetter]) {
                        const distractorEmojis = [...game.distractors[firstLetter]];
                        while (wrongEmojis.length < 2 && distractorEmojis.length > 0) {
                            const randomIndex = Math.floor(Math.random() * distractorEmojis.length);
                            const distractor = distractorEmojis.splice(randomIndex, 1)[0];
                            wrongEmojis.push(distractor);
                        }
                    }
                    
                    // Final fallback to any random emojis if still not enough
                    if (wrongEmojis.length < 2) {
                        const allEmojis = wordEmojiPairs.map(pair => pair.emoji);
                        while (wrongEmojis.length < 2) {
                            const randomEmoji = allEmojis[Math.floor(Math.random() * allEmojis.length)];
                            if (randomEmoji !== correctPair.emoji && !wrongEmojis.includes(randomEmoji)) {
                                wrongEmojis.push(randomEmoji);
                            }
                        }
                    }
                    
                    title.textContent = correctPair.word;
                    question.textContent = '';
                    
                    const allAnswers = [correctPair.emoji, ...wrongEmojis].sort(() => Math.random() - 0.5);
                    
                    options.innerHTML = '';
                    allAnswers.forEach(emoji => {
                        const button = document.createElement('button');
                        button.className = 'puzzle-button';
                        button.textContent = emoji;
                        button.style.fontSize = '40px'; // Make emojis bigger
                        button.style.background = 'white'; // White background for emoji buttons
                        button.style.color = 'black'; // Black text for better contrast
                        button.style.border = '3px solid #4CAF50'; // Green border
                        button.onclick = () => checkAnswer(emoji === correctPair.emoji, type, door, button);
                        options.appendChild(button);
                    });
                }
            } else if (type === 'reading1') {
                // Math problems (same as main math problems)
                const isAddition = Math.random() < 0.5;
                let num1, num2, answer;
                const maxAnswer = 12; // Max answer for math problems
                
                if (isAddition) {
                    // For addition, ensure sum doesn't exceed maxAnswer
                    const maxNum1 = maxAnswer - 1;
                    num1 = Math.floor(Math.random() * maxNum1) + 1; // 1 to (maxAnswer-1)
                    num2 = Math.floor(Math.random() * (maxAnswer - num1)) + 1; // 1 to (maxAnswer-num1)
                    answer = num1 + num2;
                    title.textContent = `${num1} + ${num2} = ?`;
                } else {
                    // For subtraction, ensure result is between 1-maxAnswer
                    num1 = Math.floor(Math.random() * maxAnswer) + 1;
                    num2 = Math.floor(Math.random() * Math.min(num1, maxAnswer)) + 1;
                    answer = num1 - num2;
                    title.textContent = `${num1} - ${num2} = ?`;
                }
                
                question.textContent = '';
                
                // Generate wrong answers between 1-maxAnswer
                const wrongAnswers = [];
                while (wrongAnswers.length < 2) {
                    const wrong = Math.floor(Math.random() * maxAnswer) + 1;
                    if (wrong !== answer && !wrongAnswers.includes(wrong)) {
                        wrongAnswers.push(wrong);
                    }
                }
                
                const allAnswers = [answer, ...wrongAnswers].sort(() => Math.random() - 0.5);
                
                options.innerHTML = '';
                allAnswers.forEach(ans => {
                    const button = document.createElement('button');
                    button.className = 'puzzle-button';
                    button.textContent = ans;
                    button.onclick = () => checkAnswer(ans === answer, type, door, button);
                    options.appendChild(button);
                });
            } else if (type === 'reading2') {
                // Emoji to word matching with same-first-letter strategy - show emoji, choose word
                const wordEmojiPairs = game.wordEmojiPairs;
                
                // Check if word list is loaded
                if (!wordEmojiPairs || wordEmojiPairs.length === 0) {
                    console.error('Word list not loaded yet!');
                    return;
                }
                
                // Filter out already used words in this level
                const availableWords = wordEmojiPairs.filter(pair => !game.usedWords.includes(pair.word));
                
                // If all words have been used, reset the used words list
                const wordsToUse = availableWords.length > 0 ? availableWords : wordEmojiPairs;
                if (availableWords.length === 0) {
                    game.usedWords = [];
                    console.log('All words used - resetting word tracking for this level');
                }
                
                // Pick a random word-emoji pair from available words
                const correctPair = wordsToUse[Math.floor(Math.random() * wordsToUse.length)];
                
                // Add this word to used words list
                if (!game.usedWords.includes(correctPair.word)) {
                    game.usedWords.push(correctPair.word);
                }
                const firstLetter = correctPair.word.charAt(0).toUpperCase();
                const wrongWords = [];
                
                // Try to find words with same first letter
                const sameLetterWords = wordEmojiPairs.filter(pair => 
                    pair.word.charAt(0).toUpperCase() === firstLetter && 
                    pair.word !== correctPair.word
                );
                
                // Add wrong words from same-letter words
                while (wrongWords.length < 2 && sameLetterWords.length > 0) {
                    const randomIndex = Math.floor(Math.random() * sameLetterWords.length);
                    const wrongPair = sameLetterWords.splice(randomIndex, 1)[0];
                    wrongWords.push(wrongPair.word);
                }
                
                // If not enough same-letter words, use distractors (words that start with same letter)
                if (wrongWords.length < 2 && game.distractors[firstLetter]) {
                    // Convert distractors to fake words that start with the same letter
                    const commonWords = {
                        'A': ['APPLE', 'ARROW', 'ANGEL'],
                        'B': ['BREAD', 'BRUSH', 'BRAIN'],
                        'C': ['CLOUD', 'CHAIR', 'CROWN'],
                        'D': ['DUCK', 'DRUM', 'DOOR'],
                        'F': ['FISH', 'FIRE', 'FARM'],
                        'G': ['GRASS', 'GIFT', 'GUARD'],
                        'H': ['HOUSE', 'HEART', 'HORSE'],
                        'L': ['LAMP', 'LEAF', 'LOCK'],
                        'M': ['MILK', 'MASK', 'MAGIC'],
                        'P': ['PLANT', 'PIZZA', 'PLANE'],
                        'R': ['ROBOT', 'RING', 'ROCK'],
                        'S': ['STAR', 'SNAKE', 'SMILE'],
                        'T': ['TREE', 'TRUCK', 'TIGER']
                    };
                    
                    if (commonWords[firstLetter]) {
                        const availableWords = commonWords[firstLetter].filter(word => 
                            word !== correctPair.word.toUpperCase() && 
                            !wrongWords.includes(word)
                        );
                        
                        while (wrongWords.length < 2 && availableWords.length > 0) {
                            const randomIndex = Math.floor(Math.random() * availableWords.length);
                            const word = availableWords.splice(randomIndex, 1)[0];
                            wrongWords.push(word);
                        }
                    }
                }
                
                // Final fallback to any random words if still not enough
                if (wrongWords.length < 2) {
                    while (wrongWords.length < 2) {
                        const randomPair = wordEmojiPairs[Math.floor(Math.random() * wordEmojiPairs.length)];
                        if (randomPair.word !== correctPair.word && !wrongWords.includes(randomPair.word)) {
                            wrongWords.push(randomPair.word);
                        }
                    }
                }
                
                title.textContent = ''; // No title for reading2 type
                question.innerHTML = `<div style=\"font-size: 48px; margin: 20px 0;\">${correctPair.emoji}</div>`;
                
                const allAnswers = [correctPair.word, ...wrongWords].sort(() => Math.random() - 0.5);
                
                options.innerHTML = '';
                allAnswers.forEach(word => {
                    const button = document.createElement('button');
                    button.className = 'puzzle-button';
                    button.textContent = word;
                    button.style.fontSize = '24px';
                    button.onclick = () => checkAnswer(word === correctPair.word, type, door, button);
                    options.appendChild(button);
                });
            }
        }
        
        function initializeNumberLine(door) {
            const numberGrid = document.getElementById('numberGrid');
            const gridLabels = document.getElementById('gridLabels');
            
            if (!numberGrid || !gridLabels) return;
            
            // Ensure we have valid starting data
            if (door.mathStartPosition === undefined || door.mathAnswer === undefined) {
                console.error('Door missing math data:', door);
                return;
            }
            
            // Clear any previous number line state
            door.ptCanvases = {}; // Store PT canvases for each cell
            
            // Create grid cells (0 to 12)
            numberGrid.innerHTML = '';
            for (let i = 0; i <= 12; i++) {
                const cell = document.createElement('div');
                cell.id = `grid-cell-${i}`;
                // Simplify: make cell 0 black for levels 4+ OR in test mode
                let cellBackgroundColor = 'white';
                if (i === 0 && (game.testMode || game.selectedDifficulty >= 4)) {
                    cellBackgroundColor = 'black';
                }
                if (i === 0) {
                    console.log(`LEVEL ${game.selectedDifficulty}: Test mode: ${game.testMode}, Cell 0 background: ${cellBackgroundColor}, Condition: testMode=${game.testMode}, selectedDifficulty=${game.selectedDifficulty}`);
                }
                cell.style.cssText = `
                    aspect-ratio: 1;
                    border: 1px solid #ccc;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    position: relative;
                    min-height: 35px;
                    background-color: ${cellBackgroundColor} !important;
                    transition: background-color 0.3s ease;
                    cursor: pointer;
                `;
                cell.onclick = () => movePTToPosition(i, door);
                
                // Create PT canvas for this cell
                const ptCanvas = document.createElement('canvas');
                ptCanvas.width = 30;
                ptCanvas.height = 30;
                ptCanvas.id = `pt-canvas-${i}`;
                ptCanvas.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                    z-index: 10;
                `;
                cell.appendChild(ptCanvas);
                door.ptCanvases[i] = ptCanvas;
                
                numberGrid.appendChild(cell);
            }
            
            // Create grid labels (0 to 12)
            gridLabels.innerHTML = '';
            for (let i = 0; i <= 12; i++) {
                const label = document.createElement('div');
                label.id = `grid-label-${i}`;
                label.textContent = i;
                // Simplify: make label 0 black for levels 4+ OR in test mode
                let labelColor = '#2E8B57';
                if (i === 0 && (game.testMode || game.selectedDifficulty >= 4)) {
                    labelColor = 'black';
                }
                label.style.cssText = `
                    font-size: 14px;
                    font-weight: bold;
                    color: ${labelColor};
                    padding: 5px 0;
                    transition: color 0.3s ease;
                    cursor: pointer;
                `;
                label.onclick = () => movePTToPosition(i, door);
                gridLabels.appendChild(label);
            }
            
            // Position PT at starting position
            console.log(`Initializing number line: start position = ${door.mathStartPosition}, answer = ${door.mathAnswer}`);
            movePTToPosition(door.mathStartPosition, door);
            
            // Remove any existing keyboard listeners
            if (game.currentKeyHandler) {
                document.removeEventListener('keydown', game.currentKeyHandler);
                console.log('Removed previous keyboard handler');
            }
            
            // Add keyboard event listener with door reference
            const keyHandler = (e) => numberLineKeyHandler(e, door);
            document.addEventListener('keydown', keyHandler);
            
            // Store the handler globally and on door
            game.currentKeyHandler = keyHandler;
            door.keyHandler = keyHandler;
            console.log('Added new number line keyboard handler');
            
            // Add submit button handler
            const submitBtn = document.getElementById('submitNumberLine');
            if (submitBtn) {
                submitBtn.onclick = () => checkNumberLineAnswer(door);
            }
        }
        
        function initializeNumberLineLevel8(door) {
            const numberGrid = document.getElementById('numberGrid');
            const gridLabels = document.getElementById('gridLabels');
            
            if (!numberGrid || !gridLabels) return;
            
            // Ensure we have valid starting data
            if (door.mathStartPosition === undefined || door.mathAnswer === undefined) {
                console.error('Door missing math data:', door);
                return;
            }
            
            // Clear any previous number line state
            door.ptCanvases = {}; // Store PT canvases for each cell
            
            // Create grid cells (0 to 12)
            numberGrid.innerHTML = '';
            for (let i = 0; i <= 12; i++) {
                const cell = document.createElement('div');
                cell.id = `grid-cell-${i}`;
                const backgroundColor = i === 0 ? 'black' : 'white'; // Color 0 block black
                cell.style.cssText = `
                    aspect-ratio: 1;
                    border: 1px solid #ccc;
                    background-color: ${backgroundColor};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    position: relative;
                    min-height: 35px;
                    transition: background-color 0.3s ease;
                    cursor: pointer;
                `;
                cell.onclick = () => movePTToPosition(i, door);
                
                // Create PT canvas for this cell
                const ptCanvas = document.createElement('canvas');
                ptCanvas.width = 30;
                ptCanvas.height = 30;
                ptCanvas.id = `pt-canvas-${i}`;
                ptCanvas.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                    z-index: 10;
                `;
                cell.appendChild(ptCanvas);
                door.ptCanvases[i] = ptCanvas;
                
                numberGrid.appendChild(cell);
            }
            
            // Create grid labels (0 to 12)
            gridLabels.innerHTML = '';
            for (let i = 0; i <= 12; i++) {
                const label = document.createElement('div');
                label.id = `grid-label-${i}`;
                label.textContent = i;
                // Keep all labels green for visibility
                label.style.cssText = `
                    font-size: 14px;
                    font-weight: bold;
                    color: #2E8B57;
                    padding: 5px 0;
                    transition: color 0.3s ease;
                    cursor: pointer;
                `;
                label.onclick = () => movePTToPosition(i, door);
                gridLabels.appendChild(label);
            }
            
            // Position PT at starting position
            console.log(`Initializing Level 8 number line: start position = ${door.mathStartPosition}, answer = ${door.mathAnswer}`);
            movePTToPosition(door.mathStartPosition, door);
            
            // Add keyboard event listener for Level 8 (but no submit functionality)
            const keyHandler = (e) => numberLineKeyHandler(e, door);
            
            // Remove any existing keyboard listeners first
            if (game.currentKeyHandler) {
                document.removeEventListener('keydown', game.currentKeyHandler);
                console.log('Removed previous keyboard handler');
            }
            
            document.addEventListener('keydown', keyHandler);
            game.currentKeyHandler = keyHandler;
            door.keyHandler = keyHandler;
            console.log('Added new Level 8 keyboard handler');
        }
        
        function movePTToPosition(position, door) {
            if (position < 0 || position > 12 || !door.ptCanvases) return;
            
            console.log(`Moving PT from ${door.foxPosition} to position ${position}, start position is ${door.mathStartPosition}, answer is ${door.mathAnswer}`);
            
            // Ensure starting position is never changed
            const startPos = door.mathStartPosition;
            door.foxPosition = position;
            
            // Clear all PT canvases first
            for (let i = 0; i <= 12; i++) {
                if (door.ptCanvases[i]) {
                    const ctx = door.ptCanvases[i].getContext('2d');
                    ctx.clearRect(0, 0, 30, 30);
                }
            }
            
            // Update grid cell colors - reset all first, then apply colors
            for (let i = 0; i <= 12; i++) {
                const gridCell = document.getElementById(`grid-cell-${i}`);
                const gridLabel = document.getElementById(`grid-label-${i}`);
                
                if (gridCell && gridLabel) {
                    // Reset to default - but preserve black for 0 in Level 4+ or test mode
                    if (i === 0 && (game.selectedDifficulty >= 4 || game.testMode)) {
                        gridCell.style.backgroundColor = 'black'; // Keep 0 black in Level 4+ or test mode
                        gridLabel.style.color = 'black'; // Make 0 label black too
                    } else {
                        gridCell.style.backgroundColor = '';
                        gridLabel.style.color = '#2E8B57';
                    }
                }
            }
            
            // Apply colors based on position relationship
            for (let i = 0; i <= 12; i++) {
                const gridCell = document.getElementById(`grid-cell-${i}`);
                const gridLabel = document.getElementById(`grid-label-${i}`);
                
                if (gridCell && gridLabel) {
                    if (i === startPos) {
                        // Start position coloring - but preserve black for 0 in Level 4+ or test mode
                        if (i === 0 && (game.selectedDifficulty >= 4 || game.testMode)) {
                            gridCell.style.backgroundColor = 'black'; // Keep 0 black in Level 4+ or test mode
                            gridLabel.style.color = 'black'; // Keep 0 label black too
                        } else {
                            gridCell.style.backgroundColor = '#32CD32'; // Green for other levels
                            gridLabel.style.color = '#32CD32';
                        }
                    } else if (i === position) {
                        // Current position (only if different from start)
                        if (position < startPos) {
                            gridCell.style.backgroundColor = '#4169E1';
                            gridLabel.style.color = '#4169E1';
                        } else if (position > startPos) {
                            gridCell.style.backgroundColor = '#FF8C00';
                            gridLabel.style.color = '#FF8C00';
                        }
                        // If position === startPos, it stays green from above
                    } else {
                        // Check if cell is between start and current position
                        const minPos = Math.min(startPos, position);
                        const maxPos = Math.max(startPos, position);
                        if (i > minPos && i < maxPos) {
                            // Between start and current
                            if (position > startPos) {
                                // Moving right - orange trail
                                gridCell.style.backgroundColor = '#FF8C00';
                                gridLabel.style.color = '#FF8C00';
                            } else {
                                // Moving left - blue trail
                                gridCell.style.backgroundColor = '#4169E1';
                                gridLabel.style.color = '#4169E1';
                            }
                        }
                    }
                }
            }
            
            // ALWAYS draw PT sprite in the current position cell, regardless of color
            if (door.ptCanvases[position]) {
                const ctx = door.ptCanvases[position].getContext('2d');
                
                // Draw PT using the movement sprite (up/down frames)
                if (currentMovementSprites && currentMovementSprites.complete) {
                    // Use frame 5 (up/down facing) - frameX = 640
                    const frameX = 640; // Frame 5 (up/down sprite)
                    ctx.drawImage(
                        currentMovementSprites,
                        frameX, 0, 160, 160, // Source: frame 5 (up/down facing)
                        0, 0, 30, 30   // Destination: fill the canvas
                    );
                } else {
                    // Fallback circle if sprite not loaded - make it more visible
                    ctx.fillStyle = '#FF0000'; // Red circle for debugging
                    ctx.beginPath();
                    ctx.arc(15, 15, 12, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                console.log(`PT drawn at position ${position} using up/down sprite`);
            }
        }
        
        function numberLineKeyHandler(e, door) {
            // Only handle if we're in a number line puzzle
            if (!game.puzzleActive || game.selectedDifficulty < 4) return;
            
            const modal = document.getElementById('puzzleModal');
            if (modal.style.display !== 'block') return;
            
            // Use the door passed directly to avoid confusion
            if (!door || door.mathAnswer === undefined) {
                console.log('Invalid door passed to key handler');
                return;
            }
            
            console.log(`Key pressed: ${e.key}, door start: ${door.mathStartPosition}, current pos: ${door.foxPosition}, answer: ${door.mathAnswer}`);
            console.log('Door object in keyHandler:', door.type, door.row, door.col, 'Level:', game.selectedDifficulty);
            
            if (e.key === 'ArrowLeft' && door.foxPosition > 0) {
                movePTToPosition(door.foxPosition - 1, door);
            } else if (e.key === 'ArrowRight' && door.foxPosition < 12) {
                movePTToPosition(door.foxPosition + 1, door);
            } else if (e.key === 'Enter') {
                checkNumberLineAnswer(door);
            }
        }
        
        function checkNumberLineAnswer(door) {
            const correct = door.foxPosition === door.mathAnswer;
            const result = document.getElementById('puzzleResult');
            
            if (correct) {
                // Remove keyboard listener on success
                if (door.keyHandler) {
                    document.removeEventListener('keydown', door.keyHandler);
                    delete door.keyHandler;
                }
                
                // Replace question mark with correct answer in title
                const title = document.getElementById('puzzleTitle');
                if (title) {
                    title.innerHTML = title.innerHTML.replace('?', door.mathAnswer);
                }
                
                result.innerHTML = '👍';
                result.style.color = 'green';
                result.style.fontSize = '48px';
                
                door.open = true;
                door.color = '#B8F2B8';
                
                // Complete rocket boost movement if active
                completeRocketBoostMovement();
                
                updateScore(1);
                
                // Reset attempt counters
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
                
                setTimeout(() => {
                    document.getElementById('puzzleModal').style.display = 'none';
                    result.innerHTML = '';
                    result.style.fontSize = '';
                    game.puzzleActive = false;
                    // Clear any multiplication door reference
                    game.currentMultiplicationDoor = null;
                }, 800);
            } else {
                result.innerHTML = '👎';
                result.style.color = 'red';
                result.style.fontSize = '48px';
                
                // Deduct points based on difficulty mode
                let pointsToDeduct = 0;
                if (game.difficultyMode === 'easy') {
                    pointsToDeduct = -1;
                } else if (game.difficultyMode === 'medium') {
                    pointsToDeduct = door.currentProblemAttempts === 1 ? -1 : -2;
                } else {
                    pointsToDeduct = -2;
                }
                
                updateScore(pointsToDeduct);
                
                // Track failed attempts
                if (!door.currentProblemAttempts) door.currentProblemAttempts = 0;
                door.currentProblemAttempts++;
                
                // Just show thumbs down and allow unlimited retries until game over
                setTimeout(() => {
                    result.innerHTML = '';
                    result.style.fontSize = '';
                }, 1500);
            }
        }
        
        function checkAnswer(correct, type, door, buttonElement, selectedEmoji = null) {
            const result = document.getElementById('puzzleResult');
            
            // Track attempts for this problem
            if (!door.currentProblemAttempts) door.currentProblemAttempts = 0;
            door.currentProblemAttempts++;
            
            if (correct) {
                result.innerHTML = '👍';
                result.style.color = 'green';
                result.style.fontSize = '48px'; // Make thumbs up bigger
                door.open = true;
                
                // Complete rocket boost movement if active
                completeRocketBoostMovement();
                
                // For Levels 3, 4, 5, 6, 7 digraph puzzles, speak the emoji word name
                if ((game.selectedDifficulty === 3 || game.selectedDifficulty === 4 || game.selectedDifficulty === 5 || game.selectedDifficulty === 6 || game.selectedDifficulty === 7) && type === 'reading' && selectedEmoji) {
                    setTimeout(() => {
                        speakEmojiWord(selectedEmoji);
                    }, 300); // Slight delay after showing thumbs up
                }
                
                // Give +1 point for correct answer (net effect: 1 - number_of_wrong_attempts)
                if (type === 'math') updateScore(1);
                if (type === 'reading') updateScore(1);
                if (type === 'reading1') updateScore(1);
                if (type === 'reading2') updateScore(1);
                if (type === 'sorting') updateScore(1);
                
                // Reset attempt counters
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
                
                // Change door color to match open path
                door.color = '#B8F2B8';
                
                setTimeout(() => {
                    document.getElementById('puzzleModal').style.display = 'none';
                    result.innerHTML = '';
                    result.style.fontSize = ''; // Reset font size
                    game.puzzleActive = false;
                    // Clear any multiplication door reference
                    game.currentMultiplicationDoor = null;
                }, 800); // Faster disappear (800ms instead of 1500ms)
            } else {
                result.innerHTML = '👎';
                result.style.color = 'red';
                
                // For Levels 3, 4, 5, 6, 7 digraph puzzles, speak the emoji word name even for wrong answers
                if ((game.selectedDifficulty === 3 || game.selectedDifficulty === 4 || game.selectedDifficulty === 5 || game.selectedDifficulty === 6 || game.selectedDifficulty === 7) && type === 'reading' && selectedEmoji) {
                    setTimeout(() => {
                        speakEmojiWord(selectedEmoji);
                    }, 300); // Slight delay after showing thumbs down
                }
                
                // Deduct points based on difficulty mode
                let pointsToDeduct = 0;
                
                if (game.difficultyMode === 'easy') {
                    pointsToDeduct = -1; // Always lose 1 point in easy mode
                } else if (game.difficultyMode === 'medium') {
                    // In medium mode: first wrong answer = -1, second wrong answer = -2
                    pointsToDeduct = door.currentProblemAttempts === 1 ? -1 : -2;
                } else {
                    pointsToDeduct = -2; // Hard mode: always lose 2 points
                }
                
                if (type === 'math') updateScore(pointsToDeduct);
                if (type === 'reading') updateScore(pointsToDeduct);
                if (type === 'reading1') updateScore(pointsToDeduct);
                if (type === 'reading2') updateScore(pointsToDeduct);
                if (type === 'sorting') updateScore(pointsToDeduct);
                
                // Disable the wrong answer button
                buttonElement.disabled = true;
                buttonElement.style.backgroundColor = '#ccc';
                buttonElement.style.cursor = 'not-allowed';
                
                // Track failed attempts
                if (!door.failedAttempts) door.failedAttempts = 0;
                door.failedAttempts++;
                
                // If 3 failures, generate new problem
                if (door.failedAttempts >= 3) {
                    setTimeout(() => {
                        door.failedAttempts = 0;
                        door.currentProblemAttempts = 0; // Reset for new problem
                        showPuzzle(type, door); // Generate new problem
                    }, 1500);
                } else {
                    // Clear result after showing thumbs down
                    setTimeout(() => {
                        result.innerHTML = '';
                    }, 1500);
                }
            }
        }
        
        function showCelebration() {
            // Record score for this level
            game.levelScores[game.selectedDifficulty] = game.score;
            game.gameSession.levelsCompleted++;
            game.gameSession.totalScore += game.score;
            
            console.log(`Level ${game.selectedDifficulty} completed with ${game.score} lives remaining`);
            
            // Unlock next level
            unlockNextLevel();
            
            game.celebrating = true;
            game.celebrationFrame = 0;
            game.celebrationTimer = 0;
            
            // Update button text based on whether there's a next level
            const playAgainBtn = document.getElementById('playAgainBtn');
            if (game.selectedDifficulty < 8) {
                playAgainBtn.textContent = 'Next Level';
            } else {
                playAgainBtn.textContent = 'Show Final Score';
            }
            
            document.getElementById('celebrationScreen').style.display = 'flex';
            animateCelebration();
        }
        
        function animateCelebration() {
            if (!game.celebrating) return;
            
            const canvas = document.getElementById('celebrationSprite');
            const ctx = canvas.getContext('2d');
            
            if (currentCelebrationSprites.complete) {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Calculate frame properties using configuration-based approach
                const frameProps = calculateFrameProperties(currentCelebrationSprites, game.selectedDifficulty);
                const { frameWidth, frameHeight, framesPerRow, totalFrames } = frameProps;
                
                // Calculate frame position
                const row = Math.floor(game.celebrationFrame / framesPerRow);
                const col = game.celebrationFrame % framesPerRow;
                const frameX = col * frameWidth;
                const frameY = row * frameHeight;
                
                // Scale to fit canvas while maintaining aspect ratio
                const scaleX = canvas.width / frameWidth;
                const scaleY = canvas.height / frameHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9; // 90% of canvas size for padding
                
                const scaledWidth = frameWidth * scale;
                const scaledHeight = frameHeight * scale;
                const offsetX = (canvas.width - scaledWidth) / 2;
                const offsetY = (canvas.height - scaledHeight) / 2;
                
                // Draw current frame (scaled to fit)
                ctx.drawImage(
                    currentCelebrationSprites,
                    frameX, frameY, frameWidth, frameHeight, // Source frame
                    offsetX, offsetY, scaledWidth, scaledHeight // Destination (scaled and centered)
                );
                
                // Update frame counter (slower for Level 3)
                game.celebrationTimer++;
                const frameDelay = game.selectedDifficulty === 3 ? 40 : 25; // Slower for Level 3
                if (game.celebrationTimer >= frameDelay) {
                    game.celebrationFrame = (game.celebrationFrame + 1) % totalFrames;
                    game.celebrationTimer = 0;
                }
            }
            
            requestAnimationFrame(animateCelebration);
        }
        
        
        
        function resetGame() {
            game.player.x = 0;
            game.player.y = 0;
            game.player.direction = 'right';
            // Only reset testMode if it's not already set to true (preserve test mode)
            if (!game.testMode) {
                game.testMode = false;
            }
            
            // Set starting hearts based on difficulty mode
            if (game.difficultyMode === 'easy' || game.difficultyMode === 'medium') {
                game.score = 5;
            } else {
                game.score = 3; // hard mode
            }
            
            updateScore(0); // This will set the hearts display
            
            // Display level and difficulty mode
            const difficultyEmoji = {
                'easy': '🫛',
                'medium': '😐', 
                'hard': '🙀'
            };
            document.getElementById('level').textContent = `Level: ${game.selectedDifficulty} (${difficultyEmoji[game.difficultyMode]})`;
            
            // Reset used words and digraphs for this level to prevent repetition
            game.usedWords = [];
            game.usedDigraphs = [];
            
            // Reset all doors
            game.doors.forEach(door => {
                door.open = false;
                door.color = door.type === 'math' ? '#FF6B6B' : '#4ECDC4';
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
            });
        }
        
        function playAgain() {
            game.celebrating = false;
            document.getElementById('celebrationScreen').style.display = 'none';
            
            // If there's a next level, advance to it
            if (game.selectedDifficulty < 8) {
                game.selectedDifficulty++;
                console.log(`Advancing to level ${game.selectedDifficulty}`);
                // Load next level directly
                currentCelebrationSprites = loadCelebrationSprite(game.selectedDifficulty);
                initializeGame();
            } else {
                // Completed all levels, show final score
                console.log('All levels completed, showing final score');
                showFinalScore();
            }
        }
        
        // Common component for generating level score displays
        function generateLevelScoreDisplay(maxLevel, deathLevel = null) {
            const container = document.getElementById('levelScoresContainer');
            container.innerHTML = '';
            
            // Add each level score
            for (let level = 1; level <= maxLevel; level++) {
                const score = game.levelScores[level];
                const levelItem = document.createElement('div');
                levelItem.className = 'level-score-item';
                
                // Highlight perfect scores or special achievements
                if (score >= 5) {
                    levelItem.classList.add('special');
                }
                
                // Determine score display based on context
                let scoreDisplay;
                if (score !== undefined) {
                    scoreDisplay = `${score} ♥️`;
                } else if (deathLevel && level === deathLevel) {
                    scoreDisplay = '☠️';
                } else if (deathLevel && level > deathLevel) {
                    scoreDisplay = '-';
                } else {
                    scoreDisplay = score || 0;
                    scoreDisplay = `${scoreDisplay} ♥️`;
                }
                
                levelItem.innerHTML = `
                    <div style="display: flex; align-items: center;">
                        <div class="level-wall-block" style="background-image: url('level-${level}/wall.png');"></div>
                        <div class="level-score-number">Level ${level}</div>
                    </div>
                    <div class="level-score-hearts">${scoreDisplay}</div>
                `;
                
                container.appendChild(levelItem);
            }
            
            // Add total score row
            const totalScore = Object.values(game.levelScores).reduce((sum, score) => sum + score, 0);
            const totalItem = document.createElement('div');
            totalItem.className = 'level-score-item';
            totalItem.style.borderTop = '2px solid #4CAF50';
            totalItem.style.marginTop = '10px';
            totalItem.style.fontWeight = 'bold';
            
            totalItem.innerHTML = `
                <div style="display: flex; align-items: center;">
                    <div class="level-score-number">Total</div>
                </div>
                <div class="level-score-hearts">${totalScore} ♥️</div>
            `;
            
            container.appendChild(totalItem);
        }
        
        function showFinalScore() {
            // Use common component to generate level score display (levels 1-10)
            generateLevelScoreDisplay(10);
            
            // Hide total score section (we're showing it inline now)
            document.getElementById('totalScoreSection').style.display = 'none';
            
            // Show the final score screen
            document.getElementById('finalScoreScreen').style.display = 'flex';
        }
        
        function restartFromFinalScore() {
            // Hide final score screen
            document.getElementById('finalScoreScreen').style.display = 'none';
            
            // Reset game session data
            game.levelScores = {};
            game.deathLevel = null;
            game.gameSession = {
                startTime: Date.now(),
                levelsCompleted: 0,
                totalScore: 0
            };
            
            // Show difficulty selection to start over
            document.getElementById('difficultyScreen').style.display = 'flex';
        }
        
        function showGameOverScore() {
            // Hide game over screen
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Update the title
            document.getElementById('finalScoreTitle').textContent = 'Your Scores';
            
            // Use common component to generate level score display (levels 1-10, with death level indicator)
            generateLevelScoreDisplay(10, game.deathLevel);
            
            // Hide total score section
            document.getElementById('totalScoreSection').style.display = 'none';
            
            // Change the button to "Try Again"
            const finalScoreBtn = document.getElementById('finalScoreBtn');
            finalScoreBtn.textContent = 'Try Again';
            finalScoreBtn.onclick = () => {
                // Hide final score screen and restart game
                document.getElementById('finalScoreScreen').style.display = 'none';
                restartGame();
                
                // Restore original title and button for future use
                document.getElementById('finalScoreTitle').textContent = '🎉 Congratulations! 🎉';
                document.getElementById('totalScoreSection').style.display = 'block';
                finalScoreBtn.textContent = 'Play Again';
                finalScoreBtn.onclick = restartFromFinalScore;
            };
            
            // Show the final score screen
            document.getElementById('finalScoreScreen').style.display = 'flex';
        }
        
        // Game loop
        function gameLoop() {
            // Update animation timer
            game.player.animTimer++;
            
            // Reset moving flag after a short time (creates a brief walking animation)
            if (game.player.isMoving && game.player.animTimer > 10) {
                game.player.isMoving = false;
                game.player.animTimer = 0;
            }
            
            if (!game.celebrating) {
                drawGame();
            }
            requestAnimationFrame(gameLoop);
        }
        
        
        // Show difficulty selection screen on game start
        // The game will start after user selects difficulty via selectDifficulty() function
    </script>
</body>
</html>