<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elephant Maze Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #2E8B57;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }
        
        #gameContainer {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
        
        #gameCanvas {
            border: 3px solid #2E8B57;
            border-radius: 10px;
            display: block;
        }
        
        #gameInfo {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
        }
        
        #score {
            color: #FF6347;
        }
        
        #level {
            color: #4169E1;
        }
        
        #puzzleModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 5000;
        }
        
        #puzzleContent {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-width: 500px;
            max-width: 700px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        #puzzleTitle {
            font-size: 28px;
            margin-bottom: 20px;
        }
        
        #puzzleQuestion {
            font-size: 20px;
            margin-bottom: 25px;
        }
        
        .puzzle-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 20px 40px;
            margin: 12px;
            border-radius: 25px;
            font-size: 24px;
            cursor: pointer;
            font-family: inherit;
            min-width: 100px;
            min-height: 80px;
        }
        
        .puzzle-button:hover {
            background: #45a049;
        }
        
        
        #celebrationScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #87CEEB;
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #celebrationContent {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #celebrationSprite {
            margin-bottom: 30px;
        }
        
        #playAgainBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            font-family: inherit;
            font-weight: bold;
        }
        
        #playAgainBtn:hover {
            background: #45a049;
        }
        
        #difficultyScreen {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #difficultyContent {
            text-align: center;
            background: white;
            padding: 50px;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        #difficultyTitle {
            font-size: 36px;
            color: #2E8B57;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .difficulty-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 25px 40px;
            margin: 15px;
            border-radius: 25px;
            font-size: 24px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            min-width: 250px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .difficulty-button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        
        .difficulty-button.easy {
            background: #4CAF50;
        }
        
        .difficulty-button.medium {
            background: #FF9800;
        }
        
        .difficulty-button.hard {
            background: #F44336;
        }
        
        #debugScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 4000;
            overflow-y: auto;
            color: white;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        
        #debugContent {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        #debugTitle {
            font-size: 32px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .debug-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #FFD700;
        }
        
        .debug-section h3 {
            color: #FFD700;
            margin-top: 0;
            font-size: 24px;
        }
        
        .celebration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .celebration-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid #666;
        }
        
        .celebration-item h4 {
            color: #FFD700;
            margin-top: 0;
        }
        
        .celebration-preview {
            width: 200px;
            height: 200px;
            border: 2px solid #FFD700;
            margin: 10px auto;
            background: #333;
        }
        
        .debug-button {
            background: #FFD700;
            color: black;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .debug-button:hover {
            background: #FFA500;
        }
        
        #debugCloseBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #F44336;
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            z-index: 4001;
        }
        
        #debugCloseBtn:hover {
            background: #D32F2F;
        }
        
        
        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #gameOverContent {
            text-align: center;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        #gameOverContent h1 {
            font-size: 48px;
            margin: 0;
        }
        
        #gameOverSprite {
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        #gameOverBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 25px 50px;
            font-size: 28px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            min-width: 250px;
        }
        
        #gameOverBtn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        
    </style>
</head>
<body>
    
    <div id="gameContainer">
        <div id="gameInfo">
            <div id="score">‚ô•Ô∏è‚ô•Ô∏è‚ô•Ô∏è‚ô•Ô∏è‚ô•Ô∏è</div>
            <div id="level">Level: 1</div>
        </div>
        
        <canvas id="gameCanvas" width="880" height="880"></canvas>
    </div>
    
    <div id="puzzleModal">
        <div id="puzzleContent">
            <h2 id="puzzleTitle">Puzzle Time!</h2>
            <p id="puzzleQuestion"></p>
            <div id="puzzleOptions"></div>
            <div id="puzzleResult"></div>
        </div>
    </div>
    
    <div id="celebrationScreen">
        <div id="celebrationContent">
            <canvas id="celebrationSprite" width="800" height="900"></canvas>
            <button id="playAgainBtn" onclick="playAgain()">Play Again</button>
        </div>
    </div>
    
    
    <div id="difficultyScreen">
        <div id="difficultyContent">
            <div id="difficultyTitle">Choose Your Difficulty</div>
            <button class="difficulty-button easy" onclick="selectDifficulty('easy')">Easy Peasy ü´õ</button>
            <button class="difficulty-button medium" onclick="selectDifficulty('medium')">Neutral üòê</button>
            <button class="difficulty-button hard" onclick="selectDifficulty('hard')">Hard Mode üôÄ</button>
        </div>
    </div>
    
    <div id="debugScreen">
        <button id="debugCloseBtn" onclick="closeDebugMode()">‚úï Close Debug</button>
        <div id="debugContent">
            <div id="debugTitle">üêõ DEBUG MODE üêõ</div>
            
            <div class="debug-section">
                <h3>üéâ Celebration Animations</h3>
                <p>View all celebration sprites from each level:</p>
                <button class="debug-button" onclick="loadDebugCelebrationSprites()" style="margin-bottom: 15px;">üîÑ Reload All Sprites</button>
                <div class="celebration-grid">
                    <div class="celebration-item">
                        <h4>Level 1 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration1" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(1)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(1)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 2 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration2" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(2)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(2)">Stop</button>
                    </div>
                    <div class="celebration-item">
                        <h4>Level 3 - PT Celebration</h4>
                        <canvas class="celebration-preview" id="debugCelebration3" width="200" height="200"></canvas>
                        <br>
                        <button class="debug-button" onclick="debugPlayCelebration(3)">Play Animation</button>
                        <button class="debug-button" onclick="debugStopCelebration(3)">Stop</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <div id="gameOverContent">
            <h1>GAME OVER</h1>
            <canvas id="gameOverSprite" width="436" height="436"></canvas>
            <button id="gameOverBtn" onclick="restartGame()">Try Again</button>
        </div>
    </div>
    
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // CSV Parser for dynamic maze loading
        async function loadMazeFromCSV() {
            try {
                const csvPath = `level-${game.selectedDifficulty}/grid.csv`;
                console.log(`Attempting to load ${csvPath}...`);
                console.log('Selected difficulty:', game.selectedDifficulty);
                const response = await fetch(csvPath + '?v=' + Date.now());
                console.log('Fetch response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                console.log('CSV loaded successfully, length:', csvText.length);
                console.log('First few lines:', csvText.split('\n').slice(0, 3).join('\n'));
                console.log('Looking for r1/r2 doors in CSV:', csvText.includes('r1'), csvText.includes('r2'));
                return parseMazeFromCSV(csvText);
            } catch (error) {
                console.error('Error loading CSV for level', game.selectedDifficulty, ':', error);
                console.log('Falling back to embedded CSV data');
                // Fallback to embedded CSV data if file load fails
                const fallbackCSV = `,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T
1,o,o,o,o,o,o,o,o,o,o,o,o,o,m,o,o,o,o,o,o
2,,o,,,,,,,,,,,,,,,o,,,o
3,,r,o,o,o,,o,,o,o,o,o,o,o,o,,o,,,
4,,,,,o,,o,,o,,,,,,o,,o,o,o,m
5,o,o,o,o,o,,o,o,r,,o,o,o,o,o,,,,,o
6,m,,,,,,,,o,,o,,,,,,,,,o
7,o,o,o,o,o,o,m,,o,,o,,o,o,o,o,o,o,o,o
8,,,,,,,o,,o,,m,,,,,,,,,o
9,,o,o,m,o,,o,,o,,o,o,o,o,o,o,o,o,o,o
10,,o,,,o,,o,,o,,,,,,,,,,,r
11,,o,,o,o,o,o,o,r,o,o,m,o,o,o,o,o,o,,o
12,,o,,,,,o,,o,,,,,,,,,o,,o
13,,o,o,o,o,o,o,,o,,,o,o,o,o,o,,o,,o
14,,,,,,,,,o,o,o,r,,,,m,,o,o,o
15,o,o,o,o,o,o,o, ,o,,,o,,m,,o,,,,
16,r,,,,,,,,o,o,o,o,,o,,o,o,o,o,o
17,o,,o,o,o,o,o,o,o,,,,,o,,,,,,o
18,o,,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o
19,m,,,,,,,,,,,,,,,,,,,o
20,o,o,o,o,o,o,o,o,o,r,o,o,o,o,o,m,o,o,o,w`;
                return parseMazeFromCSV(fallbackCSV);
            }
        }
        
        function parseMazeFromCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const doors = [];
            const paths = [];
            let watering_hole = null;
            
            // Skip header row (line 0)
            for (let rowIndex = 1; rowIndex < lines.length; rowIndex++) {
                const cells = lines[rowIndex].split(',');
                
                // Skip first column (row number), start from column 1
                for (let colIndex = 1; colIndex < cells.length; colIndex++) {
                    const cellValue = cells[colIndex].trim();
                    
                    // Calculate actual coordinates (0-based for arrays)
                    const x = (colIndex - 1) * 40; // Column A=0, B=1, etc. * 40
                    const y = (rowIndex - 1) * 40; // Row 1=0, Row 2=1, etc. * 40
                    
                    switch (cellValue) {
                        case 'o':
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'm':
                            doors.push({ x, y, type: 'math', open: false, color: '#FF6B6B' });
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'r':
                            doors.push({ x, y, type: 'reading', open: false, color: '#4ECDC4' });
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'r1':
                            doors.push({ x, y, type: 'reading1', open: false, color: '#9C27B0' }); // Purple
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'r2':
                            doors.push({ x, y, type: 'reading2', open: false, color: '#FF9800' }); // Orange
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 's':
                            doors.push({ x, y, type: 'sorting', open: false, color: '#FFD93D' });
                            // Add path under door for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'w':
                            watering_hole = { x, y };
                            // Add path under watering hole for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        // Empty cells and walls are ignored
                    }
                }
            }
            
            return { doors, paths, watering_hole };
        }
        
        // Word list parser for dynamic loading
        async function loadWordListFromFile() {
            try {
                const wordListPath = `level-${game.selectedDifficulty}/Word-List.txt`;
                console.log(`Attempting to load ${wordListPath}...`);
                const response = await fetch(wordListPath + '?v=' + Date.now());
                const wordListText = await response.text();
                return parseWordList(wordListText);
            } catch (error) {
                console.error(`Error loading Word-List.txt from level-${game.selectedDifficulty}:`, error);
                // Fallback to embedded word list if file load fails
                const fallbackWordList = `BAG üíº,
MAP üó∫Ô∏è,
HAT üß¢,
LEG ü¶µ,
GEM üíé,
DOT ‚ö™Ô∏è,
TEN üîü,
BOX üì¶,
FOX ü¶ä,
CAR üöó,
CAT üêà,
DOG üêï,
LOG ü™µ,
SUN ‚òÄÔ∏è,
CUP ‚òïÔ∏è,
FLY ü™∞,
BED üõèÔ∏è,
RAT üêÄ,
BAT ü¶á,
PEN üñäÔ∏è,
PIG üêñ`;
                return parseWordList(fallbackWordList);
            }
        }
        
        // Distractor list parser
        async function loadDistractorsFromFile() {
            try {
                const response = await fetch('distractors.txt' + '?v=' + Date.now());
                const distractorText = await response.text();
                return parseDistractors(distractorText);
            } catch (error) {
                console.error('Error loading distractors.txt:', error);
                return {};
            }
        }
        
        function parseDistractors(distractorText) {
            const lines = distractorText.trim().split('\n');
            const distractors = {};
            
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine.includes(':')) {
                    const [letter, emojis] = trimmedLine.split(':');
                    const letterKey = letter.trim().toUpperCase();
                    const emojiList = emojis.trim().split(/\s+/).filter(emoji => emoji.length > 0);
                    distractors[letterKey] = emojiList;
                }
            });
            
            return distractors;
        }
        
        function parseWordList(wordListText) {
            const lines = wordListText.trim().split('\n');
            const wordEmojiPairs = [];
            
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine && trimmedLine.endsWith(',')) {
                    // Remove trailing comma and split by space
                    const parts = trimmedLine.slice(0, -1).split(' ');
                    if (parts.length >= 2) {
                        const word = parts[0];
                        const emoji = parts.slice(1).join(' '); // Join in case emoji has spaces
                        wordEmojiPairs.push({ word, emoji });
                    }
                }
            });
            
            return wordEmojiPairs;
        }
        
        // Load sprite sheets for PT
        const ptSprites = {
            movement: new Image(),
            celebration: {}
        };
        
        // Load PT sprites
        ptSprites.movement.src = 'PT-sprite.svg';
        // Celebration sprites will be loaded dynamically based on difficulty
        
        // Function to load celebration sprite based on difficulty
        function loadCelebrationSprite(difficulty) {
            const celebrationSprite = new Image();
            const cacheBuster = '?v=' + Date.now();
            
            if (difficulty === 1) {
                celebrationSprite.src = 'level-1/celebrate.png' + cacheBuster;
            } else if (difficulty === 2) {
                celebrationSprite.src = 'level-2/celebrate.png' + cacheBuster;
            } else if (difficulty === 3) {
                celebrationSprite.src = 'level-3/celebrate.png' + cacheBuster;
            }
            
            return celebrationSprite;
        }
        
        // Current sprites
        let currentMovementSprites = ptSprites.movement;
        let currentCelebrationSprites = ptSprites.celebration;
        
        // Texture system for maze elements
        const textures = {
            wall: new Image(),
            open: new Image(),
            math: new Image(),
            reading: new Image(),
            endpoint: new Image(),
            reading1: new Image(), // Will fallback to reading texture
            reading2: new Image(), // Will fallback to reading texture
            sorting: new Image(),  // Will fallback to math texture
            loaded: false
        };
        
        // Game over sprite
        const gameOverSprite = new Image();
        gameOverSprite.src = 'game-over.png' + '?v=' + Date.now();
        gameOverSprite.onload = () => {
            console.log('Game over sprite loaded successfully');
        };
        gameOverSprite.onerror = () => {
            console.error('Failed to load game over sprite');
        };
        
        // Function to load textures for current level
        function loadTextures(level) {
            const basePath = `level-${level}/`;
            const cacheBuster = '?v=' + Date.now();
            
            textures.wall.src = basePath + 'wall.png' + cacheBuster;
            textures.open.src = basePath + 'open.png' + cacheBuster;
            textures.math.src = basePath + 'math.png' + cacheBuster;
            textures.reading.src = basePath + 'reading.png' + cacheBuster;
            textures.endpoint.src = basePath + 'endpoint.png' + cacheBuster;
            
            // For door types without specific textures, use existing ones
            textures.reading1 = textures.reading; // Use reading texture for letter matching
            textures.reading2 = textures.reading; // Use reading texture for emoji-to-word
            textures.sorting = textures.math;     // Use math texture for sorting
            
            // Track when all main textures are loaded
            let loadedCount = 0;
            const requiredTextures = ['wall', 'open', 'math', 'reading', 'endpoint'];
            
            requiredTextures.forEach(textureType => {
                textures[textureType].onload = () => {
                    loadedCount++;
                    if (loadedCount === requiredTextures.length) {
                        textures.loaded = true;
                        console.log(`Textures loaded for level ${level}`);
                    }
                };
                
                textures[textureType].onerror = () => {
                    console.warn(`Failed to load ${textureType} texture for level ${level}, using fallback`);
                    loadedCount++;
                    if (loadedCount === requiredTextures.length) {
                        textures.loaded = true;
                    }
                };
            });
        }
        
        // Improve canvas rendering quality
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        // Game object - will be populated with dynamic maze data
        const game = {
            score: 3,
            currentLevel: 1,
            selectedDifficulty: 1,
            maxUnlockedLevel: parseInt(localStorage.getItem('ptMazeMaxLevel')) || 1, // Track highest level unlocked
            gameLoopRunning: false, // Track if game loop is already running
            player: {
                x: 0,
                y: 0,
                size: 20,
                speed: 40,
                direction: 'right', // current facing direction
                animFrame: 0, // current animation frame (0 or 1)
                animTimer: 0, // timer for animation
                isMoving: false // whether player is currently moving
            },
            maze: [],
            doors: [], // Will be populated from CSV
            watering_hole: null, // Will be populated from CSV
            wordEmojiPairs: [], // Will be populated from Word-List.txt
            distractors: {}, // Will be populated from distractors.txt
            usedWords: [], // Track words used in current level to prevent repetition
            difficultyMode: 'hard', // easy, medium, hard
            debugMode: false, // Debug mode toggle
            tileSize: 40,
            puzzleActive: false,
            celebrating: false,
            celebrationFrame: 0,
            celebrationTimer: 0,
            gameOverActive: false,
            gameOverFrame: 0,
            gameOverTimer: 0,
            paths: [] // Will be populated from CSV
        };
        
        // Function to unlock next level
        function unlockNextLevel() {
            if (game.selectedDifficulty < 3) {
                game.maxUnlockedLevel = Math.max(game.maxUnlockedLevel, game.selectedDifficulty + 1);
                localStorage.setItem('ptMazeMaxLevel', game.maxUnlockedLevel.toString());
            }
        }
        
        // Debug function to reset progress (call in browser console)
        function resetProgress() {
            localStorage.removeItem('ptMazeMaxLevel');
            game.maxUnlockedLevel = 1;
            console.log('Progress reset to level 1');
        }
        
        // Difficulty selection function
        function selectDifficulty(difficulty) {
            game.difficultyMode = difficulty;
            console.log(`Selected difficulty: ${difficulty}`);
            
            // Hide difficulty selection screen
            document.getElementById('difficultyScreen').style.display = 'none';
            
            // Start the game with selected difficulty
            game.selectedDifficulty = 1;
            currentCelebrationSprites = loadCelebrationSprite(1);
            initializeGame();
        }
        
        // Debug mode variables
        const debugState = {
            celebrationSprites: {},
            animationFrames: {},
            animationTimers: {},
            isAnimating: {}
        };
        
        // Debug mode toggle function
        function toggleDebugMode() {
            game.debugMode = !game.debugMode;
            if (game.debugMode) {
                console.log('üêõ Debug mode enabled');
                document.getElementById('debugScreen').style.display = 'block';
                loadDebugCelebrationSprites();
            } else {
                console.log('üêõ Debug mode disabled');
                document.getElementById('debugScreen').style.display = 'none';
                stopAllDebugAnimations();
            }
        }
        
        // Close debug mode
        function closeDebugMode() {
            game.debugMode = false;
            document.getElementById('debugScreen').style.display = 'none';
            stopAllDebugAnimations();
        }
        
        // Load all celebration sprites for debug mode
        function loadDebugCelebrationSprites() {
            for (let level = 1; level <= 3; level++) {
                const sprite = new Image();
                const cacheBuster = '?v=' + Date.now() + '_' + Math.random();
                
                if (level === 1) {
                    sprite.src = 'level-1/celebrate.png' + cacheBuster;
                } else if (level === 2) {
                    sprite.src = 'level-2/celebrate.png' + cacheBuster;
                } else if (level === 3) {
                    sprite.src = 'level-3/celebrate.png' + cacheBuster;
                }
                
                sprite.onload = () => {
                    console.log(`Debug sprite loaded for level ${level}: ${sprite.width}x${sprite.height}`);
                };
                
                debugState.celebrationSprites[level] = sprite;
                debugState.animationFrames[level] = 0;
                debugState.animationTimers[level] = 0;
                debugState.isAnimating[level] = false;
            }
        }
        
        // Play celebration animation in debug mode
        function debugPlayCelebration(level) {
            debugState.isAnimating[level] = true;
            debugState.animationFrames[level] = 0;
            debugState.animationTimers[level] = 0;
            animateDebugCelebration(level);
        }
        
        // Stop celebration animation in debug mode
        function debugStopCelebration(level) {
            debugState.isAnimating[level] = false;
        }
        
        // Stop all debug animations
        function stopAllDebugAnimations() {
            for (let level = 1; level <= 3; level++) {
                debugState.isAnimating[level] = false;
            }
        }
        
        // Animate celebration in debug mode
        function animateDebugCelebration(level) {
            if (!debugState.isAnimating[level]) return;
            
            const canvas = document.getElementById(`debugCelebration${level}`);
            const ctx = canvas.getContext('2d');
            const sprite = debugState.celebrationSprites[level];
            
            if (sprite && sprite.complete) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Get sprite configuration based on level
                let frameWidth, frameHeight, framesPerRow, totalFrames;
                
                if (level === 1) {
                    const actualSheetWidth = sprite.width;
                    const actualSheetHeight = sprite.height;
                    framesPerRow = 9;
                    frameWidth = actualSheetWidth / framesPerRow;
                    frameHeight = actualSheetHeight;
                    totalFrames = 9;
                } else if (level === 2) {
                    // Level 2: Single row of 62 frames - auto-calculate from actual sprite
                    const actualSheetWidth = sprite.width;
                    const actualSheetHeight = sprite.height;
                    framesPerRow = 62;
                    frameWidth = actualSheetWidth / framesPerRow; // Don't use Math.floor to avoid drift
                    frameHeight = actualSheetHeight;
                    totalFrames = 62;
                    console.log(`Level 2: Single row ${actualSheetWidth}x${actualSheetHeight}, frameW=${frameWidth}, frameH=${frameHeight}`);
                } else if (level === 3) {
                    const actualSheetWidth = sprite.width;
                    const actualSheetHeight = sprite.height;
                    framesPerRow = 43;
                    frameWidth = Math.floor(actualSheetWidth / framesPerRow);
                    frameHeight = actualSheetHeight;
                    totalFrames = 43;
                }
                
                // Calculate frame position
                const row = Math.floor(debugState.animationFrames[level] / framesPerRow);
                const col = debugState.animationFrames[level] % framesPerRow;
                const frameX = col * frameWidth;
                const frameY = row * frameHeight;
                
                // Scale to fit debug canvas
                const scaleX = canvas.width / frameWidth;
                const scaleY = canvas.height / frameHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9;
                
                const scaledWidth = frameWidth * scale;
                const scaledHeight = frameHeight * scale;
                const offsetX = (canvas.width - scaledWidth) / 2;
                const offsetY = (canvas.height - scaledHeight) / 2;
                
                // Draw current frame
                ctx.drawImage(
                    sprite,
                    frameX, frameY, frameWidth, frameHeight,
                    offsetX, offsetY, scaledWidth, scaledHeight
                );
                
                // Update frame counter
                debugState.animationTimers[level]++;
                const frameDelay = level === 3 ? 40 : 25;
                if (debugState.animationTimers[level] >= frameDelay) {
                    debugState.animationFrames[level] = (debugState.animationFrames[level] + 1) % totalFrames;
                    debugState.animationTimers[level] = 0;
                }
            }
            
            if (debugState.isAnimating[level]) {
                requestAnimationFrame(() => animateDebugCelebration(level));
            }
        }
        
        // Initialize game with dynamic maze and word list data
        async function initializeGame() {
            console.log(`Initializing game for level ${game.selectedDifficulty}`);
            
            // Load textures for this level
            loadTextures(game.selectedDifficulty);
            
            // Load maze data, word list, and distractors in parallel
            const [mazeData, wordList, distractors] = await Promise.all([
                loadMazeFromCSV(),
                loadWordListFromFile(),
                loadDistractorsFromFile()
            ]);
            
            console.log(`Loaded maze data:`, mazeData);
            console.log(`Loaded word list:`, wordList);
            console.log(`Loaded distractors:`, distractors);
            
            game.doors = mazeData.doors;
            game.paths = mazeData.paths;
            game.watering_hole = mazeData.watering_hole;
            game.wordEmojiPairs = wordList;
            game.distractors = distractors;
            
            // Reset game state with new data
            resetGame();
            
            // Start the game after both are loaded (only if not already running)
            if (!game.gameLoopRunning) {
                game.gameLoopRunning = true;
                gameLoop();
            }
        }
        
        function updateScore(points) {
            game.score += points;
            
            // Update hearts display
            const heartsDisplay = '‚ô•Ô∏è'.repeat(Math.max(0, game.score));
            document.getElementById('score').textContent = heartsDisplay;
            
            if (game.score <= 0) {
                // Immediately dismiss any open puzzle dialog
                if (game.puzzleActive) {
                    document.getElementById('puzzleModal').style.display = 'none';
                    game.puzzleActive = false;
                }
                gameOver();
            }
        }
        
        function gameOver() {
            console.log('Game over triggered');
            game.gameOverActive = true;
            game.gameOverFrame = 0;
            game.gameOverTimer = 0;
            document.getElementById('gameOverScreen').style.display = 'flex';
            console.log('Starting game over animation');
            animateGameOver();
        }
        
        function animateGameOver() {
            if (!game.gameOverActive) return;
            
            const canvas = document.getElementById('gameOverSprite');
            const ctx = canvas.getContext('2d');
            
            if (!canvas) {
                console.error('Game over canvas not found');
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameOverSprite.complete) {
                // 17 frames, each 436x436 pixels
                const frameWidth = 436;
                const frameHeight = 436;
                const totalFrames = 17;
                
                // Calculate frame position (horizontal layout)
                const frameX = game.gameOverFrame * frameWidth;
                const frameY = 0;
                
                // Draw current frame
                ctx.drawImage(
                    gameOverSprite,
                    frameX, frameY, frameWidth, frameHeight, // Source frame
                    0, 0, canvas.width, canvas.height // Destination (full canvas)
                );
                
                // Update frame counter
                game.gameOverTimer++;
                if (game.gameOverTimer >= 15) { // Slower animation
                    game.gameOverFrame = (game.gameOverFrame + 1) % totalFrames;
                    game.gameOverTimer = 0;
                }
            } else {
                // Show a placeholder while sprite loads
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width/2, canvas.height/2);
                console.log('Game over sprite not loaded yet');
            }
            
            requestAnimationFrame(animateGameOver);
        }
        
        function restartGame() {
            // Stop game over animation
            game.gameOverActive = false;
            
            // Hide game over screen and show difficulty selection
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('difficultyScreen').style.display = 'flex';
        }
        
        function isOnPath(x, y) {
            return game.paths.some(path => 
                x >= path.x && x < path.x + path.width &&
                y >= path.y && y < path.y + path.height
            );
        }
        
        function isDoorBlocking(newX, newY) {
            return game.doors.some(door => 
                !door.open && 
                newX === door.x && newY === door.y
            );
        }
        
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw wall texture background across the entire canvas (including padding areas)
            if (textures.loaded && textures.wall.complete) {
                // Draw wall texture in a proper grid pattern covering entire canvas
                for (let x = 0; x < Math.ceil(canvas.width / 40); x++) {
                    for (let y = 0; y < Math.ceil(canvas.height / 40); y++) {
                        ctx.drawImage(textures.wall, x * 40, y * 40, 40, 40);
                    }
                }
            } else {
                // Fallback to solid color if texture isn't loaded
                ctx.fillStyle = '#2F4F2F';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw open paths using texture (same maze layout with thicker border)
            game.paths.forEach(path => {
                if (textures.loaded && textures.open.complete) {
                    // Direct positioning with 40px border padding
                    ctx.drawImage(textures.open, path.x + 40, path.y + 40, 40, 40);
                } else {
                    // Fallback to solid color
                    ctx.fillStyle = '#B8F2B8';
                    ctx.fillRect(path.x + 40, path.y + 40, 40, 40);
                }
            });
            
            // Draw doors using textures
            game.doors.forEach(door => {
                if (!door.open) {
                    let doorTexture = null;
                    
                    // Select appropriate texture
                    if (door.type === 'math') {
                        doorTexture = textures.math;
                    } else if (door.type === 'reading') {
                        doorTexture = textures.reading;
                    } else if (door.type === 'reading1') {
                        doorTexture = textures.reading1;
                    } else if (door.type === 'reading2') {
                        doorTexture = textures.reading2;
                    } else if (door.type === 'sorting') {
                        doorTexture = textures.sorting;
                    }
                    
                    // Draw door texture or fallback color with symbol
                    if (textures.loaded && doorTexture && doorTexture.complete) {
                        // Simple direct positioning with thicker border
                        ctx.drawImage(doorTexture, door.x + 40, door.y + 40, 40, 40);
                    } else {
                        // Fallback to original color system with symbols
                        ctx.fillStyle = door.color;
                        ctx.fillRect(door.x + 40, door.y + 40, 40, 40);
                        
                        // Only draw symbols when using fallback colors
                        ctx.fillStyle = '#000';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        let symbol = 'üîÄ'; // Default sorting symbol
                        if (door.type === 'math') symbol = 'ü™®';
                        else if (door.type === 'reading') symbol = 'üìö';
                        else if (door.type === 'reading1') symbol = 'üî§';
                        else if (door.type === 'reading2') symbol = 'üèûÔ∏è';
                        ctx.fillText(symbol, door.x + 60, door.y + 65);
                    }
                }
            });
            
            // Draw watering hole (endpoint) using texture
            if (game.watering_hole) {
                if (textures.loaded && textures.endpoint.complete) {
                    ctx.drawImage(textures.endpoint, game.watering_hole.x + 40, game.watering_hole.y + 40, 40, 40);
                } else {
                    // Fallback to original style
                    ctx.fillStyle = '#FFB6C1'; // Light pink background
                    ctx.fillRect(game.watering_hole.x + 40, game.watering_hole.y + 40, 40, 40);
                    ctx.fillStyle = '#000';
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üéÇ', game.watering_hole.x + 60, game.watering_hole.y + 68);
                }
            }
            
            // Draw PT sprite (offset by 30px)
            if (currentMovementSprites.complete) {
                // Calculate which frame to use based on direction and animation
                let frameX = 0;
                if (game.player.direction === 'right') {
                    frameX = (game.player.animFrame === 0) ? 0 : 160; // Frames 1, 2
                } else if (game.player.direction === 'left') {
                    frameX = (game.player.animFrame === 0) ? 320 : 480; // Frames 3, 4
                } else if (game.player.direction === 'up') {
                    frameX = (game.player.animFrame === 0) ? 640 : 800; // Frames 5, 6
                } else if (game.player.direction === 'down') {
                    frameX = (game.player.animFrame === 0) ? 640 : 800; // Frames 5, 6 (same as up for now)
                }
                
                // Draw the sprite frame (160x160 from SVG sprite sheet)
                // PT should be 45x45 to be bigger than the tile (overlaps slightly)
                const ptSize = 45;
                const ptOffset = -2.5; // Negative offset to center the larger sprite
                
                ctx.drawImage(
                    currentMovementSprites,
                    frameX, 0, 160, 160, // Source: x, y, width, height from sprite sheet
                    game.player.x + 40 + ptOffset, game.player.y + 40 + ptOffset, ptSize, ptSize // Centered in tile with thicker border
                );
            } else {
                // Fallback while sprite loads - bigger and centered
                const tileCenter = 20;
                ctx.fillStyle = '#D3D3D3';
                ctx.beginPath();
                ctx.arc(game.player.x + 40 + tileCenter, game.player.y + 40 + tileCenter, 22, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üêò', game.player.x + 40 + tileCenter, game.player.y + 40 + tileCenter + 10);
            }
        }
        
        // Debug mode keyboard listener (Shift + Ctrl + D)
        document.addEventListener('keydown', (e) => {
            if (e.shiftKey && e.ctrlKey && (e.key === 'D' || e.key === 'd')) {
                e.preventDefault();
                toggleDebugMode();
                return;
            }
        });
        
        // Global arrow key prevention (works even during puzzles)
        document.addEventListener('keydown', (e) => {
            // Handle both modern and legacy key codes
            const key = e.key || e.code;
            const arrowKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Up', 'Down', 'Left', 'Right'];
            if (arrowKeys.includes(key)) {
                e.preventDefault();
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // Don't allow movement if puzzle is active
            if (game.puzzleActive) return;
            
            // Snap current position to grid first
            let currentGridX = Math.round(game.player.x / game.tileSize) * game.tileSize;
            let currentGridY = Math.round(game.player.y / game.tileSize) * game.tileSize;
            
            let newX = currentGridX;
            let newY = currentGridY;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    newY -= game.tileSize;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    newY += game.tileSize;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    newX -= game.tileSize;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    newX += game.tileSize;
                    break;
                default:
                    return;
            }
            
            // Check if new position is on a valid path
            if (isOnPath(newX, newY)) {
                // Check if a door is blocking the path
                if (!isDoorBlocking(newX, newY)) {
                    // Update player position
                    game.player.x = newX;
                    game.player.y = newY;
                    
                    // Update direction and start animation
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        game.player.direction = 'left';
                    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        game.player.direction = 'right';
                    } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        game.player.direction = 'up';
                    } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                        game.player.direction = 'down';
                    }
                    
                    // Trigger walking animation
                    game.player.isMoving = true;
                    game.player.animFrame = (game.player.animFrame + 1) % 2; // Toggle between frames 0 and 1
                } else {
                    // Find which door is blocking and show puzzle
                    const blockingDoor = game.doors.find(door => 
                        !door.open && 
                        newX === door.x && newY === door.y
                    );
                    if (blockingDoor && !game.puzzleActive) {
                        showPuzzle(blockingDoor.type, blockingDoor);
                    }
                }
            }
            
            // Check for watering hole win condition
            if (game.watering_hole) {
                const distance = Math.sqrt(
                    Math.pow(game.player.x + 20 - game.watering_hole.x, 2) + 
                    Math.pow(game.player.y + 20 - game.watering_hole.y, 2)
                );
                if (distance < 40) {
                    showCelebration();
                }
            }
        });
        
        function showPuzzle(type, door) {
            const modal = document.getElementById('puzzleModal');
            const title = document.getElementById('puzzleTitle');
            const question = document.getElementById('puzzleQuestion');
            const options = document.getElementById('puzzleOptions');
            
            game.puzzleActive = true;
            modal.style.display = 'block';
            
            if (type === 'math') {
                const isAddition = Math.random() < 0.5;
                let num1, num2, answer;
                const maxAnswer = 20; // Max answer for math problems
                
                if (isAddition) {
                    // For addition, ensure sum doesn't exceed maxAnswer
                    const maxNum1 = maxAnswer - 1;
                    num1 = Math.floor(Math.random() * maxNum1) + 1; // 1 to (maxAnswer-1)
                    num2 = Math.floor(Math.random() * (maxAnswer - num1)) + 1; // 1 to (maxAnswer-num1)
                    answer = num1 + num2;
                    title.textContent = `${num1} + ${num2} = ?`;
                } else {
                    // For subtraction, ensure result is between 1-maxAnswer
                    num1 = Math.floor(Math.random() * maxAnswer) + 1;
                    num2 = Math.floor(Math.random() * Math.min(num1, maxAnswer)) + 1;
                    answer = num1 - num2;
                    title.textContent = `${num1} - ${num2} = ?`;
                }
                
                question.textContent = '';
                
                // Generate wrong answers between 1-maxAnswer
                const wrongAnswers = [];
                while (wrongAnswers.length < 2) {
                    const wrong = Math.floor(Math.random() * maxAnswer) + 1;
                    if (wrong !== answer && !wrongAnswers.includes(wrong)) {
                        wrongAnswers.push(wrong);
                    }
                }
                
                const allAnswers = [answer, ...wrongAnswers].sort(() => Math.random() - 0.5);
                
                options.innerHTML = '';
                allAnswers.forEach(ans => {
                    const button = document.createElement('button');
                    button.className = 'puzzle-button';
                    button.textContent = ans;
                    button.onclick = () => checkAnswer(ans === answer, type, door, button);
                    options.appendChild(button);
                });
            } else if (type === 'reading') {
                // Reading problems - word to emoji matching with same-first-letter strategy
                const wordEmojiPairs = game.wordEmojiPairs;
                
                // Filter out already used words in this level
                const availableWords = wordEmojiPairs.filter(pair => !game.usedWords.includes(pair.word));
                
                // If all words have been used, reset the used words list
                const wordsToUse = availableWords.length > 0 ? availableWords : wordEmojiPairs;
                if (availableWords.length === 0) {
                    game.usedWords = [];
                    console.log('All words used - resetting word tracking for this level');
                }
                
                // Pick a random word-emoji pair from available words
                const correctPair = wordsToUse[Math.floor(Math.random() * wordsToUse.length)];
                
                // Add this word to used words list
                if (!game.usedWords.includes(correctPair.word)) {
                    game.usedWords.push(correctPair.word);
                }
                
                // Check if word list is loaded
                if (!wordEmojiPairs || wordEmojiPairs.length === 0) {
                    console.error('Word list not loaded yet!');
                    return;
                }
                
                const firstLetter = correctPair.word.charAt(0).toUpperCase();
                const wrongEmojis = [];
                
                // Try to find words with same first letter
                const sameLetterWords = wordEmojiPairs.filter(pair => 
                    pair.word.charAt(0).toUpperCase() === firstLetter && 
                    pair.word !== correctPair.word
                );
                
                // Add wrong emojis from same-letter words
                while (wrongEmojis.length < 2 && sameLetterWords.length > 0) {
                    const randomIndex = Math.floor(Math.random() * sameLetterWords.length);
                    const wrongPair = sameLetterWords.splice(randomIndex, 1)[0];
                    wrongEmojis.push(wrongPair.emoji);
                }
                
                // If not enough same-letter words, use distractors
                if (wrongEmojis.length < 2 && game.distractors[firstLetter]) {
                    const distractorEmojis = [...game.distractors[firstLetter]];
                    while (wrongEmojis.length < 2 && distractorEmojis.length > 0) {
                        const randomIndex = Math.floor(Math.random() * distractorEmojis.length);
                        const distractor = distractorEmojis.splice(randomIndex, 1)[0];
                        wrongEmojis.push(distractor);
                    }
                }
                
                // Final fallback to any random emojis if still not enough
                if (wrongEmojis.length < 2) {
                    const allEmojis = wordEmojiPairs.map(pair => pair.emoji);
                    while (wrongEmojis.length < 2) {
                        const randomEmoji = allEmojis[Math.floor(Math.random() * allEmojis.length)];
                        if (randomEmoji !== correctPair.emoji && !wrongEmojis.includes(randomEmoji)) {
                            wrongEmojis.push(randomEmoji);
                        }
                    }
                }
                
                title.textContent = correctPair.word;
                question.textContent = '';
                
                const allAnswers = [correctPair.emoji, ...wrongEmojis].sort(() => Math.random() - 0.5);
                
                options.innerHTML = '';
                allAnswers.forEach(emoji => {
                    const button = document.createElement('button');
                    button.className = 'puzzle-button';
                    button.textContent = emoji;
                    button.style.fontSize = '40px'; // Make emojis bigger
                    button.style.background = 'white'; // White background for emoji buttons
                    button.style.color = 'black'; // Black text for better contrast
                    button.style.border = '3px solid #4CAF50'; // Green border
                    button.onclick = () => checkAnswer(emoji === correctPair.emoji, type, door, button);
                    options.appendChild(button);
                });
            } else if (type === 'reading1') {
                // Math problems (same as main math problems)
                const isAddition = Math.random() < 0.5;
                let num1, num2, answer;
                const maxAnswer = 20; // Max answer for math problems
                
                if (isAddition) {
                    // For addition, ensure sum doesn't exceed maxAnswer
                    const maxNum1 = maxAnswer - 1;
                    num1 = Math.floor(Math.random() * maxNum1) + 1; // 1 to (maxAnswer-1)
                    num2 = Math.floor(Math.random() * (maxAnswer - num1)) + 1; // 1 to (maxAnswer-num1)
                    answer = num1 + num2;
                    title.textContent = `${num1} + ${num2} = ?`;
                } else {
                    // For subtraction, ensure result is between 1-maxAnswer
                    num1 = Math.floor(Math.random() * maxAnswer) + 1;
                    num2 = Math.floor(Math.random() * Math.min(num1, maxAnswer)) + 1;
                    answer = num1 - num2;
                    title.textContent = `${num1} - ${num2} = ?`;
                }
                
                question.textContent = '';
                
                // Generate wrong answers between 1-maxAnswer
                const wrongAnswers = [];
                while (wrongAnswers.length < 2) {
                    const wrong = Math.floor(Math.random() * maxAnswer) + 1;
                    if (wrong !== answer && !wrongAnswers.includes(wrong)) {
                        wrongAnswers.push(wrong);
                    }
                }
                
                const allAnswers = [answer, ...wrongAnswers].sort(() => Math.random() - 0.5);
                
                options.innerHTML = '';
                allAnswers.forEach(ans => {
                    const button = document.createElement('button');
                    button.className = 'puzzle-button';
                    button.textContent = ans;
                    button.onclick = () => checkAnswer(ans === answer, type, door, button);
                    options.appendChild(button);
                });
            } else if (type === 'reading2') {
                // Emoji to word matching with same-first-letter strategy - show emoji, choose word
                const wordEmojiPairs = game.wordEmojiPairs;
                
                // Check if word list is loaded
                if (!wordEmojiPairs || wordEmojiPairs.length === 0) {
                    console.error('Word list not loaded yet!');
                    return;
                }
                
                // Filter out already used words in this level
                const availableWords = wordEmojiPairs.filter(pair => !game.usedWords.includes(pair.word));
                
                // If all words have been used, reset the used words list
                const wordsToUse = availableWords.length > 0 ? availableWords : wordEmojiPairs;
                if (availableWords.length === 0) {
                    game.usedWords = [];
                    console.log('All words used - resetting word tracking for this level');
                }
                
                // Pick a random word-emoji pair from available words
                const correctPair = wordsToUse[Math.floor(Math.random() * wordsToUse.length)];
                
                // Add this word to used words list
                if (!game.usedWords.includes(correctPair.word)) {
                    game.usedWords.push(correctPair.word);
                }
                const firstLetter = correctPair.word.charAt(0).toUpperCase();
                const wrongWords = [];
                
                // Try to find words with same first letter
                const sameLetterWords = wordEmojiPairs.filter(pair => 
                    pair.word.charAt(0).toUpperCase() === firstLetter && 
                    pair.word !== correctPair.word
                );
                
                // Add wrong words from same-letter words
                while (wrongWords.length < 2 && sameLetterWords.length > 0) {
                    const randomIndex = Math.floor(Math.random() * sameLetterWords.length);
                    const wrongPair = sameLetterWords.splice(randomIndex, 1)[0];
                    wrongWords.push(wrongPair.word);
                }
                
                // If not enough same-letter words, use distractors (words that start with same letter)
                if (wrongWords.length < 2 && game.distractors[firstLetter]) {
                    // Convert distractors to fake words that start with the same letter
                    const commonWords = {
                        'A': ['APPLE', 'ARROW', 'ANGEL'],
                        'B': ['BREAD', 'BRUSH', 'BRAIN'],
                        'C': ['CLOUD', 'CHAIR', 'CROWN'],
                        'D': ['DUCK', 'DRUM', 'DOOR'],
                        'F': ['FISH', 'FIRE', 'FARM'],
                        'G': ['GRASS', 'GIFT', 'GUARD'],
                        'H': ['HOUSE', 'HEART', 'HORSE'],
                        'L': ['LAMP', 'LEAF', 'LOCK'],
                        'M': ['MILK', 'MASK', 'MAGIC'],
                        'P': ['PLANT', 'PIZZA', 'PLANE'],
                        'R': ['ROBOT', 'RING', 'ROCK'],
                        'S': ['STAR', 'SNAKE', 'SMILE'],
                        'T': ['TREE', 'TRUCK', 'TIGER']
                    };
                    
                    if (commonWords[firstLetter]) {
                        const availableWords = commonWords[firstLetter].filter(word => 
                            word !== correctPair.word.toUpperCase() && 
                            !wrongWords.includes(word)
                        );
                        
                        while (wrongWords.length < 2 && availableWords.length > 0) {
                            const randomIndex = Math.floor(Math.random() * availableWords.length);
                            const word = availableWords.splice(randomIndex, 1)[0];
                            wrongWords.push(word);
                        }
                    }
                }
                
                // Final fallback to any random words if still not enough
                if (wrongWords.length < 2) {
                    while (wrongWords.length < 2) {
                        const randomPair = wordEmojiPairs[Math.floor(Math.random() * wordEmojiPairs.length)];
                        if (randomPair.word !== correctPair.word && !wrongWords.includes(randomPair.word)) {
                            wrongWords.push(randomPair.word);
                        }
                    }
                }
                
                title.textContent = ''; // No title for reading2 type
                question.innerHTML = `<div style=\"font-size: 48px; margin: 20px 0;\">${correctPair.emoji}</div>`;
                
                const allAnswers = [correctPair.word, ...wrongWords].sort(() => Math.random() - 0.5);
                
                options.innerHTML = '';
                allAnswers.forEach(word => {
                    const button = document.createElement('button');
                    button.className = 'puzzle-button';
                    button.textContent = word;
                    button.style.fontSize = '24px';
                    button.onclick = () => checkAnswer(word === correctPair.word, type, door, button);
                    options.appendChild(button);
                });
            }
        }
        
        function checkAnswer(correct, type, door, buttonElement) {
            const result = document.getElementById('puzzleResult');
            
            // Track attempts for this problem
            if (!door.currentProblemAttempts) door.currentProblemAttempts = 0;
            door.currentProblemAttempts++;
            
            if (correct) {
                result.innerHTML = 'üëç';
                result.style.color = 'green';
                result.style.fontSize = '48px'; // Make thumbs up bigger
                door.open = true;
                
                // Give +1 point for correct answer (net effect: 1 - number_of_wrong_attempts)
                if (type === 'math') updateScore(1);
                if (type === 'reading') updateScore(1);
                if (type === 'reading1') updateScore(1);
                if (type === 'reading2') updateScore(1);
                if (type === 'sorting') updateScore(1);
                
                // Reset attempt counters
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
                
                // Change door color to match open path
                door.color = '#B8F2B8';
                
                setTimeout(() => {
                    document.getElementById('puzzleModal').style.display = 'none';
                    result.innerHTML = '';
                    result.style.fontSize = ''; // Reset font size
                    game.puzzleActive = false;
                }, 800); // Faster disappear (800ms instead of 1500ms)
            } else {
                result.innerHTML = 'üëé';
                result.style.color = 'red';
                
                // Deduct points based on difficulty mode
                let pointsToDeduct = 0;
                
                if (game.difficultyMode === 'easy') {
                    pointsToDeduct = -1; // Always lose 1 point in easy mode
                } else if (game.difficultyMode === 'medium') {
                    // In medium mode: first wrong answer = -1, second wrong answer = -2
                    pointsToDeduct = door.currentProblemAttempts === 1 ? -1 : -2;
                } else {
                    pointsToDeduct = -2; // Hard mode: always lose 2 points
                }
                
                if (type === 'math') updateScore(pointsToDeduct);
                if (type === 'reading') updateScore(pointsToDeduct);
                if (type === 'reading1') updateScore(pointsToDeduct);
                if (type === 'reading2') updateScore(pointsToDeduct);
                if (type === 'sorting') updateScore(pointsToDeduct);
                
                // Disable the wrong answer button
                buttonElement.disabled = true;
                buttonElement.style.backgroundColor = '#ccc';
                buttonElement.style.cursor = 'not-allowed';
                
                // Track failed attempts
                if (!door.failedAttempts) door.failedAttempts = 0;
                door.failedAttempts++;
                
                // If 3 failures, generate new problem
                if (door.failedAttempts >= 3) {
                    setTimeout(() => {
                        door.failedAttempts = 0;
                        door.currentProblemAttempts = 0; // Reset for new problem
                        showPuzzle(type, door); // Generate new problem
                    }, 1500);
                } else {
                    // Clear result after showing thumbs down
                    setTimeout(() => {
                        result.innerHTML = '';
                    }, 1500);
                }
            }
        }
        
        function showCelebration() {
            // Unlock next level
            unlockNextLevel();
            
            game.celebrating = true;
            game.celebrationFrame = 0;
            game.celebrationTimer = 0;
            
            // Update button text based on whether there's a next level
            const playAgainBtn = document.getElementById('playAgainBtn');
            if (game.selectedDifficulty < 3) {
                playAgainBtn.textContent = 'Next Level';
            } else {
                playAgainBtn.textContent = 'Play Again';
            }
            
            document.getElementById('celebrationScreen').style.display = 'flex';
            animateCelebration();
        }
        
        function animateCelebration() {
            if (!game.celebrating) return;
            
            const canvas = document.getElementById('celebrationSprite');
            const ctx = canvas.getContext('2d');
            
            if (currentCelebrationSprites.complete) {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Determine sprite format based on character and difficulty
                let frameWidth, frameHeight, framesPerRow, totalFrames;
                
                if (game.selectedDifficulty === 2) {
                    // Level 2: Single row of 62 frames - auto-calculate from actual sprite
                    const actualSheetWidth = currentCelebrationSprites.width;
                    const actualSheetHeight = currentCelebrationSprites.height;
                    framesPerRow = 62;
                    frameWidth = actualSheetWidth / framesPerRow; // Don't use Math.floor to avoid drift
                    frameHeight = actualSheetHeight;
                    totalFrames = 62;
                } else if (game.selectedDifficulty === 3) {
                    // Level 3 sprites: 43 frames horizontal, calculate from actual sprite dimensions
                    const actualSheetWidth = currentCelebrationSprites.width; // 32768
                    const actualSheetHeight = currentCelebrationSprites.height; // 894
                    framesPerRow = 43;
                    
                    frameWidth = Math.floor(actualSheetWidth / framesPerRow); // 32768 / 43 = 762
                    frameHeight = actualSheetHeight; // 894
                    totalFrames = 43;
                } else {
                    // Level 1 sprites: New format (9 frames horizontal)
                    const actualSheetWidth = currentCelebrationSprites.width;
                    const actualSheetHeight = currentCelebrationSprites.height;
                    framesPerRow = 9;
                    
                    frameWidth = actualSheetWidth / framesPerRow;
                    frameHeight = actualSheetHeight;
                    totalFrames = 9;
                }
                
                // Calculate frame position
                const row = Math.floor(game.celebrationFrame / framesPerRow);
                const col = game.celebrationFrame % framesPerRow;
                const frameX = col * frameWidth;
                const frameY = row * frameHeight;
                
                // Scale to fit canvas while maintaining aspect ratio
                const scaleX = canvas.width / frameWidth;
                const scaleY = canvas.height / frameHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9; // 90% of canvas size for padding
                
                const scaledWidth = frameWidth * scale;
                const scaledHeight = frameHeight * scale;
                const offsetX = (canvas.width - scaledWidth) / 2;
                const offsetY = (canvas.height - scaledHeight) / 2;
                
                // Draw current frame (scaled to fit)
                ctx.drawImage(
                    currentCelebrationSprites,
                    frameX, frameY, frameWidth, frameHeight, // Source frame
                    offsetX, offsetY, scaledWidth, scaledHeight // Destination (scaled and centered)
                );
                
                // Update frame counter (slower for Level 3)
                game.celebrationTimer++;
                const frameDelay = game.selectedDifficulty === 3 ? 40 : 25; // Slower for Level 3
                if (game.celebrationTimer >= frameDelay) {
                    game.celebrationFrame = (game.celebrationFrame + 1) % totalFrames;
                    game.celebrationTimer = 0;
                }
            }
            
            requestAnimationFrame(animateCelebration);
        }
        
        
        
        function resetGame() {
            game.player.x = 0;
            game.player.y = 0;
            game.player.direction = 'right';
            
            // Set starting hearts based on difficulty mode
            if (game.difficultyMode === 'easy' || game.difficultyMode === 'medium') {
                game.score = 5;
            } else {
                game.score = 3; // hard mode
            }
            
            updateScore(0); // This will set the hearts display
            
            // Display level and difficulty mode
            const difficultyEmoji = {
                'easy': 'ü´õ',
                'medium': 'üòê', 
                'hard': 'üôÄ'
            };
            document.getElementById('level').textContent = `Level: ${game.selectedDifficulty} (${difficultyEmoji[game.difficultyMode]})`;
            
            // Reset used words for this level to prevent repetition
            game.usedWords = [];
            
            // Reset all doors
            game.doors.forEach(door => {
                door.open = false;
                door.color = door.type === 'math' ? '#FF6B6B' : '#4ECDC4';
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
            });
        }
        
        function playAgain() {
            game.celebrating = false;
            document.getElementById('celebrationScreen').style.display = 'none';
            
            // If there's a next level, advance to it
            if (game.selectedDifficulty < 3) {
                game.selectedDifficulty++;
                console.log(`Advancing to level ${game.selectedDifficulty}`);
                // Load next level directly
                currentCelebrationSprites = loadCelebrationSprite(game.selectedDifficulty);
                initializeGame();
            } else {
                // Completed all levels, restart from level 1
                console.log('All levels completed, restarting from level 1');
                game.selectedDifficulty = 1;
                currentCelebrationSprites = loadCelebrationSprite(1);
                initializeGame();
            }
        }
        
        // Game loop
        function gameLoop() {
            // Update animation timer
            game.player.animTimer++;
            
            // Reset moving flag after a short time (creates a brief walking animation)
            if (game.player.isMoving && game.player.animTimer > 10) {
                game.player.isMoving = false;
                game.player.animTimer = 0;
            }
            
            if (!game.celebrating) {
                drawGame();
            }
            requestAnimationFrame(gameLoop);
        }
        
        
        // Show difficulty selection screen on game start
        // The game will start after user selects difficulty via selectDifficulty() function
    </script>
</body>
</html>