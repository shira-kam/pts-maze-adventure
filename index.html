<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze of Marvels</title>
    <link rel="stylesheet" href="styles.css?v=5">
    <style>
        
    
        
        
    </style>
</head>
<body>
    
    <div id="gameContainer">
        <div id="gameInfo">
            <div id="score">‚ô•Ô∏è‚ô•Ô∏è‚ô•Ô∏è‚ô•Ô∏è‚ô•Ô∏è</div>
            <div id="ghostStrength" style="display: none;">‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è</div>
            <div id="level">Level: 1</div>
        </div>
        
        <canvas id="gameCanvas" width="880" height="880"></canvas>
    </div>
    
    <div id="puzzleModal">
        <div id="puzzleContent">
            <h2 id="puzzleTitle">Puzzle Time!</h2>
            <p id="puzzleQuestion"></p>
            <div id="puzzleOptions"></div>
            <div id="puzzleResult"></div>
        </div>
    </div>
    
    <div id="celebrationScreen">
        <div id="celebrationContent">
            <button id="playAgainBtn" onclick="playAgain()">Play Again</button>
            <canvas id="celebrationSprite" width="800" height="900"></canvas>
        </div>
    </div>
    
    <!-- Character Caught By Ghost Modal -->
    <div id="ghostCaughtModal" style="display: none;">
        <div id="ghostCaughtContent">
            <canvas id="ghostCaughtSprite" width="400" height="400"></canvas>
            <div id="ghostCaughtButtons">
                <button id="ghostCaughtReplayBtn" onclick="replayCharacterCaughtByGhost()">‚ü≤</button>
                <button id="ghostCaughtBtn" onclick="dismissCharacterCaughtByGhost()">OK</button>
            </div>
        </div>
    </div>
    
    <!-- Ghost Defeated Modal -->
    <div id="ghostDefeatedModal" style="display: none;">
        <div id="ghostDefeatedContent">
            <canvas id="ghostDefeatedSprite" width="400" height="400"></canvas>
            <div id="ghostDefeatedButtons">
                <button id="ghostDefeatedReplayBtn" onclick="replayGhostDefeated()">‚ü≤</button>
                <button id="ghostDefeatedBtn" onclick="dismissGhostDefeated()">OK</button>
            </div>
        </div>
    </div>
    
    <div id="characterSelectionScreen">
        <div id="characterSelectionContent">
            <div id="characterSelectionTitle">Select Character</div>
            <div id="characterButtons">
                <!-- Character buttons will be generated dynamically -->
            </div>
            <div id="parentSettingsSection">
                <button id="gameSettingsButton" onclick="openGameSettings()">
                    Game Settings (for parents)
                </button>
                <div id="settingsAppliedMessage" style="display: none;">
                    ‚úÖ Custom settings applied
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" style="display: none;" onclick="closeGameSettings()">
        <div id="settingsModalContent" onclick="event.stopPropagation()">
            <iframe id="settingsIframe" src="game-settings.html" frameborder="0"></iframe>
        </div>
    </div>
    
   <div id="difficultyScreen">
  <div id="difficultyContent">
    <div id="difficultyTitle">Choose Your Difficulty</div>

    <button class="difficulty-button easy" onclick="selectDifficulty('easy')">
      <div class="circle">ü´õ</div>
      <div class="label">Easy Peasy</div>
    </button>

    <button class="difficulty-button medium" onclick="selectDifficulty('medium')">
      <div class="circle">üòê</div>
      <div class="label">Neutral</div>
    </button>

    <button class="difficulty-button hard" onclick="selectDifficulty('hard')">
      <div class="circle">üôÄ</div>
      <div class="label">Hard Mode</div>
    </button>

    <button id="backToCharacterBtn" onclick="backToCharacterSelection()">‚Üê</button>
  </div>
</div>
    
    <div id="levelSelectionScreen">
        <div id="levelSelectionContent">
            <div id="levelSelectionTitle">Choose Your Level</div>
            <div id="levelGrid">
                <!-- Level buttons will be generated dynamically -->
            </div>
            <button id="backToDifficultyBtn" onclick="backToDifficulty()">‚Üê</button>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <div id="gameOverContent">
            <h1>GAME OVER</h1>
            <canvas id="gameOverSprite" width="436" height="436"></canvas>
            <button id="seeScoreBtn" onclick="showGameOverScore()">See Score</button>
        </div>
    </div>
    
    <div id="finalScoreScreen">
        <div id="finalScoreContent">
            <div id="finalScoreTitle">üéâ Congratulations! üéâ</div>
            
            <div id="levelScoresContainer">
                <!-- Level scores will be populated here -->
            </div>
            
            
            <button id="finalScoreBtn" onclick="restartFromFinalScore()">Play Again</button>
        </div>
    </div>
    
    <!-- Debug Screen (Dynamic HTML Generation) -->
    <div id="debugScreen">
        <button id="debugCloseBtn" onclick="debugManager.closeDebugMode()">‚úï Close Debug</button>
        <div id="debugContent">
            <div id="debugTitle">üêõ DEBUG MODE üêõ</div>
            
            <div class="debug-section">
                <h3>üë§ Character Selection</h3>
                <p>Select character for level testing:</p>
                <div id="debugCharacterSelection" style="display: flex; flex-direction: column; gap: 15px; margin: 15px 0; align-items: flex-start;">
                    <!-- Character radio buttons will be generated dynamically -->
                </div>
            </div>
            
            <div class="debug-section">
                <h3>‚öôÔ∏è Difficulty Settings</h3>
                <p>Select difficulty for level testing:</p>
                <div style="display: flex; flex-direction: column; gap: 15px; margin: 15px 0; align-items: flex-start;">
                    <label style="display: flex; align-items: center; gap: 10px; color: #fff; font-size: 18px; cursor: pointer;">
                        <input type="radio" name="debugDifficulty" value="easy" checked style="transform: scale(1.5);">
                        <span style="color: #fff; font-weight: bold;">Easy Peasy ü´õ (5 ‚ù§Ô∏è)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #fff; font-size: 18px; cursor: pointer;">
                        <input type="radio" name="debugDifficulty" value="medium" style="transform: scale(1.5);">
                        <span style="color: #fff; font-weight: bold;">Neutral üòê (5 ‚ù§Ô∏è)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; color: #fff; font-size: 18px; cursor: pointer;">
                        <input type="radio" name="debugDifficulty" value="hard" style="transform: scale(1.5);">
                        <span style="color: #fff; font-weight: bold;">Hard Mode üôÄ (3 ‚ù§Ô∏è)</span>
                    </label>
                </div>
            </div>
            
            <div class="debug-section">
                <h3>üéÆ Level Selection</h3>
                <p>Jump to any level for testing:</p>
                <div id="debugLevelButtons" style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;">
                    <!-- Level buttons will be generated dynamically -->
                </div>
                <p style="margin-top: 10px; font-size: 14px; color: #ccc;">Current Level: <span id="debugCurrentLevel">1</span></p>
            </div>
            
            <div class="debug-section">
                <h3>üéâ Celebration Animations</h3>
                <p>View all celebration sprites from each level:</p>
                <button class="debug-button" onclick="reloadDebugCelebrationSprites();" style="margin-bottom: 15px;">üîÑ Reload All Sprites</button>
                <div id="debugCelebrationGrid" class="celebration-grid">
                    <!-- Celebration items will be generated dynamically -->
                </div>
            </div>
            
            <div class="debug-section">
                <h3>üìä Score Screen Testing</h3>
                <p>Test final score screens without completing all levels:</p>
                <button class="debug-button" onclick="debugManager.closeDebugMode(); showFinalScore();" style="margin-right: 10px;">üèÜ Test Final Score Screen</button>
                <button class="debug-button" onclick="debugManager.closeDebugMode(); showGameOverScore();">üíÄ Test Game Over Score</button>
                <p style="font-size: 14px; color: #ccc; margin-top: 10px;">Note: These use current session data for score display</p>
            </div>
        </div>
    </div>
    
    <!-- Configuration System -->
    <script src="config-manager.js"></script>
    <script src="simple-math-puzzle.js"></script>
    <script src="word-emoji-puzzle.js"></script>
    <script src="number-line-puzzle.js"></script>
    <script src="division-puzzle.js"></script>
    <script src="digraph-puzzle.js"></script>
    <script src="multiplication-groups-puzzle.js"></script>
    <script src="letter-identification.js"></script>
    <script src="audio-reading-puzzle.js"></script>
    <script src="debug-manager.js"></script>
    <script src="ghost.js"></script>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // CSV Parser for dynamic maze loading
        async function loadMazeFromCSV() {
            try {
                // Load maze for current level
                const mazeLevel = game.selectedDifficulty;
                const csvPath = `level-${mazeLevel}/grid.csv`;
                console.log(`Attempting to load ${csvPath}...`);
                console.log('Selected difficulty:', game.selectedDifficulty);
                const response = await fetch(csvPath + '?v=' + Date.now());
                console.log('Fetch response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                console.log('CSV loaded successfully, length:', csvText.length);
                console.log('First few lines:', csvText.split('\n').slice(0, 3).join('\n'));
                return parseMazeFromCSV(csvText);
            } catch (error) {
                console.error('Error loading CSV for level', game.selectedDifficulty, ':', error);
                console.log('Falling back to embedded CSV data');
                // Fallback to embedded CSV data if file load fails
                const fallbackCSV = `,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T
1,o,o,o,o,o,o,o,o,o,o,o,o,o,ma,o,o,o,o,o,o
2,,o,,,,,,,,,,,,,,,o,,,o
3,,we,o,o,o,,o,,o,o,o,o,o,o,o,,o,,,
4,,,,,o,,o,,o,,,,,,o,,o,o,o,ma
5,o,o,o,o,o,,o,o,we,,o,o,o,o,o,,,,,o
6,ma,,,,,,,,o,,o,,,,,,,,,o
7,o,o,o,o,o,o,ma,,o,,o,,o,o,o,o,o,o,o,o
8,,,,,,,o,,o,,ma,,,,,,,,,o
9,,o,o,ma,o,,o,,o,,o,o,o,o,o,o,o,o,o,o
10,,o,,,o,,o,,o,,,,,,,,,,,we
11,,o,,o,o,o,o,o,we,o,o,ma,o,o,o,o,o,o,,o
12,,o,,,,,o,,o,,,,,,,,,o,,o
13,,o,o,o,o,o,o,,o,,,o,o,o,o,o,,o,,o
14,,,,,,,,,o,o,o,we,,,,ma,,o,o,o
15,o,o,o,o,o,o,o, ,o,,,o,,ma,,o,,,,
16,we,,,,,,,,o,o,o,o,,o,,o,o,o,o,o
17,o,,o,o,o,o,o,o,o,,,,,o,,,,,,o
18,o,,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o
19,ma,,,,,,,,,,,,,,,,,,,o
20,o,o,o,o,o,o,o,o,o,we,o,o,o,o,o,ma,o,o,o,w`;
                return parseMazeFromCSV(fallbackCSV);
            }
        }
        
        function parseMazeFromCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const doors = [];
            const paths = [];
            const bonusItems = [];
            let watering_hole = null;
            const maze = []; // Store raw maze data for wall transitions
            
            // Skip header row (line 0)
            for (let rowIndex = 1; rowIndex < lines.length; rowIndex++) {
                const cells = lines[rowIndex].split(',');
                const mazeRow = [];
                
                // Skip first column (row number), start from column 1
                for (let colIndex = 1; colIndex < cells.length; colIndex++) {
                    const cellValue = cells[colIndex].trim();
                    mazeRow.push(cellValue); // Store cell value in maze array
                    
                    // Calculate actual coordinates (0-based for arrays)
                    const x = (colIndex - 1) * 40; // Column A=0, B=1, etc. * 40
                    const y = (rowIndex - 1) * 40; // Row 1=0, Row 2=1, etc. * 40
                    
                    switch (cellValue) {
                        case 'o':
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'ob1':
                        case 'ob2':
                        case 'ob3':
                        case 'ob4':
                        case 'ob5': {
                            // Get puzzle type from obstacle code using current level
                            const puzzleType = configManager.getPuzzleTypeFromObstacle(game.selectedDifficulty, cellValue);
                            if (puzzleType) {
                                doors.push({ 
                                    x, y, 
                                    type: puzzleType, 
                                    obstacleCode: cellValue,
                                    open: false, 
                                    color: '#FF6B6B' 
                                });
                                // Add path under door for walkability
                                paths.push({ x, y, width: 40, height: 40 });
                            } else {
                                console.warn(`No puzzle type found for obstacle ${cellValue} in level ${game.selectedDifficulty}`);
                            }
                            break;
                        }
                        case 'w':
                            watering_hole = { x, y };
                            // Add path under watering hole for walkability
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        case 'h':
                            // Heart collectible - add to paths and track as heart
                            paths.push({ x, y, width: 40, height: 40, type: 'heart', collected: false });
                            break;
                        case 'b':
                            // Bonus collectible (level 9) - add to paths and track as bonus
                            bonusItems.push({ x, y, width: 40, height: 40, collected: false });
                            paths.push({ x, y, width: 40, height: 40 });
                            break;
                        // Empty cells and walls are ignored
                    }
                }
                maze.push(mazeRow); // Add completed row to maze
            }
            
            return { doors, paths, watering_hole, bonusItems, maze };
        }
        
        // Load sprite sheets for PT
        const characterSprites = {
            movement: new Image(),
            celebration: {},
            bonus: new Image(),
            gameOver: new Image()
        };
        
        // Load character sprites based on selected character
        async function loadCharacterSprites() {
            const selectedCharacter = game.selectedCharacter || 'PT';
            
            // Load config if not already loaded
            if (!configManager.isConfigLoaded()) {
                await configManager.loadConfig();
                // Check for and apply custom config if available
                configManager.checkAndApplyCustomConfig();
            }
            
            const characterConfig = configManager.getCharacterConfig(selectedCharacter);
            
            console.log(`Loading sprites for character: ${selectedCharacter}`);
            console.log(`Character config:`, characterConfig);
            
            // Load movement sprite
            characterSprites.movement.src = characterConfig.movement;
            console.log(`Loading movement sprite: ${characterConfig.movement}`);
            
            // Load game over sprite
            characterSprites.gameOver.src = characterConfig.gameOver;
            console.log(`Loading game over sprite: ${characterConfig.gameOver}`);
            
            // Load bonus sprite for the current level
            loadCharacterBonusSprite(game.selectedDifficulty);
        }
        
        // Function to load bonus character sprites based on level
        function loadCharacterBonusSprite(level) {
            const selectedCharacter = game.selectedCharacter || 'PT';
            const characterConfig = configManager.getCharacterConfig(selectedCharacter);
            const cacheBuster = '?v=' + Date.now();

            console.log(`Loading bonus sprite for ${selectedCharacter} at level ${level}`);
            console.log(`Character bonus config:`, characterConfig.bonus);

            // Load bonus sprite based on JSON config level assets
            if (configManager.hasFeature(level, 'rocket_boost')) {
                const bonusPath = characterConfig.bonus[level.toString()] + cacheBuster;
                characterSprites.bonus.src = bonusPath;
                console.log(`Loading bonus sprite: ${bonusPath}`);
            } else {
                // Find the first level that has bonus feature as fallback
                const availableLevels = configManager.getAvailableLevels();
                const fallbackLevel = availableLevels.find(l => configManager.hasFeature(l, 'rocket_boost')) || 9;
                const bonusPath = characterConfig.bonus[fallbackLevel.toString()] + cacheBuster;
                characterSprites.bonus.src = bonusPath;
                console.log(`Loading fallback bonus sprite: ${bonusPath}`);
            }
        }
        
        // Celebration sprites will be loaded dynamically based on difficulty
        
        // Digraph data for Level 3
        let digraphEmojis = {};
        let digraphSounds = {};
        let emojiNames = {};
        
        // Load emoji names for word pronunciation
        async function loadEmojiNames() {
            try {
                const response = await fetch('emoji-names.txt' + '?v=' + Date.now());
                const emojiText = await response.text();
                
                const lines = emojiText.trim().split('\n');
                lines.forEach(line => {
                    const parts = line.trim().split(',');
                    if (parts.length >= 2) {
                        const emoji = parts[0];
                        const name = parts[1];
                        emojiNames[emoji] = name;
                    }
                });
                
                console.log('Loaded emoji names:', emojiNames);
                return emojiNames;
            } catch (error) {
                console.error('Error loading emoji names:', error);
                return {};
            }
        }
        
        // Load digraph data files for Level 3
        async function loadDigraphData() {
            try {
                const [emojiResponse, soundResponse, namesResponse] = await Promise.all([
                    fetch('digraph-emojis.txt' + '?v=' + Date.now()),
                    fetch('digraph-sounds.txt' + '?v=' + Date.now()),
                    loadEmojiNames()
                ]);
                
                const emojiText = await emojiResponse.text();
                const soundText = await soundResponse.text();
                
                // Parse digraph-emojis.txt
                const emojiLines = emojiText.trim().split('\n');
                emojiLines.forEach(line => {
                    const parts = line.trim().split(',');
                    if (parts.length >= 4) {
                        const digraph = parts[0];
                        const emojis = parts.slice(1);
                        digraphEmojis[digraph] = emojis;
                    }
                });
                
                // Parse digraph-sounds.txt
                const soundLines = soundText.trim().split('\n');
                soundLines.forEach(line => {
                    const parts = line.trim().split(',');
                    if (parts.length >= 2) {
                        const digraph = parts[0];
                        const sound = parts[1];
                        digraphSounds[digraph] = sound;
                    }
                });
                
                // Store emoji names
                emojiNames = namesResponse;
                
                console.log('Loaded digraph data:', { digraphEmojis, digraphSounds, emojiNames });
                return { digraphEmojis, digraphSounds, emojiNames };
            } catch (error) {
                console.error('Error loading digraph data:', error);
                return { digraphEmojis: {}, digraphSounds: {}, emojiNames: {} };
            }
        }
        
        // Game configuration is now handled by ConfigManager class
        
        // Function to get celebration frame configuration for a level from JSON config
        function getCelebrationConfig(level) {
            if (configManager.isConfigLoaded()) {
                const celebrationConfig = configManager.getCelebrationSpriteConfig(level);
                return {
                    frames: celebrationConfig.frames,
                    layout: 'horizontal' // All celebrations are horizontal
                };
            }
            
            // Fallback if config not loaded or missing
            return {
                frames: 20, // Default fallback
                layout: 'horizontal'
            };
        }
        
        // Function to calculate frame dimensions and properties
        function calculateFrameProperties(sprite, level) {
            const config = getCelebrationConfig(level);
            const actualSheetWidth = sprite.width;
            const actualSheetHeight = sprite.height;
            
            let frameWidth, frameHeight, framesPerRow, totalFrames;
            
            if (config.layout === 'horizontal') {
                framesPerRow = config.frames;
                frameWidth = actualSheetWidth / framesPerRow;
                frameHeight = actualSheetHeight;
                totalFrames = config.frames;
            } else {
                // Future support for other layouts like grid if needed
                throw new Error(`Unsupported layout: ${config.layout}`);
            }
            
            return {
                frameWidth,
                frameHeight,
                framesPerRow,
                totalFrames
            };
        }
        
        // Function to load celebration sprite based on difficulty
        function loadCelebrationSprite(difficulty) {
            const celebrationSprite = new Image();
            const cacheBuster = '?v=' + Date.now();
            
            const availableLevels = configManager.getAvailableLevels();
            if (availableLevels.includes(difficulty)) {
                const characterName = game.selectedCharacter || 'PT';
                const celebrationPath = configManager.getCharacterAssetPath(characterName, 'celebration', difficulty);
                celebrationSprite.src = celebrationPath + cacheBuster;
            } else {
                console.error(`Invalid difficulty level: ${difficulty}`);
                const fallbackLevel = availableLevels[0] || 1; // Use first available level or 1 as fallback
                const characterName = game.selectedCharacter || 'PT';
                const celebrationPath = configManager.getCharacterAssetPath(characterName, 'celebration', fallbackLevel);
                celebrationSprite.src = celebrationPath + cacheBuster;
            }
            
            return celebrationSprite;
        }
        
        // Current sprites
        let currentMovementSprites = characterSprites.movement;
        let currentCelebrationSprites = characterSprites.celebration;
        
        // Texture system for maze elements - now supports dynamic door types
        const textures = {
            wall: new Image(),
            open: new Image(),
            endpoint: new Image(),
            heart: new Image(),    // Heart collectible texture
            bonus: new Image(),    // Bonus collectible texture
            // Door-type-specific textures (loaded dynamically)
            ma: new Image(),       // Simple arithmetic puzzle
            we: new Image(),       // Word emoji matching puzzle
            nl: new Image(),       // Number line puzzle
            ds: new Image(),       // Digraph sounds puzzle
            dv: new Image(),       // Division visual puzzle
            mg: new Image(),       // Multiplication groups puzzle
            sorting: new Image(),  // Will fallback to color if no texture
            loaded: false
        };
        
        // Game over sprite will be loaded dynamically based on selected character
        const gameOverSprite = characterSprites.gameOver;
        
        // Function to load textures for current level
        function loadTextures(level) {
            const basePath = `level-${level}/`;
            const cacheBuster = '?v=' + Date.now();
            
            // Reset loaded flag
            textures.loaded = false;
            console.log(`Loading textures for level ${level}...`);
            
            // Get required textures from configuration
            const requiredTextures = configManager.getRequiredTextures(level);
            console.log(`Level ${level} required textures:`, requiredTextures);
            
            // Load all required textures dynamically
            requiredTextures.forEach(textureType => {
                // Create texture object if it doesn't exist
                if (!textures[textureType]) {
                    textures[textureType] = new Image();
                }
                const texturePath = basePath + textureType + '.png' + cacheBuster;
                console.log(`Loading texture: ${textureType} from ${texturePath}`);
                textures[textureType].src = texturePath;
            });
            
            // Load bonus assets if level has them
            if (configManager.hasBonusFeatures(level)) {
                if (!textures.heart) textures.heart = new Image();
                if (!textures.bonus) textures.bonus = new Image();
                
                textures.heart.src = basePath + 'heart.png' + cacheBuster;
                textures.bonus.src = basePath + 'bonus.png' + cacheBuster;
            }
            
            // No specific texture setup needed for sorting - will fallback to color
            
            // Track when all main textures are loaded
            let loadedCount = 0;
            
            requiredTextures.forEach(textureType => {
                textures[textureType].onload = () => {
                    console.log(`‚úì Successfully loaded ${textureType} texture for level ${level}`);
                    loadedCount++;
                    if (loadedCount === requiredTextures.length) {
                        textures.loaded = true;
                        console.log(`‚úì All textures loaded for level ${level}`);
                    }
                };
                
                textures[textureType].onerror = () => {
                    console.error(`‚úó Failed to load ${textureType} texture for level ${level}, using fallback`);
                    loadedCount++;
                    if (loadedCount === requiredTextures.length) {
                        textures.loaded = true;
                        console.log(`All texture loading attempts complete for level ${level} (some failed)`);
                    }
                };
            });
        }
        
        // Improve canvas rendering quality
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        // Game object - will be populated with dynamic maze data
        const game = {
            score: 3,
            cumulativeScore: 0, // Session-only cumulative score, resets on page refresh
            currentLevelStartingHeartsAdded: false, // Track if we've added starting hearts for current level attempt
            currentLevel: 1,
            selectedDifficulty: 1,
            selectedCharacter: 'PT', // Default character
            maxUnlockedLevel: parseInt(localStorage.getItem('ptMazeMaxLevel')) || 1, // Track highest level unlocked
            gameLoopRunning: false, // Track if game loop is already running
            debugMode: false, // Debug mode toggle
            player: {
                x: 0,
                y: 0,
                size: 20,
                speed: 40,
                direction: 'right', // current facing direction
                animFrame: 0, // current animation frame (0 or 1)
                animTimer: 0, // timer for animation
                isMoving: false // whether player is currently moving
            },
            maze: [],
            doors: [], // Will be populated from CSV
            bonusItems: [], // Bonus collectibles (level 9)
            hasBonus: false, // Whether PT has collected the bonus
            rocketCountdown: 0, // Countdown timer for rocket boost (in seconds)
            rocketBoostData: null, // Stores rocket boost movement data when puzzle is active
            boostTransitionState: 'normal', // 'normal', 'starting', 'active', 'ending'
            originalMaze: [], // Store original maze for wall restoration
            playerStartPosition: { x: 0, y: 0 }, // Store starting position for teleport
            watering_hole: null, // Will be populated from CSV
            usedWords: [], // Track words used in current level to prevent repetition
            difficultyMode: 'hard', // easy, medium, hard
            testMode: false, // Test mode for alternative starting positions
            tileSize: 40,
            puzzleActive: false,
            celebrating: false,
            celebrationFrame: 0,
            celebrationTimer: 0,
            gameOverActive: false,
            gameOverFrame: 0,
            gameOverTimer: 0,
            paths: [], // Will be populated from CSV
            digraphEmojis: {}, // Will be populated from digraph-emojis.txt for Level 3
            digraphSounds: {}, // Will be populated from digraph-sounds.txt for Level 3
            emojiNames: {}, // Will be populated from emoji-names.txt for Level 3
            usedDigraphs: [], // Track digraphs used in current level to prevent repetition
        usedMultiplicationProblems: [], // Track multiplication pairs used in current level to prevent repetition
            levelScores: {}, // Track final score for each completed level
            ghost: null, // Ghost instance for current level
            deathLevel: null, // Track which level the user died on
            gameSession: { // Track current game session
                startTime: null,
                levelsCompleted: 0,
                totalScore: 0,
                completedLevels: new Set()
            }
        };
        
        
        // Debug function to reset progress (call in browser console)
        function resetProgress() {
            localStorage.removeItem('ptMazeMaxLevel');
            game.maxUnlockedLevel = 1;
            console.log('Progress reset to level 1');
        }
        
        // Difficulty selection function
        async function selectDifficulty(difficulty) {
            game.difficultyMode = difficulty;
            console.log(`Selected difficulty: ${difficulty} with character: ${game.selectedCharacter}`);
            
            // Verify character configuration is available
            if (configManager.isConfigLoaded()) {
                const characterConfig = configManager.getCharacterConfig(game.selectedCharacter);
                console.log(`Character config for ${game.selectedCharacter}:`, characterConfig);
            } else {
                console.error('Config manager not loaded when selecting difficulty!');
            }
            
            // Load character sprites before proceeding
            try {
                console.log(`Loading character sprites for ${game.selectedCharacter} before difficulty ${difficulty}`);
                await loadCharacterSprites();
                console.log(`Character sprites loaded successfully for ${game.selectedCharacter}`);
            } catch (error) {
                console.error(`Error loading character sprites for ${game.selectedCharacter}:`, error);
            }
            
            // Reset test mode when starting normal gameplay
            game.testMode = false;
            
            // Initialize game session
            game.levelScores = {};
            game.deathLevel = null;
            game.gameSession = {
                startTime: Date.now(),
                levelsCompleted: 0,
                totalScore: 0,
                completedLevels: new Set()
            };
            
            // Hide difficulty selection screen
            document.getElementById('difficultyScreen').style.display = 'none';
            
            // Show level selection screen instead of starting game directly
            showLevelSelection().catch(console.error);
        }
        
        // Level selection functions
        async function showLevelSelection() {
            await generateLevelButtons();
            document.getElementById('levelSelectionScreen').style.display = 'flex';
        }
        
        // Helper function to get puzzle textures for a level
        function getPuzzleTexturesForLevel(level) {
            // Use existing configManager function to get all required textures
            const requiredTextures = configManager.getRequiredTextures(level);
            
            // Filter out basic maze textures, keep only puzzle door textures
            // Note: getRequiredTextures returns texture names WITHOUT .png extension
            const basicTextures = ['open', 'wall', 'endpoint', 'heart', 'bonus'];
            const puzzleTextures = requiredTextures.filter(texture => 
                !basicTextures.includes(texture)
            );
            
            // Add .png extension to puzzle textures
            const puzzleTexturesWithExt = puzzleTextures.map(texture => texture + '.png');
            
            console.log(`Level ${level} puzzle textures:`, puzzleTexturesWithExt);
            
            // If no puzzle textures found, fallback to known good textures
            if (puzzleTexturesWithExt.length === 0) {
                return ['we.png', 'we.png'];
            }
            
            // If only one puzzle type, use it twice
            if (puzzleTexturesWithExt.length === 1) {
                return [puzzleTexturesWithExt[0], puzzleTexturesWithExt[0]];
            }
            
            // If more than two, take first two
            return puzzleTexturesWithExt.slice(0, 2);
        }

        async function generateLevelButtons() {
            const levelGrid = document.getElementById('levelGrid');
            levelGrid.innerHTML = '';
            
            // Load config if not already loaded
            if (!configManager.isConfigLoaded()) {
                await configManager.loadConfig();
                // Check for and apply custom config if available
                configManager.checkAndApplyCustomConfig();
            }
            
            // Get playable levels from config
            const playableLevels = configManager.getPlayableLevels();
            console.log('Loading playable levels:', playableLevels);
            
            for (const level of playableLevels) {
                const button = document.createElement('button');
                button.className = 'level-button-new';
                
                // Check if level is completed
                const isCompleted = game.gameSession.completedLevels.has(level);
                if (isCompleted) {
                    button.classList.add('completed');
                    // Don't add click handler for completed levels
                } else {
                    button.onclick = () => selectLevel(level);
                }
                
                // Create top half (white background with level number)
                const topHalf = document.createElement('div');
                topHalf.className = 'level-button-top';
                
                const levelNumber = document.createElement('div');
                levelNumber.className = 'level-number';
                levelNumber.textContent = level;
                
                topHalf.appendChild(levelNumber);
                
                // Create bottom half (puzzle textures side by side)
                const bottomHalf = document.createElement('div');
                bottomHalf.className = 'level-button-bottom';
                
                // Get puzzle textures for this level
                const puzzleTextures = getPuzzleTexturesForLevel(level);
                
                // Create two texture previews
                const texture1 = document.createElement('div');
                texture1.className = 'puzzle-texture';
                texture1.style.backgroundImage = `url('level-${level}/${puzzleTextures[0]}')`;
                
                const texture2 = document.createElement('div');
                texture2.className = 'puzzle-texture';
                texture2.style.backgroundImage = `url('level-${level}/${puzzleTextures[1]}')`;
                
                bottomHalf.appendChild(texture1);
                bottomHalf.appendChild(texture2);
                
                button.appendChild(topHalf);
                button.appendChild(bottomHalf);
                
                levelGrid.appendChild(button);
            }
        }
        
        function selectLevel(level) {
            console.log(`Selected level: ${level}`);
            
            // Hide level selection screen
            document.getElementById('levelSelectionScreen').style.display = 'none';
            
            // Start the selected level
            game.selectedDifficulty = level;
            game.currentLevelStartingHeartsAdded = false; // Reset flag for new level
            currentCelebrationSprites = loadCelebrationSprite(level);
            initializeGame();
        }
        
        // Ghost initialization function
        async function initializeGhost() {
            // Load game configuration if not already loaded
            if (!configManager.isConfigLoaded()) {
                await configManager.loadConfig();
            }
            
            const gameConfig = configManager.gameConfig;
            
            // Check if ghost is enabled globally and for this level
            if (!gameConfig.ghost || !gameConfig.ghost.enabled) {
                console.log('Ghost disabled globally');
                game.ghost = null;
                return;
            }
            
            // Create new ghost instance
            game.ghost = new Ghost(game.selectedDifficulty, gameConfig);
            
            // Set ghost difficulty based on selected game difficulty
            game.ghost.setDifficulty(game.difficultyMode);
            
            // Set ghost starting position near endpoint (will be called after maze loads)
            
            console.log('Ghost initialized for level', game.selectedDifficulty);
        }
        
        function backToDifficulty() {
            // Hide level selection screen
            document.getElementById('levelSelectionScreen').style.display = 'none';
            
            // Show difficulty selection screen
            document.getElementById('difficultyScreen').style.display = 'flex';
        }
        
        // Character selection functions
        async function showCharacterSelection() {
            await generateCharacterButtons();
            document.getElementById('characterSelectionScreen').style.display = 'flex';
        }
        
        async function generateCharacterButtons() {
            const characterButtons = document.getElementById('characterButtons');
            characterButtons.innerHTML = '';
            
            // Load config if not already loaded
            if (!configManager.isConfigLoaded()) {
                await configManager.loadConfig();
                // Check for and apply custom config if available
                configManager.checkAndApplyCustomConfig();
            }
            
            // Get available characters from config
            const availableCharacters = configManager.getAvailableCharacters();
            console.log('Loading available characters:', availableCharacters);
            
            for (const characterName of availableCharacters) {
                const characterConfig = configManager.getCharacterConfig(characterName);
                
                const button = document.createElement('button');
                button.className = 'character-button';
                button.onclick = () => selectCharacter(characterName);
                
                // Create character sprite div
                const sprite = document.createElement('div');
                sprite.className = 'character-sprite';
                
                // Load the character movement sprite and extract the last frame
                const movementSprite = new Image();
                movementSprite.onload = () => {
                    console.log(`Successfully loaded sprite for ${characterName}: ${characterConfig.movement}`);
                    console.log(`Sprite dimensions: ${movementSprite.width}x${movementSprite.height}`);
                    
                    // Check if this is an SVG file - SVGs may not provide width/height immediately
                    const isSVG = characterConfig.movement.toLowerCase().includes('.svg');
                    
                    if (isSVG) {
                        // For SVG files, use the sprite directly without canvas extraction
                        // SVG sprites should display properly when scaled
                        console.log(`Using SVG sprite directly for ${characterName}`);
                        sprite.style.backgroundImage = `url('${characterConfig.movement}')`;
                        sprite.style.backgroundSize = '720px 120px'; // Scale sprite sheet to fit in 120px height
                        sprite.style.backgroundPosition = '-600px 0px'; // Show last frame (scaled position)
                        sprite.style.backgroundRepeat = 'no-repeat';
                        console.log(`Set SVG sprite background for ${characterName} with scaled position -600px 0px`);
                    } else {
                        // For PNG/other raster images, use canvas extraction
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 160;
                        canvas.height = 160;
                        
                        try {
                            // Draw the last frame (5th frame, right-facing) - position 800,0 for 6-frame sprite
                            ctx.drawImage(movementSprite, 800, 0, 160, 160, 0, 0, 160, 160);
                            
                            // Set the sprite background to this frame
                            sprite.style.backgroundImage = `url('${canvas.toDataURL()}')`;
                            console.log(`Set canvas sprite background for ${characterName} - canvas data URL created`);
                        } catch (error) {
                            console.error(`Error drawing sprite for ${characterName}:`, error);
                            // Fallback: use the full sprite image scaled down
                            sprite.style.backgroundImage = `url('${characterConfig.movement}')`;
                            sprite.style.backgroundSize = 'cover';
                            sprite.style.backgroundPosition = 'center';
                            console.log(`Using fallback sprite display for ${characterName}`);
                        }
                    }
                };
                movementSprite.onerror = () => {
                    console.error(`Failed to load sprite for ${characterName}: ${characterConfig.movement}`);
                    // Show a fallback or error indicator
                    sprite.style.backgroundColor = '#f0f0f0';
                    sprite.style.border = '2px dashed #ccc';
                    sprite.textContent = characterName[0]; // Show first letter as fallback
                    console.log(`Using text fallback for ${characterName}`);
                };
                console.log(`Loading sprite for ${characterName}: ${characterConfig.movement}`);
                movementSprite.src = characterConfig.movement;
                
                // Only add the sprite, remove all text
                button.appendChild(sprite);
                
                characterButtons.appendChild(button);
            }
        }
        
        function selectCharacter(characterName) {
            console.log(`Selected character: ${characterName}`);
            game.selectedCharacter = characterName;
            
            // Verify character selection
            console.log(`Game object selectedCharacter: ${game.selectedCharacter}`);
            
            // Hide character selection screen
            document.getElementById('characterSelectionScreen').style.display = 'none';
            
            // Show difficulty selection screen
            document.getElementById('difficultyScreen').style.display = 'flex';
        }
        
        function backToCharacterSelection() {
            // Hide difficulty selection screen
            document.getElementById('difficultyScreen').style.display = 'none';
            // Show character selection screen
            document.getElementById('characterSelectionScreen').style.display = 'flex';
        }

        // Game Settings Modal Functions
        function openGameSettings() {
            const modal = document.getElementById('settingsModal');
            const iframe = document.getElementById('settingsIframe');
            
            // Reset iframe source to ensure fresh load
            iframe.src = 'game-settings.html';
            modal.style.display = 'flex';
            
            // Hide the settings applied message when opening settings
            document.getElementById('settingsAppliedMessage').style.display = 'none';
        }

        function closeGameSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // Functions called by the settings page
        function returnToCharacterSelection() {
            closeGameSettings();
        }

        async function applyCustomConfigAndStartGame(customConfig, selectedCharacter) {
            // Store the custom config globally for the game to use
            window.customGameConfig = customConfig;
            
            // Force reload the configuration with custom settings
            if (configManager.isConfigLoaded()) {
                await configManager.reloadWithCustomConfig();
            }
            
            // Close the settings modal
            closeGameSettings();
            
            // Show the settings applied message
            const message = document.getElementById('settingsAppliedMessage');
            message.style.display = 'block';
            
            // Auto-hide the message after 5 seconds
            setTimeout(() => {
                message.style.display = 'none';
            }, 5000);
            
            console.log('Custom game config applied:', customConfig);
        }

        // Make functions available globally for iframe communication
        window.returnToCharacterSelection = returnToCharacterSelection;
        window.applyCustomConfigAndStartGame = applyCustomConfigAndStartGame;
        
        
        function resetGame() {
            game.player.x = 0;
            game.player.y = 0;
            game.player.direction = 'right';
            // Store starting position for rocket boost teleport
            game.playerStartPosition.x = 0;
            game.playerStartPosition.y = 0;
            // Only reset testMode if it's not already set to true (preserve test mode)
            if (!game.testMode) {
                game.testMode = false;
            }
            
            // Set starting hearts based on difficulty mode (not level-specific)
            let startingHearts;
            if (game.difficultyMode === 'easy' || game.difficultyMode === 'medium') {
                startingHearts = 5;
            } else { // hard mode
                startingHearts = 3;
            }
            game.score = startingHearts;
            
            // Add starting hearts to cumulative score for this level
            if (!game.currentLevelStartingHeartsAdded) {
                game.cumulativeScore += startingHearts;
                game.currentLevelStartingHeartsAdded = true;
            }
            
            // Update display
            const scoreText = `‚ù§Ô∏è ${Math.max(0, game.score)} | üñ§ ${Math.max(0, game.cumulativeScore)}`;
            document.getElementById('score').textContent = scoreText;
            
            // Display level and difficulty mode
            const difficultyEmoji = {
                'easy': 'ü´õ',
                'medium': 'üòê', 
                'hard': 'üôÄ'
            };
            document.getElementById('level').textContent = `Level: ${game.selectedDifficulty} (${difficultyEmoji[game.difficultyMode]})`;
            
            // Reset used words and digraphs for this level to prevent repetition
            game.usedWords = [];
            game.usedDigraphs = [];
            
            // Reset all doors
            game.doors.forEach(door => {
                door.open = false;
                // Set door color based on type category
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
            });
        }
        
        // Initialize game with dynamic maze and word list data
        async function initializeGame() {
            console.log(`Initializing game for level ${game.selectedDifficulty} with character ${game.selectedCharacter}`);
            
            // Show the game container
            document.getElementById('gameContainer').style.display = 'block';
            
            // Load game configuration if not already loaded
            if (!configManager.isConfigLoaded()) {
                console.log('Loading config manager...');
                await configManager.loadConfig();
            }
            
            // Load character sprites based on selected character
            console.log('Loading character sprites...');
            await loadCharacterSprites();
            console.log('Character sprites loaded');
            
            // Reset problem tracking based on puzzle types for this level
            // Check for division visual puzzles
            const divisionConfig = configManager.getPuzzleConfig(game.selectedDifficulty, 'division_visual');
            if (divisionConfig) {
                game.hasUsedAnswerOne = false;
                game.hasUsedDivideByOne = false;
                game.usedDivisionProblems = new Set();
                console.log(`Reset division problem tracking for level ${game.selectedDifficulty}`);
            }
            
            // Check for multiplication puzzles
            const multiplicationConfig = configManager.getPuzzleConfig(game.selectedDifficulty, 'multiplication_groups');
            if (multiplicationConfig) {
                game.usedMultiplicationProblems = [];
                console.log(`Reset multiplication problem tracking for level ${game.selectedDifficulty}`);
            }
            
            // Reset bonus state when starting levels with rocket boost
            if (configManager.hasFeature(game.selectedDifficulty, 'rocket_boost')) {
                game.hasBonus = false;
                game.rocketCountdown = 0;
                currentMovementSprites = characterSprites.movement;
                updateRocketDisplay(); // Hide countdown display
                console.log('Reset bonus state for level 9');
            }
            
            // Load textures for this level
            console.log('Loading textures...');
            loadTextures(game.selectedDifficulty);
            
            console.log('Loading character bonus sprite...');
            loadCharacterBonusSprite(game.selectedDifficulty);
            
            console.log('Starting maze data loading...');
            // Load maze data and conditional puzzle data in parallel
            const loadPromises = [
                loadMazeFromCSV()
            ];
            
            // Add digraph data loading for levels that have digraph puzzles
            const digraphConfig = configManager.getPuzzleConfig(game.selectedDifficulty, 'digraph_sounds');
            if (digraphConfig) {
                loadPromises.push(loadDigraphData());
            }
            
            const results = await Promise.all(loadPromises);
            const mazeData = results[0];
            const digraphData = results[1]; // Will be undefined if not loaded
            
            console.log(`Loaded maze data:`, mazeData);
            console.log(`Doors found: ${mazeData.doors?.length || 0}`);
            console.log(`Paths found: ${mazeData.paths?.length || 0}`);
            
            game.doors = mazeData.doors;
            game.paths = mazeData.paths;
            game.watering_hole = mazeData.watering_hole;
            game.bonusItems = mazeData.bonusItems;
            
            // Store original maze for wall restoration during rocket boost
            game.originalMaze = JSON.parse(JSON.stringify(mazeData.maze || []));
            
            // Store digraph data if this level has digraph puzzles and data was loaded
            if (digraphConfig && digraphData) {
                game.digraphEmojis = digraphData.digraphEmojis;
                game.digraphSounds = digraphData.digraphSounds;
                game.emojiNames = digraphData.emojiNames;
                console.log(`Loaded digraph data for Level ${game.selectedDifficulty}:`, digraphData);
            }
            
            // Initialize ghost for this level
            console.log('Initializing ghost for level...');
            initializeGhost();
            
            // Set ghost starting position now that maze data is loaded
            if (game.ghost && game.ghost.isActive) {
                game.ghost.setStartingPosition(game.watering_hole, game.paths);
                game.ghost.initializeSkullDisplay();
            }
            
            // Reset game state with new data
            resetGame();
            
            // Start the game after both are loaded (only if not already running)
            if (!game.gameLoopRunning) {
                game.gameLoopRunning = true;
                gameLoop();
            }
        }
        
        function updateScore(points) {
            game.score += points;
            game.cumulativeScore += points;
            
            // Update display with level score and cumulative score
            const scoreText = `‚ù§Ô∏è ${Math.max(0, game.score)} | üñ§ ${Math.max(0, game.cumulativeScore)}`;
            document.getElementById('score').textContent = scoreText;
            
            if (game.score <= 0) {
                // Immediately dismiss any open puzzle dialog
                if (game.puzzleActive) {
                    document.getElementById('puzzleModal').style.display = 'none';
                    game.puzzleActive = false;
                    // Clear any multiplication door reference
                    game.currentMultiplicationDoor = null;
                }
                gameOver();
            }
        }
        
        function gameOver() {
            console.log('Game over triggered');
            // Track which level the user died on
            game.deathLevel = game.selectedDifficulty;
            game.gameOverActive = true;
            game.gameOverFrame = 0;
            game.gameOverTimer = 0;
            document.getElementById('gameOverScreen').style.display = 'flex';
            console.log('Starting game over animation');
            animateGameOver();
        }
        
        function animateGameOver() {
            if (!game.gameOverActive) return;
            
            const canvas = document.getElementById('gameOverSprite');
            const ctx = canvas.getContext('2d');
            
            if (!canvas) {
                console.error('Game over canvas not found');
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameOverSprite.complete) {
                // 13 frames, each 436x436 pixels
                const frameWidth = 436;
                const frameHeight = 436;
                const totalFrames = 13;
                
                // Calculate frame position (horizontal layout)
                const frameX = game.gameOverFrame * frameWidth;
                const frameY = 0;
                
                // Draw current frame
                ctx.drawImage(
                    gameOverSprite,
                    frameX, frameY, frameWidth, frameHeight, // Source frame
                    0, 0, canvas.width, canvas.height // Destination (full canvas)
                );
                
                // Update frame counter
                game.gameOverTimer++;
                if (game.gameOverTimer >= 15) { // Slower animation
                    game.gameOverFrame = (game.gameOverFrame + 1) % totalFrames;
                    game.gameOverTimer = 0;
                }
            } else {
                // Show a placeholder while sprite loads
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width/2, canvas.height/2);
                console.log('Game over sprite not loaded yet');
            }
            
            requestAnimationFrame(animateGameOver);
        }
        
        function restartGame() {
            // Stop game over animation and any celebrations
            game.gameOverActive = false;
            game.celebrating = false;
            document.getElementById('celebrationScreen').style.display = 'none';
            
            // Reset all game data including cumulative score
            game.levelScores = {};
            game.deathLevel = null;
            game.cumulativeScore = 0; // Reset cumulative score
            game.gameSession = {
                startTime: Date.now(),
                levelsCompleted: 0,
                totalScore: 0,
                completedLevels: new Set()
            };
            
            // Hide game over screen and show character selection
            document.getElementById('gameOverScreen').style.display = 'none';
            showCharacterSelection();
        }
        
        function isOnPath(x, y) {
            return game.paths.some(path => 
                x >= path.x && x < path.x + path.width &&
                y >= path.y && y < path.y + path.height
            );
        }
        
        function isDoorBlocking(newX, newY) {
            return game.doors.some(door => 
                !door.open && 
                newX === door.x && newY === door.y
            );
        }
        
        function checkHeartCollection(x, y) {
            // Find any heart at this position
            const heartPath = game.paths.find(path => 
                path.type === 'heart' && 
                !path.collected &&
                x === path.x && y === path.y
            );
            
            if (heartPath) {
                // Mark heart as collected
                heartPath.collected = true;
                
                // Add one life/point
                updateScore(1);
                
                console.log('Heart collected! +1 life');
                
                // Optional: Play a collection sound or show visual feedback
                // You could add a brief animation or sound here
            }
        }
        
        function checkBonusCollection(x, y) {
            // Find any bonus at this position
            const bonusItem = game.bonusItems.find(bonus => 
                !bonus.collected &&
                x === bonus.x && y === bonus.y
            );
            
            if (bonusItem) {
                // Mark bonus as collected
                bonusItem.collected = true;
                
                // Start the boost transition instead of immediate activation
                startBoostTransition();
                
                console.log('Bonus collected! Starting rocket boost transition');
            }
        }
        
        function startRocketCountdown() {
            // Update countdown display immediately
            updateRocketDisplay();
            
            // Start countdown timer
            const countdownInterval = setInterval(() => {
                // Only countdown if no puzzle is active (pause during puzzles)
                if (!game.puzzleActive) {
                    game.rocketCountdown--;
                    updateRocketDisplay();
                    
                    if (game.rocketCountdown <= 0) {
                        // Rocket boost expired - start end transition
                        clearInterval(countdownInterval);
                        endBoostTransition();
                        console.log('Rocket boost expired! Starting end transition');
                    }
                }
            }, 1000);
        }
        
        function updateRocketDisplay() {
            let rocketDisplay = document.getElementById('rocketDisplay');
            const gameContainer = document.getElementById('gameContainer');
            
            if (!rocketDisplay) {
                // Create rocket display element
                rocketDisplay = document.createElement('div');
                rocketDisplay.id = 'rocketDisplay';
                rocketDisplay.style.cssText = `
                    text-align: center;
                    font-size: 18px;
                    font-weight: bold;
                    color: #FFFFFF;
                    margin-bottom: 10px;
                    padding: 5px;
                    background: rgba(0, 0, 0, 0.3);
                    border-radius: 10px;
                    display: none;
                `;
                gameContainer.prepend(rocketDisplay);
            }
            
            if (game.rocketCountdown > 0) {
                rocketDisplay.textContent = `üöÄ Rocket Boost: ${game.rocketCountdown}s`;
                rocketDisplay.style.display = 'block';
                
                // Add rocket boost background
                gameContainer.classList.add('rocket-boost');
                
                // Add blinking effect in last 5 seconds
                if (game.rocketCountdown <= 5) {
                    gameContainer.classList.add('blinking');
                } else {
                    gameContainer.classList.remove('blinking');
                }
            } else {
                rocketDisplay.style.display = 'none';
                // Remove all rocket boost effects
                gameContainer.classList.remove('rocket-boost', 'blinking');
            }
        }
        
        function getBlockingDoor(x, y) {
            return game.doors.find(door => 
                !door.open && 
                x === door.x && y === door.y
            );
        }
        
        function completeRocketBoostMovement() {
            if (!game.rocketBoostData) return;
            
            const data = game.rocketBoostData;
            
            // Open all doors in the path and collect all hearts/bonuses
            for (let i = 0; i < data.maxSpaces; i++) {
                const space = data.spaces[i];
                
                // Open any doors at this position
                const door = getBlockingDoor(space.x, space.y);
                if (door && !door.open) {
                    door.open = true;
                    door.color = '#B8F2B8'; // Change to green
                }
                
                // Collect hearts and bonuses
                checkHeartCollection(space.x, space.y);
                checkBonusCollection(space.x, space.y);
            }
            
            // Move PT to the furthest valid position (3rd space if possible)
            const finalSpace = data.spaces[data.maxSpaces - 1];
            game.player.x = finalSpace.x;
            game.player.y = finalSpace.y;
            
            // Clear rocket boost data
            game.rocketBoostData = null;
            
            console.log(`Rocket boost completed: moved ${data.maxSpaces} spaces`);
        }
        
        // Wall transition functions for rocket boost
        function startBoostTransition() {
            if (game.selectedDifficulty !== 9 && game.selectedDifficulty !== 10) return;
            
            console.log('Starting rocket boost transition');
            game.boostTransitionState = 'starting';
            
            // Freeze player movement
            game.player.isMoving = false;
            
            // Show boost transition modal
            showBoostTransitionModal(true);
        }
        
        function showBoostTransitionModal(isStarting) {
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'boostTransitionModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 6000;
                display: flex;
                justify-content: center;
                align-items: center;
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 40px;
                border-radius: 20px;
                text-align: center;
                box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            `;
            
            // Create animated PT sprite canvas
            const spriteCanvas = document.createElement('canvas');
            spriteCanvas.width = 200;
            spriteCanvas.height = 200;
            spriteCanvas.style.cssText = `
                display: block;
                margin: 20px auto;
                border: 3px solid #2E8B57;
                border-radius: 10px;
            `;
            
            const spriteCtx = spriteCanvas.getContext('2d');
            const spriteToUse = isStarting ? characterSprites.bonus : characterSprites.movement;
            
            // Animate the sprite
            let animFrame = 0;
            const animateSprite = () => {
                if (spriteToUse.complete) {
                    spriteCtx.clearRect(0, 0, 200, 200);
                    
                    // Use right-facing frames and alternate between them
                    const frameX = (animFrame % 2 === 0) ? 0 : 160;
                    
                    spriteCtx.drawImage(
                        spriteToUse,
                        frameX, 0, 160, 160,
                        20, 20, 160, 160
                    );
                    
                    animFrame++;
                }
            };
            
            const animInterval = setInterval(animateSprite, 500);
            
            // Create button
            const button = document.createElement('button');
            button.textContent = isStarting ? 'START BOOST!' : 'RETURN TO NORMAL';
            button.style.cssText = `
                background: ${isStarting ? '#FF4500' : '#4CAF50'};
                color: white;
                padding: 15px 30px;
                border: none;
                border-radius: 10px;
                font-size: 20px;
                font-weight: bold;
                cursor: pointer;
                margin-top: 20px;
            `;
            
            button.onclick = () => {
                clearInterval(animInterval);
                document.body.removeChild(modal);
                
                if (isStarting) {
                    // Start boost mode
                    removeWalls();
                    currentMovementSprites = characterSprites.bonus;
                    game.rocketCountdown = 30;
                    game.boostTransitionState = 'active';
                    startRocketCountdown();
                    
                    const gameContainer = document.getElementById('gameContainer');
                    gameContainer.style.transition = 'background 0.5s ease';
                    gameContainer.classList.add('rocket-boost');
                    
                    console.log('Rocket boost active - walls removed');
                } else {
                    // End boost mode
                    // Store current position
                    const currentX = game.player.x;
                    const currentY = game.player.y;
                    
                    // Restore walls first
                    restoreWalls();
                    
                    // Then find best position for PT (current position if valid, or nearest open square)
                    const newPosition = findNearestOpenSquareAfterRestore(currentX, currentY);
                    game.player.x = newPosition.x;
                    game.player.y = newPosition.y;
                    
                    currentMovementSprites = characterSprites.movement;
                    
                    const gameContainer = document.getElementById('gameContainer');
                    gameContainer.style.transition = 'background 0.5s ease';
                    gameContainer.classList.remove('rocket-boost', 'blinking');
                    
                    game.hasBonus = false;
                    game.rocketCountdown = 0;
                    game.boostTransitionState = 'normal';
                    updateRocketDisplay();
                    
                    const movedText = (newPosition.x === game.playerStartPosition.x && newPosition.y === game.playerStartPosition.y) 
                        ? 'player teleported to start' 
                        : `player moved to nearest open square (${newPosition.x}, ${newPosition.y})`;
                    console.log(`Rocket boost ended - walls restored, ${movedText}`);
                }
            };
            
            // Add title
            const title = document.createElement('h2');
            title.textContent = isStarting ? 'üöÄ ROCKET BOOST READY!' : 'üèÅ BOOST ENDING';
            title.style.cssText = `
                color: ${isStarting ? '#FF4500' : '#4CAF50'};
                font-size: 28px;
                margin-bottom: 10px;
            `;
            
            content.appendChild(title);
            content.appendChild(spriteCanvas);
            content.appendChild(button);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function endBoostTransition() {
            if (game.selectedDifficulty !== 9 && game.selectedDifficulty !== 10) return;
            
            // Don't show boost end modal if level is already completed
            if (game.celebrating) {
                console.log('Level already completed, skipping boost end modal');
                return;
            }
            
            console.log('Ending rocket boost transition');
            game.boostTransitionState = 'ending';
            
            // Check if player is on a heart and collect it
            checkHeartCollection(game.player.x, game.player.y);
            
            // Freeze player movement
            game.player.isMoving = false;
            
            // Show boost transition modal
            showBoostTransitionModal(false);
        }
        
        function removeWalls() {
            // Collect all wall positions first
            const wallPositions = [];
            for (let rowIndex = 0; rowIndex < game.originalMaze.length; rowIndex++) {
                for (let colIndex = 0; colIndex < game.originalMaze[rowIndex].length; colIndex++) {
                    const cellValue = game.originalMaze[rowIndex][colIndex];
                    if (cellValue === '' || cellValue === ' ') {
                        wallPositions.push({ rowIndex, colIndex });
                    }
                }
            }
            
            // Shuffle the wall positions to randomize which half we remove
            for (let i = wallPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [wallPositions[i], wallPositions[j]] = [wallPositions[j], wallPositions[i]];
            }
            
            // Remove only half of the walls
            const halfCount = Math.floor(wallPositions.length / 2);
            for (let i = 0; i < halfCount; i++) {
                const { rowIndex, colIndex } = wallPositions[i];
                const x = colIndex * 40;
                const y = rowIndex * 40;
                game.paths.push({ x, y, width: 40, height: 40 });
            }
            
            console.log(`Removed ${halfCount} out of ${wallPositions.length} walls`);
        }
        
        function restoreWalls() {
            // Remove all paths that were originally walls
            game.paths = game.paths.filter(path => {
                const colIndex = path.x / 40;
                const rowIndex = path.y / 40;
                
                // Check if this path was originally a wall
                if (rowIndex < game.originalMaze.length && colIndex < game.originalMaze[rowIndex].length) {
                    const originalCell = game.originalMaze[rowIndex][colIndex];
                    // Keep paths that were originally non-empty (not walls)
                    return originalCell !== '' && originalCell !== ' ';
                }
                return true;
            });
        }
        
        function isPositionWalkable(x, y) {
            // Check if a position is currently walkable (has a path)
            const gridX = Math.round(x / 40) * 40;
            const gridY = Math.round(y / 40) * 40;
            
            return game.paths.some(path => path.x === gridX && path.y === gridY);
        }
        
        function findNearestOpenSquareAfterRestore(startX, startY) {
            // Snap to grid
            const gridStartX = Math.round(startX / 40) * 40;
            const gridStartY = Math.round(startY / 40) * 40;
            
            // If current position is walkable after wall restoration, stay there
            if (isPositionWalkable(gridStartX, gridStartY)) {
                console.log(`PT staying at current position: (${gridStartX}, ${gridStartY})`);
                return { x: gridStartX, y: gridStartY };
            }
            
            // Otherwise, search in expanding squares for nearest walkable position
            const maxDistance = Math.max(game.originalMaze.length, game.originalMaze[0]?.length || 0);
            
            for (let distance = 1; distance <= maxDistance; distance++) {
                // Check all positions at this distance
                for (let dx = -distance; dx <= distance; dx++) {
                    for (let dy = -distance; dy <= distance; dy++) {
                        // Only check positions on the border of this distance square
                        if (Math.abs(dx) !== distance && Math.abs(dy) !== distance) continue;
                        
                        const checkX = gridStartX + (dx * 40);
                        const checkY = gridStartY + (dy * 40);
                        
                        if (isPositionWalkable(checkX, checkY)) {
                            console.log(`Found nearest open square at distance ${distance}: (${checkX}, ${checkY})`);
                            return { x: checkX, y: checkY };
                        }
                    }
                }
            }
            
            // Fallback to start position if no open square found
            console.warn('No open square found, falling back to start position');
            return { x: game.playerStartPosition.x, y: game.playerStartPosition.y };
        }
        
        
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw wall texture background across the entire canvas (including padding areas)
            let wallTexture = textures.wall;
            
            // Walls always use normal texture - boost texture is only for newly opened paths
            
            if (textures.loaded && wallTexture.complete) {
                // Draw wall texture in a proper grid pattern covering entire canvas
                for (let x = 0; x < Math.ceil(canvas.width / 40); x++) {
                    for (let y = 0; y < Math.ceil(canvas.height / 40); y++) {
                        ctx.drawImage(wallTexture, x * 40, y * 40, 40, 40);
                    }
                }
            } else {
                // Fallback to solid color if texture isn't loaded
                ctx.fillStyle = '#2F4F2F';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw open paths using texture (same maze layout with thicker border)
            game.paths.forEach(path => {
                if (path.type === 'heart' && !path.collected) {
                    // Draw heart collectible
                    if (textures.loaded && textures.heart.complete) {
                        ctx.drawImage(textures.heart, path.x + 40, path.y + 40, 40, 40);
                    } else {
                        // Fallback: draw open path with heart emoji
                        ctx.fillStyle = '#B8F2B8';
                        ctx.fillRect(path.x + 40, path.y + 40, 40, 40);
                        ctx.fillStyle = '#FF0000';
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚ù§Ô∏è', path.x + 60, path.y + 65);
                    }
                } else if (path.type !== 'heart' || path.collected) {
                    // Draw regular open path
                    if (textures.loaded && textures.open.complete) {
                        // Direct positioning with 40px border padding
                        ctx.drawImage(textures.open, path.x + 40, path.y + 40, 40, 40);
                    } else {
                        // Fallback to solid color
                        ctx.fillStyle = '#B8F2B8';
                        ctx.fillRect(path.x + 40, path.y + 40, 40, 40);
                    }
                }
            });
            
            // Draw bonus items (level 9)
            if (game.bonusItems) {
                game.bonusItems.forEach(bonus => {
                    if (!bonus.collected) {
                        if (textures.loaded && textures.bonus.complete) {
                            ctx.drawImage(textures.bonus, bonus.x + 40, bonus.y + 40, 40, 40);
                        } else {
                            // Fallback: draw open path with star emoji
                            ctx.fillStyle = '#B8F2B8';
                            ctx.fillRect(bonus.x + 40, bonus.y + 40, 40, 40);
                            ctx.fillStyle = '#FFD700';
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('‚≠ê', bonus.x + 60, bonus.y + 65);
                        }
                    }
                });
            }
            
            // Draw doors using textures
            game.doors.forEach(door => {
                if (!door.open) {
                    let doorTexture = null;
                    
                    // Use obstacle-based texture loading
                    if (door.obstacleCode) {
                        const obstacleNumber = door.obstacleCode.replace('ob', ''); // ob1 -> 1, ob2 -> 2, etc.
                        const textureName = `obstacle${obstacleNumber}`;
                        doorTexture = textures[textureName];
                    } else {
                        console.warn('Door missing obstacleCode, cannot determine texture');
                        doorTexture = null;
                    }
                    
                    // Draw door texture or fallback color
                    if (textures.loaded && doorTexture && doorTexture.complete) {
                        // Simple direct positioning with thicker border
                        ctx.drawImage(doorTexture, door.x + 40, door.y + 40, 40, 40);
                    } else {
                        // Fallback to plain color only
                        ctx.fillStyle = door.color;
                        ctx.fillRect(door.x + 40, door.y + 40, 40, 40);
                    }
                }
            });
            
            // Draw watering hole (endpoint) using texture
            if (game.watering_hole) {
                if (textures.loaded && textures.endpoint.complete) {
                    ctx.drawImage(textures.endpoint, game.watering_hole.x + 40, game.watering_hole.y + 40, 40, 40);
                } else {
                    // Fallback to original style
                    ctx.fillStyle = '#FFB6C1'; // Light pink background
                    ctx.fillRect(game.watering_hole.x + 40, game.watering_hole.y + 40, 40, 40);
                    ctx.fillStyle = '#000';
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üéÇ', game.watering_hole.x + 60, game.watering_hole.y + 68);
                }
            }
            
            // Draw PT sprite (offset by 30px)
            if (currentMovementSprites.complete) {
                // Calculate which frame to use based on direction and animation
                let frameX = 0;
                if (game.player.direction === 'right') {
                    frameX = (game.player.animFrame === 0) ? 0 : 160; // Frames 1, 2
                } else if (game.player.direction === 'left') {
                    frameX = (game.player.animFrame === 0) ? 320 : 480; // Frames 3, 4
                } else if (game.player.direction === 'up') {
                    frameX = (game.player.animFrame === 0) ? 640 : 800; // Frames 5, 6
                } else if (game.player.direction === 'down') {
                    frameX = (game.player.animFrame === 0) ? 640 : 800; // Frames 5, 6 (same as up for now)
                }
                
                // Draw the sprite frame (160x160 from SVG sprite sheet)
                // PT should be 45x45 to be bigger than the tile (overlaps slightly)
                const ptSize = 45;
                const ptOffset = -2.5; // Negative offset to center the larger sprite
                
                ctx.drawImage(
                    currentMovementSprites,
                    frameX, 0, 160, 160, // Source: x, y, width, height from sprite sheet
                    game.player.x + 40 + ptOffset, game.player.y + 40 + ptOffset, ptSize, ptSize // Centered in tile with thicker border
                );
            } else {
                // Fallback while sprite loads - bigger and centered
                const tileCenter = 20;
                ctx.fillStyle = '#D3D3D3';
                ctx.beginPath();
                ctx.arc(game.player.x + 40 + tileCenter, game.player.y + 40 + tileCenter, 22, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üêò', game.player.x + 40 + tileCenter, game.player.y + 40 + tileCenter + 10);
            }
            
            // Draw ghost if active
            if (game.ghost && game.ghost.isActive) {
                game.ghost.render(ctx, game.tileSize, 40, 40);
            }
        }
        
        
        // Design system keyboard listener (Shift + Ctrl + S)
        document.addEventListener('keydown', (e) => {
            if (e.shiftKey && e.ctrlKey && (e.key === 'S' || e.key === 's')) {
                e.preventDefault();
                window.open('design-system.html', '_blank');
                console.log('üé® Design System opened in new tab');
                return;
            }
        });
        
        // Global arrow key prevention to stop page scrolling
        document.addEventListener('keydown', (e) => {
            // Always prevent arrow keys from scrolling the page
            const key = e.key || e.code;
            const navigationKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Up', 'Down', 'Left', 'Right', 'w', 'W', 'a', 'A', 's', 'S', 'd', 'D'];
            if (navigationKeys.includes(key)) {
                e.preventDefault();
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', async (e) => {
            // Don't allow movement if puzzle is active or during boost transitions
            if (game.puzzleActive) return;
            if (game.boostTransitionState === 'starting' || game.boostTransitionState === 'ending') return;
            
            // Snap current position to grid first
            let currentGridX = Math.round(game.player.x / game.tileSize) * game.tileSize;
            let currentGridY = Math.round(game.player.y / game.tileSize) * game.tileSize;
            
            let newX = currentGridX;
            let newY = currentGridY;
            
            // Movement is always single tile now (walls are removed during boost instead of triple movement)
            const moveDistance = game.tileSize;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    newY -= moveDistance;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    newY += moveDistance;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    newX -= moveDistance;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    newX += moveDistance;
                    break;
                default:
                    return;
            }
            
            // Normal movement (single space)
            if (isOnPath(newX, newY)) {
                // Check if a door is blocking the path
                if (!isDoorBlocking(newX, newY)) {
                    // Update player position
                    game.player.x = newX;
                    game.player.y = newY;
                    
                    // Check for heart collection
                    checkHeartCollection(newX, newY);
                    // Check for bonus collection
                    checkBonusCollection(newX, newY);
                    
                    // Update direction and start animation
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        game.player.direction = 'left';
                    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        game.player.direction = 'right';
                    } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        game.player.direction = 'up';
                    } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                        game.player.direction = 'down';
                    }
                    
                    // Trigger walking animation
                    game.player.isMoving = true;
                    game.player.animFrame = (game.player.animFrame + 1) % 2; // Toggle between frames 0 and 1
                } else {
                    // Find which door is blocking and show puzzle
                    const blockingDoor = game.doors.find(door => 
                        !door.open && 
                        newX === door.x && newY === door.y
                    );
                    if (blockingDoor && !game.puzzleActive) {
                        // Route to appropriate puzzle system based on door type
                        if (blockingDoor.type === 'simple_arithmetic') {
                            // Use modular system for simple arithmetic
                            const usedModular = showSimpleMathPuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else if (blockingDoor.type === 'word_emoji_matching') {
                            // Use modular system for word-emoji matching
                            const usedModular = await showWordEmojiPuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else if (blockingDoor.type === 'number_line') {
                            // Use modular system for number line puzzles
                            const usedModular = showNumberLinePuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else if (blockingDoor.type === 'digraph_sounds') {
                            // Use modular system for digraph puzzles
                            const usedModular = showDigraphPuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else if (blockingDoor.type === 'multiplication_groups') {
                            // Use modular system for multiplication groups puzzles
                            const usedModular = showMultiplicationGroupsPuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else if (blockingDoor.type === 'letter_identification') {
                            // Use modular system for letter identification puzzles
                            const usedModular = showLetterIdentificationPuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else if (blockingDoor.type === 'audio_reading') {
                            // Use modular system for audio reading puzzles
                            const usedModular = showAudioReadingPuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else if (blockingDoor.type === 'division_visual') {
                            // Use modular system for division puzzles
                            const usedModular = showDivisionPuzzle(blockingDoor);
                            if (!usedModular) {
                                showPuzzle(blockingDoor.type, blockingDoor);
                            }
                        } else {
                            // Use original system for all other puzzle types
                            showPuzzle(blockingDoor.type, blockingDoor);
                        }
                    }
                }
            } else {
                // Path is blocked by wall - no movement allowed
                console.log('Movement blocked by wall');
            }
            
            // Check for watering hole win condition
            if (game.watering_hole) {
                // Player needs to be on the exact same tile as the watering hole
                const playerGridX = Math.round(game.player.x / 40) * 40;
                const playerGridY = Math.round(game.player.y / 40) * 40;
                const wateringHoleGridX = Math.round(game.watering_hole.x / 40) * 40;
                const wateringHoleGridY = Math.round(game.watering_hole.y / 40) * 40;
                
                if (playerGridX === wateringHoleGridX && playerGridY === wateringHoleGridY) {
                    console.log(`Player reached watering hole at (${playerGridX}, ${playerGridY})`);
                    showCelebration();
                }
            }
        });
        
        // Simple Math Puzzle Integration - Only for simple_arithmetic type
        function showSimpleMathPuzzle(door) {
            // Only handle simple_arithmetic door type (Levels 1-3)
            if (door.type === 'simple_arithmetic') {
                console.log(`Using modular simple math puzzle for door type: ${door.type}`);
                const puzzle = new SimpleMathPuzzle(door);
                puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }
        
        // Word-Emoji Puzzle Integration - Only for word_emoji_matching type
        async function showWordEmojiPuzzle(door) {
            // Only handle word_emoji_matching door type (Levels 1-2)
            if (door.type === 'word_emoji_matching') {
                console.log(`Using modular word-emoji puzzle for door type: ${door.type}`);
                const puzzle = new WordEmojiPuzzle(door);
                await puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }
        
        // Number Line Puzzle Integration - Only for number_line type
        function showNumberLinePuzzle(door) {
            // Only handle number_line door type (Levels 4-9)
            if (door.type === 'number_line') {
                console.log(`Using modular number line puzzle for door type: ${door.type}`);
                const puzzle = new NumberLinePuzzle(door);
                puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }

        function showDivisionPuzzle(door) {
            // Only handle division_visual door type (Levels 8-10)
            if (door.type === 'division_visual') {
                console.log(`Using modular division puzzle for door type: ${door.type}`);
                const puzzle = new DivisionPuzzle(door);
                puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }
        
        function showDigraphPuzzle(door) {
            // Only handle digraph_sounds door type (Levels 3-7)
            if (door.type === 'digraph_sounds') {
                console.log(`Using modular digraph puzzle for door type: ${door.type}`);
                const puzzle = new DigraphPuzzle(door);
                puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }
        
        function showMultiplicationGroupsPuzzle(door) {
            // Only handle multiplication_groups door type (Level 10)
            if (door.type === 'multiplication_groups') {
                console.log(`Using modular multiplication groups puzzle for door type: ${door.type}`);
                const puzzle = new MultiplicationGroupsPuzzle(door);
                puzzle.showModal();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }

        function showLetterIdentificationPuzzle(door) {
            // Only handle letter_identification door type
            if (door.type === 'letter_identification') {
                console.log(`Using modular letter identification puzzle for door type: ${door.type}`);
                const puzzle = new LetterIdentificationPuzzle(door);
                puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }

        function showAudioReadingPuzzle(door) {
            // Only handle audio_reading door type
            if (door.type === 'audio_reading') {
                console.log(`Using modular audio reading puzzle for door type: ${door.type}`);
                const puzzle = new AudioReadingPuzzle(door);
                puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }
        
        function checkAnswer(correct, type, door, buttonElement, selectedEmoji = null) {
            const result = document.getElementById('puzzleResult');
            
            // Track attempts for this problem
            if (!door.currentProblemAttempts) door.currentProblemAttempts = 0;
            door.currentProblemAttempts++;
            
            if (correct) {
                result.innerHTML = 'üëç';
                result.style.color = 'green';
                result.style.fontSize = '48px'; // Make thumbs up bigger
                door.open = true;
                
                // Complete rocket boost movement if active
                completeRocketBoostMovement();
                
                // For digraph puzzles, speak the emoji word name
                const hasDigraphPuzzle = configManager.getLevelConfig(game.selectedDifficulty)?.puzzles?.digraph_sounds;
                if (hasDigraphPuzzle && (type === 'digraph_sounds') && selectedEmoji) {
                    setTimeout(() => {
                        speakEmojiWord(selectedEmoji);
                    }, 300); // Slight delay after showing thumbs up
                }
                
                // Give +1 point for correct answer (net effect: 1 - number_of_wrong_attempts)
                // Update score for correct answers (all puzzle types give +1)
                updateScore(1);
                
                // Weaken ghost when puzzle is solved correctly
                if (game.ghost && game.ghost.isActive) {
                    game.ghost.onPuzzleSolved();
                }
                
                // Reset attempt counters
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
                
                // Change door color to match open path
                door.color = '#B8F2B8';
                
                setTimeout(() => {
                    document.getElementById('puzzleModal').style.display = 'none';
                    result.innerHTML = '';
                    result.style.fontSize = ''; // Reset font size
                    game.puzzleActive = false;
                    // Clear any multiplication door reference
                    game.currentMultiplicationDoor = null;
                }, 800); // Faster disappear (800ms instead of 1500ms)
            } else {
                result.innerHTML = 'üëé';
                result.style.color = 'red';
                
                // For digraph puzzles, speak the emoji word name even for wrong answers
                const hasDigraphPuzzle = configManager.getLevelConfig(game.selectedDifficulty)?.puzzles?.digraph_sounds;
                if (hasDigraphPuzzle && (type === 'digraph_sounds') && selectedEmoji) {
                    setTimeout(() => {
                        speakEmojiWord(selectedEmoji);
                    }, 300); // Slight delay after showing thumbs down
                }
                
                // Deduct points based on difficulty mode
                let pointsToDeduct = 0;
                
                if (game.difficultyMode === 'easy') {
                    pointsToDeduct = -1; // Always lose 1 point in easy mode
                } else if (game.difficultyMode === 'medium') {
                    // In medium mode: first wrong answer = -1, second wrong answer = -2
                    pointsToDeduct = door.currentProblemAttempts === 1 ? -1 : -2;
                } else {
                    pointsToDeduct = -2; // Hard mode: always lose 2 points
                }
                
                // Update score for wrong answers (all puzzle types use same penalty)
                updateScore(pointsToDeduct);
                
                // Disable the wrong answer button
                buttonElement.disabled = true;
                buttonElement.style.backgroundColor = '#ccc';
                buttonElement.style.cursor = 'not-allowed';
                
                // Track failed attempts
                if (!door.failedAttempts) door.failedAttempts = 0;
                door.failedAttempts++;
        
        
        
        
        
        
        
        // Common component for generating level score displays
        
        } // Closes 'else' block from line 2690 (wrong answer handling)
        } // Closes checkAnswer() function from line 2647
        
        // Score screen functions - moved to global scope for onclick accessibility
        function generateLevelScoreDisplay(maxLevel, deathLevel = null) {
            const container = document.getElementById('levelScoresContainer');
            container.innerHTML = '';
            
            // Use dynamic level loading from JSON config
            const playableLevels = configManager.getPlayableLevels();
            const levelsToShow = maxLevel ? playableLevels.filter(level => level <= maxLevel) : playableLevels;
            
            // Add each level score
            for (const level of levelsToShow) {
                const score = game.levelScores[level];
                const levelItem = document.createElement('div');
                levelItem.className = 'level-score-item';
                
                // Highlight perfect scores or special achievements
                if (score >= 5) {
                    levelItem.classList.add('special');
                }
                
                // Determine score display based on context
                let scoreDisplay;
                if (score !== undefined) {
                    scoreDisplay = `${score} ‚ô•Ô∏è`;
                } else if (deathLevel && level === deathLevel) {
                    scoreDisplay = '‚ò†Ô∏è';
                } else if (deathLevel && level > deathLevel) {
                    scoreDisplay = '-';
                } else {
                    scoreDisplay = score || 0;
                    scoreDisplay = `${scoreDisplay} ‚ô•Ô∏è`;
                }
                
                levelItem.innerHTML = `
                    <div style="display: flex; align-items: center;">
                        <div class="level-wall-block" style="background-image: url('level-${level}/wall.png');"></div>
                        <div class="level-score-number">Level ${level}</div>
                    </div>
                    <div class="level-score-hearts">${scoreDisplay}</div>
                `;
                
                container.appendChild(levelItem);
            }
            
            // Add total score row
            const totalScore = Object.values(game.levelScores).reduce((sum, score) => sum + score, 0);
            const totalItem = document.createElement('div');
            totalItem.className = 'level-score-item';
            totalItem.style.borderTop = '2px solid #4CAF50';
            totalItem.style.marginTop = '10px';
            totalItem.style.fontWeight = 'bold';
            
            totalItem.innerHTML = `
                <div style="display: flex; align-items: center;">
                    <div class="level-score-number">Total</div>
                </div>
                <div class="level-score-hearts">${totalScore} ‚ô•Ô∏è</div>
            `;
            
            container.appendChild(totalItem);
        }
        
        function showFinalScore() {
            // Hide any other screens that might be showing
            document.getElementById('celebrationScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('levelSelectionScreen').style.display = 'none';
            
            // Use common component to generate level score display (all playable levels)
            generateLevelScoreDisplay();
            
            // Show the final score screen
            document.getElementById('finalScoreScreen').style.display = 'flex';
        }
        
        function restartFromFinalScore() {
            // Hide final score screen
            document.getElementById('finalScoreScreen').style.display = 'none';
            
            // Stop any celebration animations
            game.celebrating = false;
            document.getElementById('celebrationScreen').style.display = 'none';
            
            // Reset all game data including cumulative score
            game.levelScores = {};
            game.deathLevel = null;
            game.cumulativeScore = 0; // Reset cumulative score
            game.gameSession = {
                startTime: Date.now(),
                levelsCompleted: 0,
                totalScore: 0,
                completedLevels: new Set()
            };
            
            // Show character selection to start over
            showCharacterSelection();
        }
        
        function showGameOverScore() {
            // Hide game over screen
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Update the title
            document.getElementById('finalScoreTitle').textContent = 'Your Scores';
            
            // Use common component to generate level score display (all playable levels, with death level indicator)
            generateLevelScoreDisplay(null, game.deathLevel);
            
            // Change the button to "Try Again"
            const finalScoreBtn = document.getElementById('finalScoreBtn');
            finalScoreBtn.textContent = 'Try Again';
            finalScoreBtn.onclick = () => {
                // Hide final score screen and restart game
                document.getElementById('finalScoreScreen').style.display = 'none';
                restartGame();
                
                // Restore original title and button for future use
                document.getElementById('finalScoreTitle').textContent = 'üéâ Congratulations! üéâ';
                finalScoreBtn.textContent = 'Play Again';
                finalScoreBtn.onclick = restartFromFinalScore;
            };
            
            // Show the final score screen
            document.getElementById('finalScoreScreen').style.display = 'flex';
        }
        
        function animateCelebration() {
            if (!game.celebrating) return;
            
            const canvas = document.getElementById('celebrationSprite');
            const ctx = canvas.getContext('2d');
            
            if (currentCelebrationSprites.complete) {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Calculate frame properties using configuration-based approach
                const frameProps = calculateFrameProperties(currentCelebrationSprites, game.selectedDifficulty);
                const { frameWidth, frameHeight, framesPerRow, totalFrames } = frameProps;
                
                // Calculate frame position
                const row = Math.floor(game.celebrationFrame / framesPerRow);
                const col = game.celebrationFrame % framesPerRow;
                const frameX = col * frameWidth;
                const frameY = row * frameHeight;
                
                // Scale to fit canvas while maintaining aspect ratio
                const scaleX = canvas.width / frameWidth;
                const scaleY = canvas.height / frameHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9; // 90% of canvas size for padding
                
                const scaledWidth = frameWidth * scale;
                const scaledHeight = frameHeight * scale;
                const offsetX = (canvas.width - scaledWidth) / 2;
                const offsetY = (canvas.height - scaledHeight) / 2;
                
                // Draw current frame (scaled to fit)
                ctx.drawImage(
                    currentCelebrationSprites,
                    frameX, frameY, frameWidth, frameHeight, // Source frame
                    offsetX, offsetY, scaledWidth, scaledHeight // Destination (scaled and centered)
                );
                
                // Update frame counter using config-based delay
                game.celebrationTimer++;
                const animationConfig = configManager.getAnimationConfig(game.selectedDifficulty);
                const frameDelay = animationConfig.frameDelay || 25;
                if (game.celebrationTimer >= frameDelay) {
                    game.celebrationFrame = (game.celebrationFrame + 1) % totalFrames;
                    game.celebrationTimer = 0;
                }
            }
            
            requestAnimationFrame(animateCelebration);
        }
        
        function playAgain() {
            game.celebrating = false;
            document.getElementById('celebrationScreen').style.display = 'none';
            
            // Check if all levels are completed
            const totalPlayableLevels = configManager.getPlayableLevels().length;
            if (game.gameSession.completedLevels.size >= totalPlayableLevels) {
                // All levels completed, show final score
                console.log('All levels completed, showing final score');
                showFinalScore();
            } else {
                // Show level selection screen so player can choose next level
                console.log('Showing level selection for next level choice');
                showLevelSelection().catch(console.error);
            }
        }
        
        // Global function for character caught by ghost modal dismissal
        function dismissCharacterCaughtByGhost() {
            if (game.ghost) {
                game.ghost.dismissCharacterCaughtByGhost();
            }
        }
        
        // Global function for ghost defeated modal dismissal  
        function dismissGhostDefeated() {
            if (game.ghost) {
                game.ghost.dismissGhostDefeated();
            }
        }
        
        // Global function for character caught by ghost modal replay
        function replayCharacterCaughtByGhost() {
            if (game.ghost) {
                game.ghost.replayCharacterCaughtByGhost();
            }
        }
        
        // Global function for ghost defeated modal replay  
        function replayGhostDefeated() {
            if (game.ghost) {
                game.ghost.replayGhostDefeated();
            }
        }
        
        function showCelebration() {
            // If boost is active, end it properly
            if (game.rocketCountdown > 0 || game.boostTransitionState !== 'normal') {
                console.log('Level completed during boost - cleaning up boost state');
                game.hasBonus = false;
                game.rocketCountdown = 0;
                game.boostTransitionState = 'normal';
                currentMovementSprites = characterSprites.movement;
                updateRocketDisplay();
                
                // Remove boost visual effects
                const gameContainer = document.getElementById('gameContainer');
                gameContainer.classList.remove('rocket-boost', 'blinking');
            }
            
            // Record score for this level
            game.levelScores[game.selectedDifficulty] = game.score;
            game.gameSession.levelsCompleted++;
            game.gameSession.totalScore += game.score;
            
            // Mark level as completed
            game.gameSession.completedLevels.add(game.selectedDifficulty);
            
            console.log(`Level ${game.selectedDifficulty} completed with ${game.score} lives remaining`);
            
            game.celebrating = true;
            game.celebrationFrame = 0;
            game.celebrationTimer = 0;
            
            // Update button text - now always shows "Choose Next Level" unless all levels completed
            const playAgainBtn = document.getElementById('playAgainBtn');
            const totalPlayableLevels = configManager.getPlayableLevels().length;
            if (game.gameSession.completedLevels.size >= totalPlayableLevels) {
                playAgainBtn.textContent = 'Show Final Score';
            } else {
                playAgainBtn.textContent = 'Choose Next Level';
            }
            
            document.getElementById('celebrationScreen').style.display = 'flex';
            animateCelebration();
        }
        
        // Game loop
        function gameLoop() {
            // Update animation timer
            game.player.animTimer++;
            
            // Reset moving flag after a short time (creates a brief walking animation)
            if (game.player.isMoving && game.player.animTimer > 10) {
                game.player.isMoving = false;
                game.player.animTimer = 0;
            }
            
            // Update ghost if active
            if (game.ghost && game.ghost.isActive) {
                game.ghost.update(Date.now(), game);
            }
            
            if (!game.celebrating) {
                drawGame();
            }
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize character selection screen on game start
        // Character selection -> difficulty selection -> level selection -> game start
        document.addEventListener('DOMContentLoaded', () => {
            // Start the game loop
            gameLoop();
            
            // Force hide game screens initially, show character selection
            document.getElementById('difficultyScreen').style.display = 'none';
            document.getElementById('levelSelectionScreen').style.display = 'none';
            
            // Show character selection screen as the first screen
            showCharacterSelection();
        });
    </script>
</body>
</html>