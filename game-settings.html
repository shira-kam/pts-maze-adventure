<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customize Levels</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .settings-container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px 30px 0 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            position: relative;
            min-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #2d3748;
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .level-drawer {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
            transition: border-color 0.3s ease;
        }
        
        .level-drawer.open {
            border-color: #007bff;
            border-width: 2px;
        }
        
        .drawer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #e9ecef;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
        }
        
        .drawer-header:hover {
            background: #dee2e6;
        }
        
        .drawer-title-left {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }
        
        .drawer-title-right {
            color: #666;
            font-style: italic;
        }
        
        .chevron {
            transition: transform 0.3s ease;
            font-size: 14px;
            color: #666;
            font-weight: bold;
            display: inline-block;
            width: 0;
            height: 0;
            border-left: 8px solid #666;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            margin-left: 10px;
        }
        
        .chevron.open {
            transform: rotate(90deg);
            margin-left: 8px;
            margin-top: 2px;
        }
        
        .drawer-content {
            display: none;
            padding: 20px;
        }
        
        .drawer-content.open {
            display: block;
        }
        
        .section {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        
        .section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .radio-group {
            display: flex;
            gap: 15px;
        }
        
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
        }
        
        select, input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-group.operations {
            gap: 20px;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
        }
        
        .puzzle-config {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .puzzle-config.active {
            display: block;
        }
        
        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 20px;
        }

        .action-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            background: white;
            padding: 20px 30px;
            margin: 0 -30px 0 -30px;
            border-top: 1px solid #e0e0e0;
            border-radius: 0 0 20px 20px;
            box-shadow: 0 -4px 15px rgba(0,0,0,0.1);
            margin-top: auto;
        }
        
        .cancel-button, .apply-button {
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .cancel-button {
            background: #6c757d;
            color: white;
        }
        
        .cancel-button:hover {
            background: #545b62;
        }
        
        .apply-button {
            background: #28a745;
            color: white;
            box-shadow: 0 4px 12px rgba(40,167,69,0.3);
        }
        
        .apply-button:hover {
            background: #1e7e34;
        }
        
        .icon {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            display: inline-block;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: #ddd;
        }
        
        .number-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }
        
        /* ===== PUZZLE MODAL STYLES - EXACT replica from real game ===== */
        
        /* Puzzle button styling to match main game */
        .puzzle-button {
            margin: 10px 5px !important;
            padding: 10px 15px !important;
            border-radius: 8px !important;
            cursor: pointer !important;
            font-family: Arial, sans-serif !important;
            font-weight: bold !important;
            transition: all 0.2s ease !important;
        }
        
        .puzzle-button:hover {
            transform: scale(1.05) !important;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
        }
        
        .puzzle-button:disabled {
            opacity: 0.6 !important;
            cursor: not-allowed !important;
            transform: none !important;
        }
        
        /* Word emoji puzzle specific styling - only applied when class is present */
        #puzzleOptions.word-emoji-options {
            display: flex !important;
            flex-wrap: wrap !important;
            justify-content: center !important;
            align-items: center !important;
            gap: 10px !important;
            margin: 20px 0 !important;
        }
        
        /* Letter identification puzzle specific styling - only applied when class is present */
        #puzzleOptions.letter-identification-options {
            display: flex !important;
            flex-wrap: wrap !important;
            justify-content: center !important;
            align-items: center !important;
            gap: 10px !important;
            margin: 20px 0 !important;
        }
        
        #puzzleModal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.8) !important;
            z-index: 10000 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        #puzzleContent {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            width: 1000px; /* Increased to 1000px to fully accommodate number lines up to 20 */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center; /* Center all content like real game */
            /* Removed min-height to let content determine size */
        }
        
        #puzzleTitle {
            margin: 0 0 20px 0;
            font-size: 1.5em;
            color: black; /* Black text on white background like real game */
            text-align: center;
        }
        
        #puzzleQuestion {
            margin: 0 0 20px 0;
            text-align: center;
        }
        
        #puzzleOptions {
            margin: 20px 0;
            text-align: center;
        }
        
        #puzzleResult {
            margin: 20px 0;
            text-align: center; /* Center feedback like real game */
            font-size: 48px; /* Large emoji size */
        }
        
        #puzzlePreviewQuestion {
            font-size: 1.2em;
            color: #333;
            margin: 0;
            text-align: center;
        }
        
        #puzzlePreviewOptions {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-height: 200px;
        }
        
        #puzzlePreviewResult {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            min-height: 30px;
        }
        
        /* Preview mode indicator */
        #puzzlePreviewModal::before {
            content: "PUZZLE PREVIEW MODE";
            position: fixed;
            top: 20px;
            right: 20px;
            background: #007bff;
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10001;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }
        
        /* Responsive design - placeholder for future mobile support */
    </style>
</head>
<body>
    <div class="settings-container">
        <div class="header">
            <h1>Customize Levels</h1>
        </div>
        
        <div class="content-area">
            <div id="level-drawers">
                <!-- Level drawers will be generated here -->
            </div>
        </div>
        
        <div class="action-buttons" id="actionButtons">
            <button class="cancel-button" onclick="cancelAndReturnToCharacterSelection()">
                Cancel
            </button>
            <button class="apply-button" onclick="applyConfigAndStartGame()">
                Apply to Game
            </button>
        </div>
    </div>

    <!-- Puzzle Modal - EXACT replica from real game -->
    <div id="puzzleModal" style="display: none !important;">
        <div id="puzzleContent">
            <h2 id="puzzleTitle">Puzzle Time!</h2>
            <p id="puzzleQuestion"></p>
            <div id="puzzleOptions"></div>
            <div id="puzzleResult"></div>
        </div>
    </div>

    <script src="preset-manager.js"></script>
    
    <!-- Include puzzle scripts for preview functionality -->
    <script src="simple-math-puzzle.js"></script>
    <script src="word-emoji-puzzle.js"></script>
    <script src="digraph-puzzle.js"></script>
    <script src="number-line-puzzle.js"></script>
    <script src="division-puzzle.js"></script>
    <script src="multiplication-groups-puzzle.js"></script>
    <script src="letter-identification.js"></script>
    <script src="audio-reading-puzzle.js"></script>
    <!-- Note: rhyming puzzle doesn't have separate JS file - integrated in main game -->
    
    <script>
        let gameConfig = {};
        let currentConfig = {};
        
        // Available puzzle types
        const puzzleTypes = [
            { value: 'word_emoji_matching', label: 'Word Emoji Matching' },
            { value: 'simple_arithmetic', label: 'Simple Math (A+B=?)' },
            { value: 'digraph_sounds', label: 'Digraph Matching' },
            { value: 'number_line', label: 'Number Line (A+B+C=?)' },
            { value: 'division_visual', label: 'Division puzzle (A:B=?)' },
            { value: 'multiplication_groups', label: 'Multiplication puzzle (AxB=?)' },
            { value: 'letter_identification', label: 'Letter Identification' },
            { value: 'audio_reading', label: 'Audio Reading' },
            { value: 'rhyming', label: 'Rhyming Sounds' }
        ];
        
        // Available digraphs from digraph-sounds.txt
        const availableDigraphs = ['CH', 'SH', 'TH', 'WH', 'PH', 'BL', 'CL', 'FL', 'GL', 'PL', 'SL', 'SC', 'SK', 'SM', 'SN', 'SP', 'ST', 'BR', 'CR', 'DR', 'FR', 'GR', 'PR', 'TR'];
        
        // Word list levels
        const wordListLevels = [
            { value: 'beginner', label: 'Beginner' },
            { value: 'intermediate', label: 'Intermediate' },
            { value: 'advanced', label: 'Advanced' }
        ];
        
        // Available audio reading word lists (will be populated dynamically)
        let availableWordLists = [];
        
        // Load preset as base configuration for customization
        async function loadPresetAsBase(presetId) {
            try {
                // Load preset manager if not already loaded
                await presetManager.loadBaseConfig();
                await presetManager.loadAvailablePresets();
                
                // Get preset from parameter or session
                const targetPresetId = presetId || presetManager.getBasePresetFromSession()?.id;
                
                if (targetPresetId) {
                    const mergedConfig = presetManager.applyPreset(targetPresetId);
                    if (mergedConfig) {
                        // Use merged config as base instead of default
                        gameConfig = mergedConfig;
                        currentConfig = JSON.parse(JSON.stringify(mergedConfig));
                        
                        const preset = presetManager.getCurrentPreset();
                        console.log(`Loaded preset as base: ${preset.name}`);
                        
                        // Add indicator that we're customizing a preset
                        const header = document.querySelector('h1');
                        if (header) {
                            header.innerHTML = `Customize Levels<br><small style="color: #666; font-size: 0.6em;">Based on: ${preset.name}</small>`;
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to load preset as base:', error);
                // Continue with default configuration
            }
        }
        
        // Initialize the page
        async function initializePage() {
            // Preload PT sprite for preview functionality
            if (!window.currentMovementSprites) {
                window.currentMovementSprites = new Image();
                window.currentMovementSprites.src = 'PT-sprite.svg';
                console.log('Preloading PT sprite for preview');
            }
            
            await loadGameConfig();
            await discoverWordLists();
            
            // Check if we're being called from character selection with specific character
            const urlParams = new URLSearchParams(window.location.search);
            const selectedCharacter = urlParams.get('character');
            const presetId = urlParams.get('preset');
            
            if (selectedCharacter) {
                // Store the selected character for when we return to the game
                sessionStorage.setItem('selectedCharacter', selectedCharacter);
            }
            
            // Check for preset to load as base configuration
            if (presetId || presetManager.getBasePresetFromSession()) {
                await loadPresetAsBase(presetId);
            }
            
            generateLevelDrawers();
        }
        
        // Dynamically discover available word lists from the audio-reading directory
        async function discoverWordLists() {
            availableWordLists = [];
            
            try {
                // Fetch the directory listing page to parse available files
                const response = await fetch('word-lists/audio-reading/');
                if (response.ok) {
                    const html = await response.text();
                    
                    // Parse HTML to find all .txt files
                    const linkPattern = /href="([^"]*\.txt)"/g;
                    
                    let match;
                    while ((match = linkPattern.exec(html)) !== null) {
                        const filename = match[1];
                        // Extract the word list name (remove ".txt")
                        const listName = filename.replace('.txt', '');
                        
                        // Convert filename to display name
                        const displayName = listName
                            .split('-')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                        
                        availableWordLists.push({
                            value: listName,
                            label: `${displayName} words`
                        });
                        console.log(`Found word list: ${listName} (${filename})`);
                    }
                }
            } catch (error) {
                console.warn('Could not fetch directory listing, falling back to file testing method');
                
                // Fallback: Try to fetch a few common word list files individually
                const commonWordLists = ['basic-magic-e', 'advanced-magic-e', 'silent-e', 'cvc'];
                for (const listName of commonWordLists) {
                    try {
                        const url = `word-lists/audio-reading/${listName}.txt`;
                        const response = await fetch(url, { method: 'HEAD' });
                        if (response.ok) {
                            const displayName = listName
                                .split('-')
                                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                .join(' ');
                            
                            availableWordLists.push({
                                value: listName,
                                label: `${displayName} words`
                            });
                            console.log(`Found word list: ${listName}`);
                        }
                    } catch (error) {
                        // Silently continue if file doesn't exist
                    }
                }
            }
            
            // If no word lists found, add a fallback
            if (availableWordLists.length === 0) {
                availableWordLists.push({
                    value: 'basic-magic-e',
                    label: 'Basic Magic E words (fallback)'
                });
            }
            
            console.log('Available word lists:', availableWordLists);
        }
        
        // Load the current game configuration dynamically
        async function loadGameConfig() {
            try {
                // Fetch the live game-config.json file
                console.log('Loading live game configuration...');
                const response = await fetch('game-config.json');
                
                if (response.ok) {
                    gameConfig = await response.json();
                    console.log('✅ Successfully loaded live game config from game-config.json');
                    console.log(`Found ${Object.keys(gameConfig.levels || {}).length} levels in config`);
                } else {
                    throw new Error(`Failed to fetch game-config.json: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.warn('⚠️ Failed to load live game-config.json, using fallback embedded config');
                console.error('Config loading error:', error);
                
                // Fallback to basic embedded config for emergency use
                gameConfig = {
                    "puzzles": {
                        "word_emoji_matching": {
                            "tracking": {
                                "preventRepetition": true,
                                "usedWords": [],
                                "trackingScope": "level"
                            }
                        },
                        "number_line": {
                            "operations": ["addition", "subtraction"],
                            "numberLine": {
                                "length": 12,
                                "minA": 1,
                                "maxA": 8,
                                "minB": 1,
                                "maxB": 8,
                                "maxResult": 12
                            },
                            "tracking": {
                                "preventRepetition": true,
                                "maxAttempts": 3,
                                "trackingScope": "level"
                            }
                        },
                        "letter_identification": {
                            "tracking": {
                                "preventRepetition": true,
                                "maxAttempts": 3,
                                "trackingScope": "level"
                            }
                        },
                        "rhyming": {
                            "tracking": {
                                "preventRepetition": true,
                                "maxAttempts": 3,
                                "trackingScope": "level"
                            }
                        }
                    },
                    "levels": {
                        "1": {
                            "playable": true,
                            "puzzles": [
                                {
                                    "type": "number_line",
                                    "operations": ["addition"],
                                    "numberLine": {
                                        "length": 10,
                                        "minA": 1,
                                        "maxA": 9,
                                        "minB": 1,
                                        "maxB": 9,
                                        "maxResult": 10
                                    }
                                }
                            ]
                        }
                    },
                    "characters": {
                        "PT": {
                            "name": "PT the Elephant",
                            "movement": "PT-sprite.svg",
                            "celebration": "PT-celebrate.png",
                            "gameOver": "PT-game-over.png"
                        }
                    }
                };
            }
            
            // Create working copy for modifications
            currentConfig = JSON.parse(JSON.stringify(gameConfig));
        }
        
        // Generate level drawer components
        function generateLevelDrawers() {
            const container = document.getElementById('level-drawers');
            container.innerHTML = '';
            
            // Sort levels numerically
            const levelNumbers = Object.keys(gameConfig.levels || {}).sort((a, b) => parseInt(a) - parseInt(b));
            
            levelNumbers.forEach(levelNum => {
                const levelConfig = gameConfig.levels[levelNum];
                const drawer = createLevelDrawer(levelNum, levelConfig);
                container.appendChild(drawer);
            });
        }
        
        // Create a single level drawer
        function createLevelDrawer(levelNum, levelConfig) {
            const drawer = document.createElement('div');
            drawer.className = 'level-drawer';
            drawer.id = `level-${levelNum}`;
            
            // Determine puzzle names for display
            let puzzleDisplay = 'Not playable';
            if (levelConfig.playable && levelConfig.puzzles && levelConfig.puzzles.length > 0) {
                const puzzleNames = levelConfig.puzzles.map(p => {
                    const puzzleType = puzzleTypes.find(pt => pt.value === p.type);
                    return puzzleType ? puzzleType.label : p.type;
                });
                puzzleDisplay = puzzleNames.join(' & ');
            }
            
            drawer.innerHTML = `
                <div class="drawer-header" onclick="toggleDrawer(${levelNum})">
                    <div class="drawer-title-left">
                        <span class="icon" style="background-image: url('level-${levelNum}/wall.png')"></span>
                        Level ${levelNum}
                        <span class="chevron" id="chevron-${levelNum}"></span>
                    </div>
                    <div class="drawer-title-right" id="puzzle-display-${levelNum}">
                        ${puzzleDisplay}
                    </div>
                </div>
                <div class="drawer-content" id="content-${levelNum}">
                    ${generateDrawerContent(levelNum, levelConfig)}
                </div>
            `;
            
            return drawer;
        }
        
        // Generate the content inside a drawer
        function generateDrawerContent(levelNum, levelConfig) {
            const isPlayable = levelConfig.playable || false;
            const puzzles = levelConfig.puzzles || [];
            
            let content = `
                <div class="section">
                    <h3>Playable</h3>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="playable-${levelNum}" value="true" 
                                   ${isPlayable ? 'checked' : ''} 
                                   onchange="updatePlayableStatus(${levelNum}, true)">
                            Yes
                        </label>
                        <label>
                            <input type="radio" name="playable-${levelNum}" value="false" 
                                   ${!isPlayable ? 'checked' : ''}
                                   onchange="updatePlayableStatus(${levelNum}, false)">
                            No
                        </label>
                    </div>
                </div>
            `;
            
            // Add puzzle sections
            for (let i = 0; i < 2; i++) {
                const puzzleNum = i + 1;
                const puzzle = puzzles[i] || { type: '', config: {} };
                const sectionClass = !isPlayable ? 'section disabled' : 'section';
                
                content += `
                    <div class="${sectionClass}" id="puzzle-section-${levelNum}-${puzzleNum}">
                        <h3>
                            <span class="icon" style="background-image: url('level-${levelNum}/obstacle${puzzleNum}.png')"></span>
                            Puzzle ${puzzleNum}
                        </h3>
                        <div class="form-group">
                            <label>Select puzzle:</label>
                            <select id="puzzle-select-${levelNum}-${puzzleNum}" 
                                    onchange="updatePuzzleType(${levelNum}, ${puzzleNum}, this.value)"
                                    ${!isPlayable ? 'disabled' : ''}>
                                <option value="">-- Select Puzzle --</option>
                                ${puzzleTypes.map(pt => 
                                    `<option value="${pt.value}" ${pt.value === puzzle.type ? 'selected' : ''}>${pt.label}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="puzzle-config ${puzzle.type ? 'active' : ''}" id="config-${levelNum}-${puzzleNum}">
                            ${puzzle.type ? generatePuzzleConfig(levelNum, puzzleNum, puzzle.type, puzzle) : ''}
                        </div>
                    </div>
                `;
                
                // Hide second puzzle section if level only has one puzzle
                if (i === 1 && puzzles.length < 2) {
                    content = content.replace(`puzzle-section-${levelNum}-${puzzleNum}"`, `puzzle-section-${levelNum}-${puzzleNum}" style="display: none;"`);
                }
            }
            
            return content;
        }
        
        // Generate puzzle-specific configuration forms
        function generatePuzzleConfig(levelNum, puzzleNum, puzzleType, puzzleData) {
            switch (puzzleType) {
                case 'word_emoji_matching':
                    return generateWordEmojiConfig(levelNum, puzzleNum, puzzleData);
                case 'simple_arithmetic':
                    return generateSimpleMathConfig(levelNum, puzzleNum, puzzleData);
                case 'digraph_sounds':
                    return generateDigraphConfig(levelNum, puzzleNum, puzzleData);
                case 'number_line':
                    return generateNumberLineConfig(levelNum, puzzleNum, puzzleData);
                case 'division_visual':
                    return generateDivisionConfig(levelNum, puzzleNum, puzzleData);
                case 'multiplication_groups':
                    return generateMultiplicationConfig(levelNum, puzzleNum, puzzleData);
                case 'letter_identification':
                    return generateLetterIdConfig(levelNum, puzzleNum, puzzleData);
                case 'audio_reading':
                    return generateAudioReadingConfig(levelNum, puzzleNum, puzzleData);
                case 'rhyming':
                    return generateRhymingConfig(levelNum, puzzleNum, puzzleData);
                default:
                    return '';
            }
        }
        
        function generateWordEmojiConfig(levelNum, puzzleNum, puzzleData) {
            const wordListLevel = puzzleData.wordListLevel || 'beginner';
            
            return `
                <div class="form-group">
                    <label>Word List Level:</label>
                    <select id="wordListLevel-${levelNum}-${puzzleNum}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                        ${wordListLevels.map(wl => 
                            `<option value="${wl.value}" ${wl.value === wordListLevel ? 'selected' : ''}>${wl.label}</option>`
                        ).join('')}
                    </select>
                </div>
            `;
        }
        
        function generateSimpleMathConfig(levelNum, puzzleNum, puzzleData) {
            const operations = puzzleData.operations || ['addition'];
            const limits = puzzleData.limits || {};
            
            return `
                <div class="form-group">
                    <label>Operations:</label>
                    <div class="checkbox-group operations">
                        <label>
                            <input type="checkbox" value="addition" ${operations.includes('addition') ? 'checked' : ''}
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                            Addition
                        </label>
                        <label>
                            <input type="checkbox" value="subtraction" ${operations.includes('subtraction') ? 'checked' : ''}
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                            Subtraction
                        </label>
                    </div>
                </div>
                <div class="number-inputs">
                    <div class="form-group">
                        <label>Max A:</label>
                        <input type="number" id="maxA-${levelNum}-${puzzleNum}" value="${limits.maxA || 10}" 
                               min="1" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max B:</label>
                        <input type="number" id="maxB-${levelNum}-${puzzleNum}" value="${limits.maxB || 10}" 
                               min="1" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max Result:</label>
                        <input type="number" id="maxResult-${levelNum}-${puzzleNum}" value="${limits.maxResult || 12}" 
                               min="1" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                </div>
            `;
        }
        
        function generateDigraphConfig(levelNum, puzzleNum, puzzleData) {
            const selectedDigraphs = puzzleData.digraphs || [];
            
            return `
                <div class="form-group">
                    <label>Digraphs:</label>
                    <div class="checkbox-group">
                        ${availableDigraphs.map(digraph => `
                            <label>
                                <input type="checkbox" value="${digraph}" 
                                       name="digraphs-${levelNum}-${puzzleNum}"
                                       ${selectedDigraphs.includes(digraph) ? 'checked' : ''}
                                       onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                                ${digraph}
                            </label>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        function generateNumberLineConfig(levelNum, puzzleNum, puzzleData) {
            const operations = puzzleData.operations || ['addition'];
            const numberLine = puzzleData.numberLine || {};
            const terms = numberLine.terms || '2';
            
            return `
                <div class="form-group">
                    <label>Operations:</label>
                    <div class="checkbox-group operations">
                        <label>
                            <input type="checkbox" value="addition" ${operations.includes('addition') ? 'checked' : ''}
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                            Addition
                        </label>
                        <label>
                            <input type="checkbox" value="subtraction" ${operations.includes('subtraction') ? 'checked' : ''}
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                            Subtraction
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label>Number of Terms:</label>
                    <div class="radio-group terms">
                        <label>
                            <input type="radio" name="terms-${levelNum}-${puzzleNum}" value="2" ${terms === '2' ? 'checked' : ''}
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum}); toggleTripleInputs(${levelNum}, ${puzzleNum})">
                            2 terms (A+B and/or A-B)
                        </label>
                        <label>
                            <input type="radio" name="terms-${levelNum}-${puzzleNum}" value="3" ${terms === '3' ? 'checked' : ''}
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum}); toggleTripleInputs(${levelNum}, ${puzzleNum})">
                            3 terms (A+B+C, and/or A-B-C, and/or A-B+C etc)
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label>Length of Number Line:</label>
                    <input type="number" id="length-${levelNum}-${puzzleNum}" value="${numberLine.length || 12}" 
                           min="5" max="20" 
                           onchange="updateNumberLineValidation(${levelNum}, ${puzzleNum}); updatePuzzleConfig(${levelNum}, ${puzzleNum})"
                           onblur="updateNumberLineValidation(${levelNum}, ${puzzleNum}); updatePuzzleConfig(${levelNum}, ${puzzleNum})"
                           oninput="if(this.value > 20) this.value = 20; if(this.value < 5 && this.value !== '') this.value = 5;">
                </div>
                <div class="number-inputs">
                    <div class="form-group">
                        <label>Min A:</label>
                        <input type="number" id="minA-${levelNum}-${puzzleNum}" value="${numberLine.minA || 1}" 
                               min="0" max="${numberLine.length || 12}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max A:</label>
                        <input type="number" id="maxA-${levelNum}-${puzzleNum}" value="${numberLine.maxA || 8}" 
                               min="0" max="${numberLine.length || 12}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Min B:</label>
                        <input type="number" id="minB-${levelNum}-${puzzleNum}" value="${numberLine.minB || 1}" 
                               min="0" max="${numberLine.length || 12}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max B:</label>
                        <input type="number" id="maxB-${levelNum}-${puzzleNum}" value="${numberLine.maxB || 8}" 
                               min="0" max="${numberLine.length || 12}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max Result:</label>
                        <input type="number" id="maxResult-${levelNum}-${puzzleNum}" value="${numberLine.maxResult || 12}" 
                               min="5" max="${numberLine.length || 12}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                </div>
                <div class="number-inputs" id="triple-inputs-${levelNum}-${puzzleNum}" style="display: ${terms === '3' ? 'grid' : 'none'}">
                    <div class="form-group">
                        <label>Min C:</label>
                        <input type="number" id="minC-${levelNum}-${puzzleNum}" value="${numberLine.minC || 1}" 
                               min="0" max="${numberLine.length || 12}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max C:</label>
                        <input type="number" id="maxC-${levelNum}-${puzzleNum}" value="${numberLine.maxC || 4}" 
                               min="0" max="${numberLine.length || 12}" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                </div>
            `;
        }
        
        function generateDivisionConfig(levelNum, puzzleNum, puzzleData) {
            const division = puzzleData.division || {};
            
            return `
                <div class="number-inputs">
                    <div class="form-group">
                        <label>Max A:</label>
                        <input type="number" id="maxA-${levelNum}-${puzzleNum}" value="${division.maxA || 12}" 
                               min="12" 
                               onchange="updateDivisionValidation(${levelNum}, ${puzzleNum}); updatePuzzleConfig(${levelNum}, ${puzzleNum})"
                               onblur="updateDivisionValidation(${levelNum}, ${puzzleNum}); updatePuzzleConfig(${levelNum}, ${puzzleNum})"
                               oninput="if(this.value < 12 && this.value !== '') this.value = 12;">
                    </div>
                    <div class="form-group">
                        <label>Max B:</label>
                        <input type="number" id="maxB-${levelNum}-${puzzleNum}" value="${division.maxB || 10}" 
                               min="1" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max Answer:</label>
                        <input type="number" id="maxAnswer-${levelNum}-${puzzleNum}" value="${division.maxAnswer || 10}" 
                               min="1" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="excludeIdentity-${levelNum}-${puzzleNum}" 
                               ${division.excludeIdentity !== false ? 'checked' : ''} onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                        Exclude Identity (A ÷ A)
                    </label>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="excludeA1-${levelNum}-${puzzleNum}" 
                               ${division.excludeA1 !== false ? 'checked' : ''} onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                        Exclude A = 1
                    </label>
                </div>
            `;
        }
        
        function generateMultiplicationConfig(levelNum, puzzleNum, puzzleData) {
            const multiplication = puzzleData.multiplication || {};
            
            return `
                <div class="number-inputs">
                    <div class="form-group">
                        <label>Max Answer:</label>
                        <input type="number" id="maxProduct-${levelNum}-${puzzleNum}" value="${multiplication.maxProduct || 20}" 
                               min="1" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Min A:</label>
                        <input type="number" id="minFactor-${levelNum}-${puzzleNum}" value="${multiplication.minFactor || 2}" 
                               min="1" max="10" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                    <div class="form-group">
                        <label>Max B:</label>
                        <input type="number" id="maxFactor-${levelNum}-${puzzleNum}" value="${multiplication.maxFactor || 10}" 
                               min="1" max="10" onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                    </div>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="excludeOne-${levelNum}-${puzzleNum}" 
                               ${multiplication.excludeOne !== false ? 'checked' : ''} onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                        Exclude One
                    </label>
                </div>
            `;
        }
        
        function generateLetterIdConfig(levelNum, puzzleNum, puzzleData) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            const excludedLetters = puzzleData.excludeLetters || [];
            
            return `
                <div class="form-group">
                    <label>Exclude letters:</label>
                    <div class="checkbox-group">
                        ${alphabet.map(letter => `
                            <label>
                                <input type="checkbox" value="${letter}" 
                                       ${excludedLetters.includes(letter) ? 'checked' : ''}
                                       onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                                ${letter}
                            </label>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        function generateAudioReadingConfig(levelNum, puzzleNum, puzzleData) {
            const mode = puzzleData.mode || 'match_speech_to_text';
            const selectedWordLists = puzzleData.wordLists || ['basic-magic-e'];
            
            return `
                <div class="form-group">
                    <label>Mode:</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="mode-${levelNum}-${puzzleNum}" value="match_speech_to_text" 
                                   ${mode === 'match_speech_to_text' ? 'checked' : ''} 
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                            Match Speech to Text
                        </label>
                        <label>
                            <input type="radio" name="mode-${levelNum}-${puzzleNum}" value="match_text_to_speech" 
                                   ${mode === 'match_text_to_speech' ? 'checked' : ''} 
                                   onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                            Match Text to Speech
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label>Word Lists:</label>
                    <div class="checkbox-group">
                        ${availableWordLists.map(wordList => `
                            <label>
                                <input type="checkbox" value="${wordList.value}" 
                                       ${selectedWordLists.includes(wordList.value) ? 'checked' : ''}
                                       onchange="updatePuzzleConfig(${levelNum}, ${puzzleNum})">
                                ${wordList.label}
                            </label>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function generateRhymingConfig(levelNum, puzzleNum, puzzleData) {
            return ``;
        }
        
        // Event handlers
        function toggleDrawer(levelNum) {
            const drawer = document.getElementById(`level-${levelNum}`);
            const content = document.getElementById(`content-${levelNum}`);
            const chevron = document.getElementById(`chevron-${levelNum}`);
            
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                drawer.classList.remove('open');
                chevron.classList.remove('open');
            } else {
                content.classList.add('open');
                drawer.classList.add('open');
                chevron.classList.add('open');
            }
        }
        
        function updatePlayableStatus(levelNum, isPlayable) {
            const puzzle1Section = document.getElementById(`puzzle-section-${levelNum}-1`);
            const puzzle2Section = document.getElementById(`puzzle-section-${levelNum}-2`);
            const puzzleDisplay = document.getElementById(`puzzle-display-${levelNum}`);
            
            if (isPlayable) {
                puzzle1Section.classList.remove('disabled');
                puzzle2Section.classList.remove('disabled');
                puzzle1Section.querySelectorAll('input, select').forEach(el => el.disabled = false);
                puzzle2Section.querySelectorAll('input, select').forEach(el => el.disabled = false);
            } else {
                puzzle1Section.classList.add('disabled');
                puzzle2Section.classList.add('disabled');
                puzzle1Section.querySelectorAll('input, select').forEach(el => el.disabled = true);
                puzzle2Section.querySelectorAll('input, select').forEach(el => el.disabled = true);
                puzzleDisplay.textContent = 'Not playable';
            }
            
            // Update config
            if (!currentConfig.levels[levelNum]) {
                currentConfig.levels[levelNum] = {};
            }
            currentConfig.levels[levelNum].playable = isPlayable;
            
            if (!isPlayable) {
                currentConfig.levels[levelNum].puzzles = [];
            }
            
            updatePuzzleDisplay(levelNum);
        }
        
        function updatePuzzleType(levelNum, puzzleNum, puzzleType) {
            const configDiv = document.getElementById(`config-${levelNum}-${puzzleNum}`);
            
            if (puzzleType) {
                configDiv.classList.add('active');
                configDiv.innerHTML = generatePuzzleConfig(levelNum, puzzleNum, puzzleType, {});
            } else {
                configDiv.classList.remove('active');
                configDiv.innerHTML = '';
            }
            
            // Show/hide second puzzle section based on selection
            const puzzle2Section = document.getElementById(`puzzle-section-${levelNum}-2`);
            if (puzzleNum === 1) {
                if (puzzleType) {
                    puzzle2Section.style.display = 'block';
                } else {
                    puzzle2Section.style.display = 'none';
                    // Clear second puzzle if first is cleared
                    document.getElementById(`puzzle-select-${levelNum}-2`).value = '';
                    document.getElementById(`config-${levelNum}-2`).innerHTML = '';
                    document.getElementById(`config-${levelNum}-2`).classList.remove('active');
                }
            }
            
            updatePuzzleConfig(levelNum, puzzleNum);
            updatePuzzleDisplay(levelNum);
        }
        
        function updatePuzzleConfig(levelNum, puzzleNum) {
            // Get current puzzle type
            const puzzleSelect = document.getElementById(`puzzle-select-${levelNum}-${puzzleNum}`);
            const puzzleType = puzzleSelect ? puzzleSelect.value : '';
            
            if (!puzzleType) return;
            
            // Initialize level config if needed
            if (!currentConfig.levels[levelNum]) {
                currentConfig.levels[levelNum] = { playable: true, puzzles: [] };
            }
            
            // Ensure puzzles array has enough elements
            while (currentConfig.levels[levelNum].puzzles.length < puzzleNum) {
                currentConfig.levels[levelNum].puzzles.push({ type: '', config: {} });
            }
            
            // Update puzzle config based on type
            const puzzleConfig = { type: puzzleType };
            
            switch (puzzleType) {
                case 'word_emoji_matching':
                    const wordListLevel = document.getElementById(`wordListLevel-${levelNum}-${puzzleNum}`)?.value || 'beginner';
                    
                    puzzleConfig.wordListLevel = wordListLevel;
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        usedWords: [],
                        trackingScope: "level"
                    };
                    break;
                    
                case 'simple_arithmetic':
                    const operations = Array.from(document.querySelectorAll(`#config-${levelNum}-${puzzleNum} input[type="checkbox"]:checked`))
                        .map(cb => cb.value).filter(v => ['addition', 'subtraction'].includes(v));
                    const maxA = parseInt(document.getElementById(`maxA-${levelNum}-${puzzleNum}`)?.value) || 10;
                    const maxB = parseInt(document.getElementById(`maxB-${levelNum}-${puzzleNum}`)?.value) || 10;
                    const maxResult = parseInt(document.getElementById(`maxResult-${levelNum}-${puzzleNum}`)?.value) || 12;
                    
                    puzzleConfig.operations = operations;
                    puzzleConfig.limits = { maxA, maxB, maxResult };
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        maxAttempts: 3,
                        trackingScope: "level"
                    };
                    break;
                    
                case 'digraph_sounds':
                    const selectedDigraphs = Array.from(document.querySelectorAll(`#config-${levelNum}-${puzzleNum} input[type="checkbox"]:checked`))
                        .map(cb => cb.value).filter(v => availableDigraphs.includes(v));
                    
                    puzzleConfig.digraphs = selectedDigraphs;
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        usedDigraphs: [],
                        trackingScope: "level"
                    };
                    break;
                    
                case 'number_line':
                    const nlOperations = Array.from(document.querySelectorAll(`#config-${levelNum}-${puzzleNum} input[type="checkbox"]:checked`))
                        .map(cb => cb.value).filter(v => ['addition', 'subtraction'].includes(v));
                    const terms = document.querySelector(`#config-${levelNum}-${puzzleNum} input[name="terms-${levelNum}-${puzzleNum}"]:checked`)?.value || '2';
                    const length = parseInt(document.getElementById(`length-${levelNum}-${puzzleNum}`)?.value) || 12;
                    const minA = parseInt(document.getElementById(`minA-${levelNum}-${puzzleNum}`)?.value) || 1;
                    const maxANL = parseInt(document.getElementById(`maxA-${levelNum}-${puzzleNum}`)?.value) || 8;
                    const minB = parseInt(document.getElementById(`minB-${levelNum}-${puzzleNum}`)?.value) || 1;
                    const maxBNL = parseInt(document.getElementById(`maxB-${levelNum}-${puzzleNum}`)?.value) || 8;
                    const maxResultNL = parseInt(document.getElementById(`maxResult-${levelNum}-${puzzleNum}`)?.value) || 12;
                    
                    puzzleConfig.operations = nlOperations;
                    puzzleConfig.numberLine = { 
                        operations: nlOperations,
                        terms: terms,
                        length, 
                        minA, 
                        maxA: maxANL, 
                        minB, 
                        maxB: maxBNL, 
                        maxResult: maxResultNL 
                    };
                    
                    if (terms === '3') {
                        const minC = parseInt(document.getElementById(`minC-${levelNum}-${puzzleNum}`)?.value) || 1;
                        const maxC = parseInt(document.getElementById(`maxC-${levelNum}-${puzzleNum}`)?.value) || 4;
                        puzzleConfig.numberLine.minC = minC;
                        puzzleConfig.numberLine.maxC = maxC;
                    }
                    
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        maxAttempts: 3,
                        trackingScope: "level"
                    };
                    break;
                    
                case 'division_visual':
                    const maxADiv = parseInt(document.getElementById(`maxA-${levelNum}-${puzzleNum}`)?.value) || 12;
                    const maxBDiv = parseInt(document.getElementById(`maxB-${levelNum}-${puzzleNum}`)?.value) || 10;
                    const maxAnswer = parseInt(document.getElementById(`maxAnswer-${levelNum}-${puzzleNum}`)?.value) || 10;
                    const excludeIdentity = document.getElementById(`excludeIdentity-${levelNum}-${puzzleNum}`)?.checked !== false;
                    const excludeA1 = document.getElementById(`excludeA1-${levelNum}-${puzzleNum}`)?.checked !== false;
                    
                    puzzleConfig.division = { 
                        maxA: maxADiv, 
                        maxB: maxBDiv, 
                        maxAnswer, 
                        excludeIdentity, 
                        excludeA1 
                    };
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        trackingScope: "level"
                    };
                    break;
                    
                case 'multiplication_groups':
                    const maxProduct = parseInt(document.getElementById(`maxProduct-${levelNum}-${puzzleNum}`)?.value) || 20;
                    const minFactor = parseInt(document.getElementById(`minFactor-${levelNum}-${puzzleNum}`)?.value) || 2;
                    const maxFactor = parseInt(document.getElementById(`maxFactor-${levelNum}-${puzzleNum}`)?.value) || 10;
                    const excludeOne = document.getElementById(`excludeOne-${levelNum}-${puzzleNum}`)?.checked !== false;
                    
                    puzzleConfig.operations = ["multiplication"];
                    puzzleConfig.multiplication = { 
                        maxProduct, 
                        minFactor, 
                        maxFactor, 
                        excludeOne 
                    };
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        maxAttempts: 3,
                        trackingScope: "level"
                    };
                    break;
                    
                case 'letter_identification':
                    const excludedLetters = Array.from(document.querySelectorAll(`#config-${levelNum}-${puzzleNum} input[type="checkbox"]:checked`))
                        .map(cb => cb.value);
                    
                    if (excludedLetters.length > 0) {
                        puzzleConfig.excludeLetters = excludedLetters;
                    }
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        usedLetters: [],
                        trackingScope: "level"
                    };
                    break;
                    
                case 'audio_reading':
                    const selectedMode = document.querySelector(`input[name="mode-${levelNum}-${puzzleNum}"]:checked`)?.value || 'match_speech_to_text';
                    const selectedWordLists = Array.from(document.querySelectorAll(`#config-${levelNum}-${puzzleNum} input[type="checkbox"]:checked`))
                        .map(cb => cb.value);
                    
                    puzzleConfig.mode = selectedMode;
                    puzzleConfig.wordLists = selectedWordLists.length > 0 ? selectedWordLists : (availableWordLists.length > 0 ? [availableWordLists[0].value] : ['basic-magic-e']);
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        maxAttempts: 3,
                        trackingScope: "level"
                    };
                    break;
                    
                case 'rhyming':
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        maxAttempts: 3,
                        trackingScope: "level"
                    };
                    break;
            }
            
            currentConfig.levels[levelNum].puzzles[puzzleNum - 1] = puzzleConfig;
            updatePuzzleDisplay(levelNum);
        }
        
        function toggleTripleInputs(levelNum, puzzleNum) {
            const termsRadio = document.querySelector(`input[name="terms-${levelNum}-${puzzleNum}"]:checked`);
            const tripleInputs = document.getElementById(`triple-inputs-${levelNum}-${puzzleNum}`);
            
            if (termsRadio && termsRadio.value === '3') {
                tripleInputs.style.display = 'grid';
            } else {
                tripleInputs.style.display = 'none';
            }
        }
        
        function updatePuzzleDisplay(levelNum) {
            const puzzleDisplay = document.getElementById(`puzzle-display-${levelNum}`);
            const levelConfig = currentConfig.levels[levelNum];
            
            if (!levelConfig || !levelConfig.playable) {
                puzzleDisplay.textContent = 'Not playable';
                return;
            }
            
            const puzzles = levelConfig.puzzles || [];
            if (puzzles.length === 0) {
                puzzleDisplay.textContent = 'No puzzles configured';
                return;
            }
            
            const puzzleNames = puzzles
                .filter(p => p.type)
                .map(p => {
                    const puzzleType = puzzleTypes.find(pt => pt.value === p.type);
                    return puzzleType ? puzzleType.label : p.type;
                });
                
            puzzleDisplay.textContent = puzzleNames.join(' & ') || 'No puzzles configured';
        }
        
        function generateFinalConfig() {
            // Merge with original config to preserve all other settings
            const finalConfig = JSON.parse(JSON.stringify(gameConfig));
            
            // Update only the levels that were modified
            Object.keys(currentConfig.levels).forEach(levelNum => {
                if (!finalConfig.levels) finalConfig.levels = {};
                finalConfig.levels[levelNum] = {
                    ...finalConfig.levels[levelNum],
                    ...currentConfig.levels[levelNum]
                };
            });
            
            return finalConfig;
        }
        
        function cancelAndReturnToCharacterSelection() {
            // Return to character selection without applying changes
            if (window.parent && window.parent.returnToCharacterSelection) {
                window.parent.returnToCharacterSelection();
            } else {
                // Fallback for testing - just close or redirect
                if (window.history.length > 1) {
                    window.history.back();
                } else {
                    window.location.href = 'index.html';
                }
            }
        }
        
        function applyConfigAndStartGame() {
            const finalConfig = generateFinalConfig();
            const selectedCharacter = sessionStorage.getItem('selectedCharacter');
            
            console.log('Applying config to game...');
            
            // Pass the config and character to the main game and start
            if (window.parent && window.parent.applyCustomConfigAndStartGame) {
                window.parent.applyCustomConfigAndStartGame(finalConfig, selectedCharacter);
            } else {
                // Fallback for testing - store in localStorage and redirect
                localStorage.setItem('customGameConfig', JSON.stringify(finalConfig));
                if (selectedCharacter) {
                    sessionStorage.setItem('selectedCharacter', selectedCharacter);
                }
                // Set flag to show success message
                sessionStorage.setItem('settingsApplied', 'true');
                window.location.href = 'index.html';
            }
        }
        
        // Function for parent window to get current config
        function getCurrentConfig() {
            return generateFinalConfig();
        }
        
        // Make functions available globally for parent window access
        window.getCurrentConfig = getCurrentConfig;
        window.applyConfigAndStartGame = applyConfigAndStartGame;
        window.cancelAndReturnToCharacterSelection = cancelAndReturnToCharacterSelection;
        
        // Validation functions
        function updateNumberLineValidation(levelNum, puzzleNum) {
            const lengthInput = document.getElementById(`length-${levelNum}-${puzzleNum}`);
            let length = parseInt(lengthInput.value) || 12;
            
            // Enforce length constraints (5-20)
            if (length < 5) {
                length = 5;
                lengthInput.value = 5;
            } else if (length > 20) {
                length = 20;
                lengthInput.value = 20;
            }
            
            // Update max values for all A, B, C, and Result inputs
            const inputs = ['minA', 'maxA', 'minB', 'maxB', 'maxResult', 'minC', 'maxC'];
            inputs.forEach(inputId => {
                const input = document.getElementById(`${inputId}-${levelNum}-${puzzleNum}`);
                if (input) {
                    input.max = length;
                    // Adjust value if it exceeds new max
                    let value = parseInt(input.value) || 0;
                    if (value > length) {
                        input.value = length;
                    }
                    // Ensure minimum values
                    if (value < 0) {
                        input.value = 0;
                    }
                }
            });
            
            // Special case for maxResult - minimum is 5
            const maxResultInput = document.getElementById(`maxResult-${levelNum}-${puzzleNum}`);
            if (maxResultInput) {
                let value = parseInt(maxResultInput.value) || 5;
                if (value < 5) {
                    maxResultInput.value = 5;
                } else if (value > length) {
                    maxResultInput.value = length;
                }
            }
        }
        
        function updateDivisionValidation(levelNum, puzzleNum) {
            const maxAInput = document.getElementById(`maxA-${levelNum}-${puzzleNum}`);
            const maxBInput = document.getElementById(`maxB-${levelNum}-${puzzleNum}`);
            
            if (maxAInput && maxBInput) {
                let maxA = parseInt(maxAInput.value) || 12;
                
                // Enforce Max A >= 12
                if (maxA < 12) {
                    maxA = 12;
                    maxAInput.value = 12;
                }
                
                // Max B must be less than Max A
                maxBInput.max = maxA - 1;
                let maxB = parseInt(maxBInput.value) || 1;
                
                // Adjust Max B if it's too high or too low
                if (maxB >= maxA) {
                    maxBInput.value = Math.max(1, maxA - 1);
                } else if (maxB < 1) {
                    maxBInput.value = 1;
                }
            }
        }
        
        // Generic validation function for number inputs
        function validateNumberInput(input, min, max) {
            if (!input) return;
            
            let value = parseInt(input.value);
            if (isNaN(value)) {
                input.value = min || 0;
                return;
            }
            
            if (min !== undefined && value < min) {
                input.value = min;
            } else if (max !== undefined && value > max) {
                input.value = max;
            }
        }
        
        // ===== PREVIEW CONFIG MANAGEMENT FUNCTIONS =====
        
        /**
         * Generate preview configuration for a specific puzzle
         * @param {number} levelNum - The level number
         * @param {number} puzzleIndex - The puzzle index (0-based)
         * @returns {Object} Preview configuration object
         */
        function generatePreviewConfig(levelNum, puzzleIndex) {
            const puzzleConfig = getCurrentPuzzleFormData(levelNum, puzzleIndex);
            
            if (!puzzleConfig) {
                console.error(`No puzzle configuration found for level ${levelNum}, puzzle ${puzzleIndex}`);
                return null;
            }
            
            return {
                levels: {
                    "mock": {
                        playable: true,
                        puzzles: [puzzleConfig] // Single puzzle for preview
                    }
                },
                characters: {
                    "PT": {
                        name: "PT the Elephant",
                        movement: "PT-sprite.svg",
                        celebration: "PT-celebrate.png",
                        gameOver: "PT-game-over.png",
                        description: "Preview character"
                    }
                }
            };
        }
        
        /**
         * Get current form data for a specific puzzle
         * @param {number} levelNum - The level number
         * @param {number} puzzleIndex - The puzzle index (0-based)
         * @returns {Object} Current puzzle configuration from form
         */
        function getCurrentPuzzleFormData(levelNum, puzzleIndex) {
            const puzzleNum = puzzleIndex + 1; // Convert to 1-based for DOM IDs
            
            // Get current puzzle type
            const puzzleSelect = document.getElementById(`puzzle-select-${levelNum}-${puzzleNum}`);
            if (!puzzleSelect || !puzzleSelect.value) {
                console.error(`No puzzle type selected for level ${levelNum}, puzzle ${puzzleNum}`);
                return null;
            }
            
            const puzzleType = puzzleSelect.value;
            const puzzleConfig = { type: puzzleType };
            
            // Extract configuration based on puzzle type (using same logic as updatePuzzleConfig)
            switch (puzzleType) {
                case 'word_emoji_matching':
                    const wordListLevel = document.getElementById(`wordListLevel-${levelNum}-${puzzleNum}`)?.value || 'beginner';
                    puzzleConfig.wordListLevel = wordListLevel;
                    puzzleConfig.tracking = {
                        preventRepetition: false, // Disabled for preview - no need to track used words
                        usedWords: [],
                        trackingScope: "level"
                    };
                    break;
                    
                case 'simple_arithmetic':
                    const operations = [];
                    if (document.getElementById(`addition-${levelNum}-${puzzleNum}`)?.checked) operations.push('addition');
                    if (document.getElementById(`subtraction-${levelNum}-${puzzleNum}`)?.checked) operations.push('subtraction');
                    
                    puzzleConfig.operations = operations.length > 0 ? operations : ['addition'];
                    puzzleConfig.limits = {
                        maxA: parseInt(document.getElementById(`maxA-${levelNum}-${puzzleNum}`)?.value) || 10,
                        maxB: parseInt(document.getElementById(`maxB-${levelNum}-${puzzleNum}`)?.value) || 10,
                        maxResult: parseInt(document.getElementById(`maxResult-${levelNum}-${puzzleNum}`)?.value) || 12
                    };
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        maxAttempts: 3,
                        trackingScope: "level"
                    };
                    break;
                    
                case 'digraph_sounds':
                    const selectedDigraphs = [];
                    document.querySelectorAll(`input[name="digraphs-${levelNum}-${puzzleNum}"]:checked`).forEach(checkbox => {
                        selectedDigraphs.push(checkbox.value);
                    });
                    
                    puzzleConfig.digraphs = selectedDigraphs.length > 0 ? selectedDigraphs : ['CH', 'SH', 'TH'];
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        usedDigraphs: [],
                        trackingScope: "level"
                    };
                    break;
                    
                case 'number_line':
                    const nlOperations = Array.from(document.querySelectorAll(`#config-${levelNum}-${puzzleNum} input[type="checkbox"]:checked`))
                        .map(cb => cb.value).filter(v => ['addition', 'subtraction'].includes(v));
                    const terms = document.querySelector(`#config-${levelNum}-${puzzleNum} input[name="terms-${levelNum}-${puzzleNum}"]:checked`)?.value || '2';
                    
                    puzzleConfig.operations = nlOperations.length > 0 ? nlOperations : ['addition'];
                    puzzleConfig.numberLine = {
                        operations: nlOperations.length > 0 ? nlOperations : ['addition'],
                        terms: terms,
                        length: parseInt(document.getElementById(`length-${levelNum}-${puzzleNum}`)?.value) || 12,
                        minA: parseInt(document.getElementById(`minA-${levelNum}-${puzzleNum}`)?.value) || 1,
                        maxA: parseInt(document.getElementById(`maxA-${levelNum}-${puzzleNum}`)?.value) || 8,
                        minB: parseInt(document.getElementById(`minB-${levelNum}-${puzzleNum}`)?.value) || 1,
                        maxB: parseInt(document.getElementById(`maxB-${levelNum}-${puzzleNum}`)?.value) || 8,
                        maxResult: parseInt(document.getElementById(`maxResult-${levelNum}-${puzzleNum}`)?.value) || 12
                    };
                    
                    if (terms === '3') {
                        puzzleConfig.numberLine.minC = parseInt(document.getElementById(`minC-${levelNum}-${puzzleNum}`)?.value) || 1;
                        puzzleConfig.numberLine.maxC = parseInt(document.getElementById(`maxC-${levelNum}-${puzzleNum}`)?.value) || 4;
                    }
                    
                    puzzleConfig.tracking = {
                        preventRepetition: false, // Disabled for preview - no need to track used problems
                        maxAttempts: 3,
                        trackingScope: "level"
                    };
                    break;
                    
                case 'division_visual':
                    puzzleConfig.division = {
                        maxA: parseInt(document.getElementById(`maxA-${levelNum}-${puzzleNum}`)?.value) || 12,
                        maxB: parseInt(document.getElementById(`maxB-${levelNum}-${puzzleNum}`)?.value) || 10,
                        maxAnswer: parseInt(document.getElementById(`maxAnswer-${levelNum}-${puzzleNum}`)?.value) || 10,
                        excludeIdentity: document.getElementById(`excludeIdentity-${levelNum}-${puzzleNum}`)?.checked || false,
                        excludeA1: document.getElementById(`excludeA1-${levelNum}-${puzzleNum}`)?.checked || false
                    };
                    break;
                    
                case 'multiplication_groups':
                    const multOperations = [];
                    if (document.getElementById(`multiplication-${levelNum}-${puzzleNum}`)?.checked) multOperations.push('multiplication');
                    
                    puzzleConfig.operations = multOperations.length > 0 ? multOperations : ['multiplication'];
                    puzzleConfig.multiplication = {
                        maxProduct: parseInt(document.getElementById(`maxProduct-${levelNum}-${puzzleNum}`)?.value) || 20,
                        minFactor: parseInt(document.getElementById(`minFactor-${levelNum}-${puzzleNum}`)?.value) || 2,
                        maxFactor: parseInt(document.getElementById(`maxFactor-${levelNum}-${puzzleNum}`)?.value) || 10,
                        excludeOne: document.getElementById(`excludeOne-${levelNum}-${puzzleNum}`)?.checked || true
                    };
                    break;
                    
                case 'letter_identification':
                    const excludedLetters = [];
                    document.querySelectorAll(`input[type="checkbox"][onchange*="updatePuzzleConfig(${levelNum}, ${puzzleNum})"]:checked`).forEach(checkbox => {
                        if (checkbox.value && checkbox.value.length === 1 && checkbox.value.match(/[A-Z]/)) {
                            excludedLetters.push(checkbox.value);
                        }
                    });
                    
                    puzzleConfig.excludeLetters = excludedLetters;
                    puzzleConfig.tracking = {
                        preventRepetition: false, // Disabled for preview to test different letters
                        usedLetters: [],
                        trackingScope: "level"
                    };
                    break;
                    
                case 'audio_reading':
                    const mode = document.getElementById(`mode-${levelNum}-${puzzleNum}`)?.value || 'match_text_to_speech';
                    const selectedWordLists = [];
                    document.querySelectorAll(`input[name="wordLists-${levelNum}-${puzzleNum}"]:checked`).forEach(checkbox => {
                        selectedWordLists.push(checkbox.value);
                    });
                    
                    puzzleConfig.mode = mode;
                    puzzleConfig.wordLists = selectedWordLists.length > 0 ? selectedWordLists : ['cvc'];
                    break;
                    
                case 'rhyming':
                    puzzleConfig.tracking = {
                        preventRepetition: true,
                        trackingScope: "level"
                    };
                    break;
                    
                default:
                    console.error(`Unknown puzzle type: ${puzzleType}`);
                    return null;
            }
            
            return puzzleConfig;
        }
        
        /**
         * Launch puzzle preview popup
         * @param {number} levelNum - The level number
         * @param {number} puzzleIndex - The puzzle index (0-based)
         */
        async function previewPuzzle(levelNum, puzzleIndex) {
            try {
                // Get current puzzle configuration from form
                const puzzleConfig = getCurrentPuzzleFormData(levelNum, puzzleIndex);
                
                if (!puzzleConfig) {
                    alert('Unable to generate preview. Please check your puzzle configuration.');
                    return;
                }
                
                console.log(`Starting preview for Level ${levelNum}, Puzzle ${puzzleIndex + 1}:`, puzzleConfig);
                
                // Show the modal
                showPuzzlePreviewModal();
                
                // Set up minimal game state for puzzle compatibility
                setupPreviewGameState();
                
                // Trigger the specific puzzle
                await triggerPreviewPuzzleByType(puzzleConfig);
                
            } catch (error) {
                console.error('Failed to launch puzzle preview:', error);
                alert('Failed to launch preview. Please try again.');
            }
        }
        
        /**
         * Show the puzzle preview modal
         */
        function showPuzzlePreviewModal() {
            window.isPreviewMode = true; // Set preview mode flag
            
            const modal = document.getElementById('puzzleModal');
            modal.style.setProperty('display', 'flex', 'important'); // Override !important rule
            
            // Explicitly ensure centering (in case of CSS conflicts)
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            
            // Clear previous content
            document.getElementById('puzzleQuestion').textContent = '';
            document.getElementById('puzzleOptions').innerHTML = '';
            document.getElementById('puzzleResult').innerHTML = '';
        }
        
        /**
         * Close the puzzle preview modal
         */
        function closePuzzlePreview() {
            window.isPreviewMode = false; // Clear preview mode flag
            
            const modal = document.getElementById('puzzleModal');
            modal.style.setProperty('display', 'none', 'important'); // Override !important rule
            
            // Clean up any puzzle-specific elements
            document.getElementById('puzzleOptions').innerHTML = '';
            document.getElementById('puzzleOptions').className = ''; // Reset any puzzle-specific classes
            document.getElementById('puzzleResult').innerHTML = '';
            
            // Clean up puzzle instances to prevent memory leaks
            if (window.letterPuzzleInstance) {
                // Stop any playing audio
                if (window.letterPuzzleInstance.audioCache) {
                    Object.values(window.letterPuzzleInstance.audioCache).forEach(audio => {
                        audio.pause();
                        audio.currentTime = 0;
                    });
                }
                window.letterPuzzleInstance = null;
            }
            
            if (window.multiplicationPuzzleInstance) {
                window.multiplicationPuzzleInstance = null;
            }
            
            if (window.divisionPuzzleInstance) {
                window.divisionPuzzleInstance = null;
            }
            
            if (window.digraphPuzzleInstance) {
                window.digraphPuzzleInstance = null;
            }
            
            // Restore any DOM overrides
            if (window.previewModalOverride) {
                window.previewModalOverride.restore();
            }
        }
        
        /**
         * Load digraph data for DigraphPuzzle preview
         */
        async function loadDigraphDataForPreview() {
            if (!window.game.digraphEmojis || !window.game.digraphSounds || !window.game.emojiNames) {
                try {
                    const [emojiResponse, soundResponse, namesResponse] = await Promise.all([
                        fetch('digraph-emojis.txt?v=' + Date.now()),
                        fetch('digraph-sounds.txt?v=' + Date.now()),
                        fetch('emoji-names.txt?v=' + Date.now())
                    ]);
                    
                    // Parse digraph emojis (CSV format: CH,🧀,🍒,🪑,⛓️)
                    const emojiText = await emojiResponse.text();
                    window.game.digraphEmojis = {};
                    emojiText.split('\n').forEach(line => {
                        if (line.trim()) {
                            const parts = line.split(',');
                            if (parts.length > 1) {
                                window.game.digraphEmojis[parts[0]] = parts.slice(1);
                            }
                        }
                    });
                    
                    // Parse digraph sounds (CSV format: CH,cha)
                    const soundText = await soundResponse.text();
                    window.game.digraphSounds = {};
                    soundText.split('\n').forEach(line => {
                        if (line.trim()) {
                            const parts = line.split(',');
                            if (parts.length === 2) {
                                window.game.digraphSounds[parts[0]] = parts[1];
                            }
                        }
                    });
                    
                    // Parse emoji names (CSV format: 🍎,apple)
                    const namesText = await namesResponse.text();
                    window.game.emojiNames = {};
                    namesText.split('\n').forEach(line => {
                        if (line.trim()) {
                            const parts = line.split(',');
                            if (parts.length === 2) {
                                window.game.emojiNames[parts[0]] = parts[1];
                            }
                        }
                    });
                    
                    console.log('Digraph data loaded for preview:', {
                        digraphs: Object.keys(window.game.digraphEmojis).length,
                        sounds: Object.keys(window.game.digraphSounds).length,
                        names: Object.keys(window.game.emojiNames).length
                    });
                } catch (error) {
                    console.error('Failed to load digraph data:', error);
                }
            }
        }

        /**
         * Set up minimal game state for puzzle compatibility
         */
        function setupPreviewGameState() {
            // Create minimal game object for puzzle scripts
            if (!window.game) {
                window.game = {};
            }
            
            window.game.level = 'preview';
            window.game.score = 5;
            window.game.difficulty = 'easy';
            window.game.selectedDifficulty = 1; // CRITICAL: Must be NUMBER like real game, not string
            window.game.character = 'PT';
            window.game.puzzleActive = true;
            window.game.testMode = false; // Add testMode property like real game
            
            // Initialize legacy compatibility globals for multiplication puzzle
            if (!window.game.usedMultiplicationProblems) {
                window.game.usedMultiplicationProblems = [];
            }
            
            // Initialize legacy compatibility globals for division puzzle
            if (!window.game.hasUsedAnswerOne) {
                window.game.hasUsedAnswerOne = false;
            }
            if (!window.game.hasUsedDivideByOne) {
                window.game.hasUsedDivideByOne = false;
            }
            if (!window.game.usedDivisionProblems) {
                window.game.usedDivisionProblems = new Set();
            }
            
            // Create minimal configManager for puzzle compatibility
            if (!window.configManager) {
                window.configManager = {
                    getPuzzleConfig: function(level, puzzleType) {
                        // Return the current puzzle config from the preview
                        return window.currentPreviewPuzzleConfig || {};
                    }
                };
            }
            
            // PT sprite should already be preloaded during page initialization
            
            // Map modal elements - now using EXACT same structure as real game
            window.puzzleModal = document.getElementById('puzzleModal');
            window.puzzleContent = document.getElementById('puzzleContent');
            window.puzzleTitle = document.getElementById('puzzleTitle');
            window.puzzleQuestion = document.getElementById('puzzleQuestion');
            window.puzzleOptions = document.getElementById('puzzleOptions');
            window.puzzleResult = document.getElementById('puzzleResult');
        }
        
        /**
         * Trigger puzzle based on type
         */
        async function triggerPreviewPuzzleByType(puzzleConfig) {
            const puzzleType = puzzleConfig.type;
            
            try {
                // Store current config for puzzle scripts to access
                window.currentPreviewPuzzleConfig = puzzleConfig;
                
                // Reset puzzle options styling (clean slate for each puzzle)
                document.getElementById('puzzleOptions').className = '';
                
                // Update modal title
                document.getElementById('puzzleTitle').textContent = `Preview: ${getPuzzleTypeName(puzzleType)}`;
                
                switch (puzzleType) {
                    case 'word_emoji_matching':
                        if (typeof WordEmojiPuzzle === 'function') {
                            // Add specific styling class for word emoji layout
                            document.getElementById('puzzleOptions').className = 'word-emoji-options';
                            
                            const mockDoor = createWordEmojiDoorMock(puzzleConfig);
                            const puzzle = new WordEmojiPuzzle(mockDoor);
                            await puzzle.render(); // Note: async render method
                        } else {
                            showPreviewError('Word emoji puzzle function not available');
                        }
                        break;
                        
                    case 'simple_arithmetic':
                        if (typeof SimpleMathPuzzle === 'function') {
                            // TODO: Implement SimpleMathPuzzle preview
                            showPreviewError('Simple math puzzle preview not yet implemented');
                        } else {
                            showPreviewError('Simple math puzzle function not available');
                        }
                        break;
                        
                    case 'digraph_sounds':
                        if (typeof DigraphPuzzle === 'function') {
                            // Load all digraph data - puzzle will handle selection via config
                            await loadDigraphDataForPreview();
                            const mockDoor = createDigraphDoorMock(puzzleConfig);
                            window.digraphPuzzleInstance = new DigraphPuzzle(mockDoor);
                            
                            // Override setTimeout to intercept the 1500ms delay used by DigraphPuzzle
                            const originalSetTimeout = window.setTimeout;
                            window.setTimeout = function(callback, delay) {
                                // If this is the 1500ms timeout from DigraphPuzzle for modal closing
                                if (window.isPreviewMode && delay === 1500 && callback.toString().includes('puzzleModal')) {
                                    // Use much shorter delay for preview
                                    return originalSetTimeout(() => {
                                        closePuzzlePreview();
                                    }, 500);
                                }
                                // For all other timeouts, use original
                                return originalSetTimeout(callback, delay);
                            };
                            
                            await digraphPuzzleInstance.render();
                            
                            // Store the original setTimeout override for cleanup
                            window.previewModalOverride = {
                                originalSetTimeout: originalSetTimeout,
                                restore: function() {
                                    window.setTimeout = originalSetTimeout;
                                    window.previewModalOverride = null;
                                }
                            };
                        } else {
                            showPreviewError('Digraph puzzle function not available');
                        }
                        break;
                        
                    case 'number_line':
                        if (typeof NumberLinePuzzle === 'function') {
                            // Create comprehensive door mock with canvas system
                            const mockDoor = createNumberLineDoorMock(puzzleConfig);
                            const puzzle = new NumberLinePuzzle(mockDoor);
                            puzzle.render();
                        } else {
                            showPreviewError('Number line puzzle function not available');
                        }
                        break;
                        
                    case 'division_visual':
                        if (typeof DivisionPuzzle === 'function') {
                            const mockDoor = createDivisionDoorMock(puzzleConfig);
                            window.divisionPuzzleInstance = new DivisionPuzzle(mockDoor);
                            
                            // Override setTimeout to intercept the 1500ms delay used by DivisionPuzzle
                            const originalSetTimeout = window.setTimeout;
                            window.setTimeout = function(callback, delay) {
                                // If this is the 1500ms timeout from DivisionPuzzle for modal closing
                                if (window.isPreviewMode && delay === 1500 && callback.toString().includes('puzzleModal')) {
                                    // Use much shorter delay for preview
                                    return originalSetTimeout(() => {
                                        closePuzzlePreview();
                                    }, 500);
                                }
                                // For all other timeouts, use original
                                return originalSetTimeout(callback, delay);
                            };
                            
                            divisionPuzzleInstance.render(); // Synchronous render
                            
                            // Store the original setTimeout override for cleanup
                            window.previewModalOverride = {
                                originalSetTimeout: originalSetTimeout,
                                restore: function() {
                                    window.setTimeout = originalSetTimeout;
                                    window.previewModalOverride = null;
                                }
                            };
                        } else {
                            showPreviewError('Division puzzle function not available');
                        }
                        break;
                        
                    case 'multiplication_groups':
                        if (typeof MultiplicationGroupsPuzzle === 'function') {
                            const mockDoor = createMultiplicationDoorMock(puzzleConfig);
                            window.multiplicationPuzzleInstance = new MultiplicationGroupsPuzzle(mockDoor);
                            
                            // Override setTimeout to intercept the 1500ms delay used by MultiplicationGroupsPuzzle
                            const originalSetTimeout = window.setTimeout;
                            window.setTimeout = function(callback, delay) {
                                // If this is the 1500ms timeout from MultiplicationGroupsPuzzle for modal closing
                                if (window.isPreviewMode && delay === 1500 && callback.toString().includes('puzzleModal')) {
                                    // Use much shorter delay for preview
                                    return originalSetTimeout(() => {
                                        closePuzzlePreview();
                                    }, 500);
                                }
                                // For all other timeouts, use original
                                return originalSetTimeout(callback, delay);
                            };
                            
                            multiplicationPuzzleInstance.showModal(); // NOTE: Uses showModal() not render()
                            
                            // Store the original setTimeout override for cleanup
                            window.previewModalOverride = {
                                originalSetTimeout: originalSetTimeout,
                                restore: function() {
                                    window.setTimeout = originalSetTimeout;
                                    window.previewModalOverride = null;
                                }
                            };
                        } else {
                            showPreviewError('Multiplication puzzle function not available');
                        }
                        break;
                        
                    case 'letter_identification':
                        if (typeof LetterIdentificationPuzzle === 'function') {
                            // Add specific styling class for letter identification layout
                            document.getElementById('puzzleOptions').className = 'letter-identification-options';
                            
                            const mockDoor = createLetterIdentificationDoorMock(puzzleConfig);
                            window.letterPuzzleInstance = new LetterIdentificationPuzzle(mockDoor);
                            
                            // Override setTimeout to intercept the 2000ms delay used by LetterIdentificationPuzzle
                            const originalSetTimeout = window.setTimeout;
                            window.setTimeout = function(callback, delay) {
                                // If this is the 2000ms timeout from LetterIdentificationPuzzle for modal closing
                                if (window.isPreviewMode && delay === 2000 && callback.toString().includes('puzzleModal')) {
                                    // Use much shorter delay for preview
                                    return originalSetTimeout(() => {
                                        closePuzzlePreview();
                                    }, 500);
                                }
                                // For all other timeouts, use original
                                return originalSetTimeout(callback, delay);
                            };
                            
                            // Render the puzzle with unmodified logic
                            letterPuzzleInstance.render();
                            
                            // Store the original setTimeout override for cleanup
                            window.previewModalOverride = {
                                originalSetTimeout: originalSetTimeout,
                                restore: function() {
                                    window.setTimeout = originalSetTimeout;
                                    window.previewModalOverride = null;
                                }
                            };
                            
                            // Force audio preloading for better performance in preview
                            if (letterPuzzleInstance.audioCache) {
                                Object.keys(letterPuzzleInstance.audioCache).forEach(letter => {
                                    const audio = letterPuzzleInstance.audioCache[letter];
                                    audio.load(); // Force immediate load
                                });
                            }
                        } else {
                            showPreviewError('Letter identification puzzle function not available');
                        }
                        break;
                        
                    case 'audio_reading':
                        if (typeof AudioReadingPuzzle === 'function') {
                            // TODO: Implement AudioReadingPuzzle preview
                            showPreviewError('Audio reading puzzle preview not yet implemented');
                        } else {
                            showPreviewError('Audio reading puzzle function not available');
                        }
                        break;
                        
                    case 'rhyming':
                        // Rhyming puzzle is integrated in main game - we'll need to handle this specially
                        showPreviewError('Rhyming puzzle preview not yet implemented');
                        break;
                        
                    default:
                        showPreviewError(`Unknown puzzle type: ${puzzleType}`);
                        break;
                }
            } catch (error) {
                console.error('Error triggering puzzle preview:', error);
                showPreviewError('Failed to load puzzle preview');
            }
        }
        
        /**
         * Get user-friendly puzzle type name
         */
        function getPuzzleTypeName(puzzleType) {
            const typeNames = {
                'word_emoji_matching': 'Word Emoji Matching',
                'simple_arithmetic': 'Simple Math',
                'digraph_sounds': 'Digraph Sounds',
                'number_line': 'Number Line',
                'division_visual': 'Division Visual',
                'multiplication_groups': 'Multiplication Groups',
                'letter_identification': 'Letter Identification',
                'audio_reading': 'Audio Reading',
                'rhyming': 'Rhyming'
            };
            return typeNames[puzzleType] || puzzleType;
        }
        
        /**
         * Show error in preview modal
         */
        function showPreviewError(message) {
            document.getElementById('puzzleQuestion').textContent = 'Preview Error';
            document.getElementById('puzzleOptions').innerHTML = `
                <div style="text-align: center; color: #d63384; padding: 20px;">
                    <p>${message}</p>
                    <button onclick="closePuzzlePreview()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                </div>
            `;
        }
        
        /**
         * Handle puzzle completion (called by puzzle scripts)
         */
        function handlePuzzleCompletion(isCorrect) {
            console.log('Preview puzzle completed:', isCorrect);
            
            if (isCorrect) {
                // Show success message briefly, then close modal
                document.getElementById('puzzleResult').innerHTML = '👍 <span style="color: #28a745;">Correct!</span>';
                setTimeout(() => {
                    closePuzzlePreview();
                }, 1500);
            } else {
                // Show failure message (puzzle stays open like in real game)
                document.getElementById('puzzleResult').innerHTML = '👎 <span style="color: #dc3545;">Try again!</span>';
            }
        }
        
        /**
         * Create comprehensive door mock for NumberLinePuzzle
         */
        function createNumberLineDoorMock(puzzleConfig) {
            return {
                type: 'number_line',
                config: puzzleConfig,
                foxPosition: 0,
                mathStartPosition: 0,
                ptCanvases: {} // NumberLinePuzzle will populate this during initializeNumberLine()
            };
        }

        /**
         * Create door mock for WordEmojiPuzzle (simpler than NumberLine - no canvas system needed)
         */
        function createWordEmojiDoorMock(puzzleConfig) {
            return {
                type: 'word_emoji_matching',
                config: puzzleConfig
                // Simpler than NumberLinePuzzle - no canvas system needed
            };
        }

        /**
         * Create door mock for LetterIdentificationPuzzle
         */
        function createLetterIdentificationDoorMock(puzzleConfig) {
            return {
                type: 'letter_identification',
                config: puzzleConfig
                // Simple door object - puzzle manages complex state internally
            };
        }

        /**
         * Create door mock for MultiplicationGroupsPuzzle
         */
        function createMultiplicationDoorMock(puzzleConfig) {
            return {
                type: 'multiplication_groups',
                config: puzzleConfig
                // Simple door object - puzzle manages its own state
            };
        }

        /**
         * Create door mock for DivisionPuzzle
         */
        function createDivisionDoorMock(puzzleConfig) {
            return {
                type: 'division_visual',
                config: puzzleConfig
                // Simple door object - puzzle manages its own state
            };
        }

        /**
         * Create door mock for DigraphPuzzle
         */
        function createDigraphDoorMock(puzzleConfig) {
            return {
                type: 'digraph_sounds',
                config: puzzleConfig
                // Simple door object - puzzle manages its own state
            };
        }

        /**
         * Number Line Puzzle Integration for Preview (copied from main game)
         */
        function showNumberLinePuzzle(door) {
            // Only handle number_line door type
            if (door.type === 'number_line') {
                console.log(`Using modular number line puzzle for preview`);
                const puzzle = new NumberLinePuzzle(door);
                puzzle.render();
                return true; // Indicates modular system was used
            }
            
            return false; // Fall back to original system
        }
        
        // Make functions available globally for puzzle scripts (exact signatures from real game)
        window.showCelebration = function() { /* No-op for preview */ };
        window.updateScore = function(points) { /* No-op for preview */ };
        window.getCurrentLevel = function() { return 'preview'; };
        window.getCurrentDifficulty = function() { return 'easy'; };
        window.speakEmojiWord = function(emoji) { /* No-op for preview */ };
        window.completeRocketBoostMovement = function() { /* No-op for preview */ };
        window.closePuzzlePreview = closePuzzlePreview;
        window.showNumberLinePuzzle = showNumberLinePuzzle;
        
        // Store flag to track when we're in preview mode
        window.isPreviewMode = false;
        window.checkAnswer = function(correct, type, door, buttonElement, selectedEmoji = null) {
            // EXACT replica of real game's checkAnswer function
            const result = document.getElementById('puzzleResult');
            
            // Track attempts for this problem (like real game)
            if (!door.currentProblemAttempts) door.currentProblemAttempts = 0;
            door.currentProblemAttempts++;
            
            if (correct) {
                result.innerHTML = '👍'; // EXACT real game feedback - just emoji
                result.style.color = 'green';
                result.style.fontSize = '48px'; // Make thumbs up bigger like real game
                door.open = true;
                
                // Reset attempt counters like real game
                door.currentProblemAttempts = 0;
                door.failedAttempts = 0;
                
                // Change door color like real game
                door.color = '#B8F2B8';
                
                setTimeout(() => {
                    document.getElementById('puzzleModal').style.setProperty('display', 'none', 'important');
                    result.innerHTML = '';
                    result.style.fontSize = ''; // Reset font size
                    window.game.puzzleActive = false;
                }, 800); // Same timing as real game
            } else {
                result.innerHTML = '👎'; // EXACT real game feedback - just emoji
                result.style.color = 'red';
                
                // Disable the wrong answer button like real game
                buttonElement.disabled = true;
                buttonElement.style.backgroundColor = '#ccc';
                buttonElement.style.cursor = 'not-allowed';
                
                // Track failed attempts like real game
                if (!door.failedAttempts) door.failedAttempts = 0;
                door.failedAttempts++;
            }
        };
        
        // Make preview function available globally
        window.previewPuzzle = previewPuzzle;
        
        // Add keyboard support for modal
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('puzzleModal');
                if (modal && modal.style.display === 'flex') {
                    closePuzzlePreview();
                }
            }
        });
        
        // Close modal when clicking overlay (but not content)
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('puzzleModal');
            if (event.target === modal) {
                closePuzzlePreview();
            }
        });
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializePage);
    </script>
</body>
</html>